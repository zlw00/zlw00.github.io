<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>百度又一面</title>
    <link href="/2023/03/20/%E7%99%BE%E5%BA%A6%E5%8F%88%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/03/20/%E7%99%BE%E5%BA%A6%E5%8F%88%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="说一下final，final底层"><a href="#说一下final，final底层" class="headerlink" title="说一下final，final底层"></a>说一下final，final底层</h1><h1 id="说一下什么是对象"><a href="#说一下什么是对象" class="headerlink" title="说一下什么是对象"></a>说一下什么是对象</h1><h1 id="hashcode存储在哪，为什么要有它"><a href="#hashcode存储在哪，为什么要有它" class="headerlink" title="hashcode存储在哪，为什么要有它"></a>hashcode存储在哪，为什么要有它</h1><h1 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h1><h1 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h1><h1 id="什么是引用，引用存放在哪"><a href="#什么是引用，引用存放在哪" class="headerlink" title="什么是引用，引用存放在哪"></a>什么是引用，引用存放在哪</h1><h1 id="接口和抽象类的区别，为什么要有接口和抽象类"><a href="#接口和抽象类的区别，为什么要有接口和抽象类" class="headerlink" title="接口和抽象类的区别，为什么要有接口和抽象类"></a>接口和抽象类的区别，为什么要有接口和抽象类</h1><h1 id="java中的锁有哪几种，分别用在什么情况"><a href="#java中的锁有哪几种，分别用在什么情况" class="headerlink" title="java中的锁有哪几种，分别用在什么情况"></a>java中的锁有哪几种，分别用在什么情况</h1><h1 id="x3D-x3D-和equals-的区别"><a href="#x3D-x3D-和equals-的区别" class="headerlink" title="&#x3D;&#x3D;和equals()的区别"></a>&#x3D;&#x3D;和equals()的区别</h1><h1 id="基本类型有哪些"><a href="#基本类型有哪些" class="headerlink" title="基本类型有哪些"></a>基本类型有哪些</h1><h1 id="引用类型有哪些"><a href="#引用类型有哪些" class="headerlink" title="引用类型有哪些"></a>引用类型有哪些</h1><h1 id="String的基本方法"><a href="#String的基本方法" class="headerlink" title="String的基本方法"></a>String的基本方法</h1><h1 id="StringBuffer和StringBuilder的区别"><a href="#StringBuffer和StringBuilder的区别" class="headerlink" title="StringBuffer和StringBuilder的区别"></a>StringBuffer和StringBuilder的区别</h1><h1 id="JVM和JRE的区别"><a href="#JVM和JRE的区别" class="headerlink" title="JVM和JRE的区别"></a>JVM和JRE的区别</h1><h1 id="java的IO流"><a href="#java的IO流" class="headerlink" title="java的IO流"></a>java的IO流</h1><h1 id="说说BIO和NIO"><a href="#说说BIO和NIO" class="headerlink" title="说说BIO和NIO"></a>说说BIO和NIO</h1><h1 id="AOP和IOC"><a href="#AOP和IOC" class="headerlink" title="AOP和IOC"></a>AOP和IOC</h1><h1 id="SpringBoot怎么用的"><a href="#SpringBoot怎么用的" class="headerlink" title="SpringBoot怎么用的"></a>SpringBoot怎么用的</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>春招</category>
      
      <category>百度</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>小米一面</title>
    <link href="/2023/03/02/%E5%B0%8F%E7%B1%B3%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/03/02/%E5%B0%8F%E7%B1%B3%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="TreeMap和LinkedHashMap的区别"><a href="#TreeMap和LinkedHashMap的区别" class="headerlink" title="TreeMap和LinkedHashMap的区别"></a>TreeMap和LinkedHashMap的区别</h1><h1 id="支付之后，怎么知道已经支付成功了"><a href="#支付之后，怎么知道已经支付成功了" class="headerlink" title="支付之后，怎么知道已经支付成功了"></a>支付之后，怎么知道已经支付成功了</h1><h1 id="手写实现paseInt-方法"><a href="#手写实现paseInt-方法" class="headerlink" title="手写实现paseInt()方法"></a>手写实现paseInt()方法</h1><h1 id="IP报文头都包含什么"><a href="#IP报文头都包含什么" class="headerlink" title="IP报文头都包含什么"></a>IP报文头都包含什么</h1><h1 id="说一下Mysql的版本控制"><a href="#说一下Mysql的版本控制" class="headerlink" title="说一下Mysql的版本控制"></a>说一下Mysql的版本控制</h1><h1 id="redis有1G的存储空间，一直加入Kb的文件，会怎么样，怎么处理"><a href="#redis有1G的存储空间，一直加入Kb的文件，会怎么样，怎么处理" class="headerlink" title="redis有1G的存储空间，一直加入Kb的文件，会怎么样，怎么处理"></a>redis有1G的存储空间，一直加入Kb的文件，会怎么样，怎么处理</h1><h1 id="创建对象会在哪？是所有的都在堆中吗"><a href="#创建对象会在哪？是所有的都在堆中吗" class="headerlink" title="创建对象会在哪？是所有的都在堆中吗"></a>创建对象会在哪？是所有的都在堆中吗</h1><h1 id="二叉搜索数找到第K个大的数，说一下想法"><a href="#二叉搜索数找到第K个大的数，说一下想法" class="headerlink" title="二叉搜索数找到第K个大的数，说一下想法"></a>二叉搜索数找到第K个大的数，说一下想法</h1><h1 id="CMS回收器的过程，里面的几个标记"><a href="#CMS回收器的过程，里面的几个标记" class="headerlink" title="CMS回收器的过程，里面的几个标记"></a>CMS回收器的过程，里面的几个标记</h1><h1 id="计算机网络几层的协议"><a href="#计算机网络几层的协议" class="headerlink" title="计算机网络几层的协议"></a>计算机网络几层的协议</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>春招</category>
      
      <category>百度</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>百度一面</title>
    <link href="/2023/02/20/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/"/>
    <url>/2023/02/20/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="手写快速排序"><a href="#手写快速排序" class="headerlink" title="手写快速排序"></a>手写快速排序</h1><h1 id="mysql开启事务的命令"><a href="#mysql开启事务的命令" class="headerlink" title="mysql开启事务的命令"></a>mysql开启事务的命令</h1><p><code>show engines</code> 命令可以查看mysql存储引擎支持事务的情况。</p><p><img src="/2023/02/20/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/image-20230303131345866.png" alt="image-20230303131345866"></p><p><strong>开启事务：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN;<br># 或者<br>START TRANSACTION；<br></code></pre></td></tr></table></figure><h1 id="Mysql查询表字段的命令"><a href="#Mysql查询表字段的命令" class="headerlink" title="Mysql查询表字段的命令"></a>Mysql查询表字段的命令</h1><p>查询表的字段名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>select COLUMN_NAME from information_schema.COLUMNS where table_name = &#x27;goods&#x27;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/20/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/image-20230303134641251.png" alt="image-20230303134641251"></p><p>查询表的字段名，包含约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show full COLUMNs from goods<br></code></pre></td></tr></table></figure><p><img src="/2023/02/20/%E7%99%BE%E5%BA%A6%E4%B8%80%E9%9D%A2/image-20230303134634726.png" alt="image-20230303134634726"></p><h1 id="Mysql有哪些存储引擎，有什么区别"><a href="#Mysql有哪些存储引擎，有什么区别" class="headerlink" title="Mysql有哪些存储引擎，有什么区别"></a>Mysql有哪些存储引擎，有什么区别</h1><p>mysql中四种常用的存储引擎：</p><blockquote><p> MyISAM存储引擎、innoDB存储引擎、MEMORY存储引擎、ARCHIVE存储引擎。</p></blockquote><p><strong>区别：</strong></p><ul><li><p>InnoDB：支持事务处理（实现了mysql标准定义了四个隔离级别，具有提交和回滚事务的能力），支持外键，支持崩溃修复能力（redo log），支持并发控制（支持行级锁），如果对事务的完整性比较高，需要频繁更新和删除操作的数据库，则可以选择InnoDB。</p></li><li><p>MyISAM：插入数据快，如果表主要用于插入记录和读出记录的那么选择MyISAM能实现高效率的处理。</p></li><li><p>MEMORY：所有的数据都存储在内存中，数据的处理速度快，但安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。MySQL中使用该引擎作为临时表，存放查询的中间结果</p></li><li><p>Archive：如果只有INSERT和SELECT操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archiv</p></li></ul><h1 id="InnoDB的作用"><a href="#InnoDB的作用" class="headerlink" title="InnoDB的作用"></a>InnoDB的作用</h1><p>为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL Server的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL Server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p><h1 id="写一下json格式"><a href="#写一下json格式" class="headerlink" title="写一下json格式"></a>写一下json格式</h1><p><strong>json的语法规则：</strong></p><ul><li>数组（Array）用方括号(“[]”)表示。</li><li>对象（0bject）用大括号(“{}”)表示。</li><li>名称&#x2F;值对(name&#x2F;value）组合成数组和对象。</li><li>名称(name）置于双引号中，值（value）有字符串、数值、布尔值、null、对象和数组。</li><li>并列的数据之间用逗号(“,”）分隔</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xdr630&quot;</span>,<br><span class="hljs-string">&quot;favorite&quot;</span>: <span class="hljs-string">&quot;programming&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="ping是网络层中的哪个协议"><a href="#ping是网络层中的哪个协议" class="headerlink" title="ping是网络层中的哪个协议"></a>ping是网络层中的哪个协议</h1><p>Ping使用的是网络层的ICMP协议。</p><p>Ping命令是一种使用ICMP协议的网络工具，用于测试主机之间的可达性和网络连接质量。</p><p>Ping测试是一个简单但有效的网络工具，可以帮助管理员诊断网络故障和测试网络连接质量。</p><h1 id="http响应码501，502，503，504都是什么"><a href="#http响应码501，502，503，504都是什么" class="headerlink" title="http响应码501，502，503，504都是什么"></a>http响应码501，502，503，504都是什么</h1><p>500(服务器内部错误)：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</p><p>501(尚未实施)：服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</p><p>502(错误网关)：服务器作为网关或代理，从上游服务器收到无效响应。</p><p>503(服务不可用)：服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态。</p><p>504(网关超时)：服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p><p>505(HTTP 版本不受支持)：服务器不支持请求中所用的 HTTP 版本。</p><h1 id="linux查询端口号命令"><a href="#linux查询端口号命令" class="headerlink" title="linux查询端口号命令"></a>linux查询端口号命令</h1><p><strong>第一种：lsof命令</strong>：lsof 可查看端口占用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">lsof -i:端口号<br></code></pre></td></tr></table></figure><p><strong>第二种：netstat -tunlp命令</strong>：用于显示 tcp，udp 的端口和进程等相关情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">netstat -nltp | grep 端口号<br></code></pre></td></tr></table></figure><h1 id="联合索引ABC，能访问什么情况，什么情况不能访问"><a href="#联合索引ABC，能访问什么情况，什么情况不能访问" class="headerlink" title="联合索引ABC，能访问什么情况，什么情况不能访问"></a>联合索引ABC，能访问什么情况，什么情况不能访问</h1><p>查询的条件中A必须存在，否则失效。</p><p>中间不能跳过某一列，否则该列后面的字段索引将失效。例如AC，则索引字段只用到了A。</p><h1 id="mysql使用事务"><a href="#mysql使用事务" class="headerlink" title="mysql使用事务"></a>mysql使用事务</h1><h1 id="插入多条数据时要不要开启事务"><a href="#插入多条数据时要不要开启事务" class="headerlink" title="插入多条数据时要不要开启事务"></a>插入多条数据时要不要开启事务</h1><p>要</p><h1 id="什么情况下使用AOP，AOP使用到了哪些注解"><a href="#什么情况下使用AOP，AOP使用到了哪些注解" class="headerlink" title="什么情况下使用AOP，AOP使用到了哪些注解"></a>什么情况下使用AOP，AOP使用到了哪些注解</h1><h1 id="基础不好，推荐看书：Mysql必知必会-和-linux菜鸟私房菜什么情况下"><a href="#基础不好，推荐看书：Mysql必知必会-和-linux菜鸟私房菜什么情况下" class="headerlink" title="基础不好，推荐看书：Mysql必知必会 和 linux菜鸟私房菜什么情况下"></a>基础不好，推荐看书：Mysql必知必会 和 linux菜鸟私房菜什么情况下</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>春招</category>
      
      <category>百度</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>寻找重复数</title>
    <link href="/2022/12/29/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <url>/2022/12/29/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode-287：寻找重复数"><a href="#leetCode-287：寻找重复数" class="headerlink" title="leetCode-287：寻找重复数"></a>leetCode-287：寻找重复数</h1><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong>。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>自己的思路，通过原地哈希的算法进行，但之后读题才发现，不能修改原数组。。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">while</span> (nums[i]!=i+<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span> (nums[i]==nums[nums[i]-<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> nums[i];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[nums[i]-<span class="hljs-number">1</span>];<br>                nums[a-<span class="hljs-number">1</span>] = a;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>通过二分法，因为题目中所给数组的范围在[1,n]之间，数量为n+1，因为有一个数重复。</p><p>因此，我们用二分方法可以通过数字出现的次数进行二分。</p><p>例如，这个没有重复的数组[1,2,3,4]：</p><blockquote><p> 则&lt;&#x3D;1的数只有一个，&lt;&#x3D;2的数只有两个，&lt;&#x3D;3的数只有三个，&lt;&#x3D;4的数只有四个</p></blockquote><p>则如果下面这个有重复数字的数组为：[1,3,4,2,2]</p><blockquote><p>若&lt;&#x3D;1的数只有一个，说明重复的数在1右侧，反之说明重复的数在1左侧，<br>若&lt;&#x3D;2的数只有两个，说明重复的数在2右侧，反之说明重复的数在2左侧<br>若&lt;&#x3D;3的数只有三个，说明重复的数在3右侧，反之说明重复的数在3左侧<br>若&lt;&#x3D;4的数只有四个，说明重复的数在4右侧，反之说明重复的数在4左侧</p></blockquote><p><strong>因为如果小于某一个数的数量大于这个数，就说明重复数一定出现在小于等于这个数的数字中。因此就可以使用二分法来控制搜索的范围，是在mid的前面（也就是小于等于该数）还是后面</strong></p><p><strong>代码为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>                <span class="hljs-keyword">if</span> (nums[i]&lt;=mid) count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (count&gt;mid) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><p>通过快慢指针的算法，如果数组中出现重复数字，通过索引指向的数字去找下一个索引的数，可以看作是一个循环链表。</p><p>如果没有重复的数组：[1,2,3,4]</p><p>0-&gt;1<br>1-&gt;3<br>2-&gt;4<br>3-&gt;2<br>我们从下标为 <code>0</code> 出发，根据 <code>f(n)</code> 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推，直到下标超界。这样可以产生一个类似链表一样的序列。<br><code>0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;null</code></p><p>如果有重复数字的数组：[1,3,4,2,2]</p><p>其映射关系 <code>n-&gt;f(n)</code> 为：<br>0-&gt;1<br>1-&gt;3<br>2-&gt;4<br>3-&gt;2<br>4-&gt;2</p><p>以此类推产生一个类似链表一样的序列。<br><code>0-&gt;1-&gt;3-&gt;2-&gt;4-&gt;2-&gt;4-&gt;2-&gt;……</code></p><p>可以抽象为下图：</p><p><img src="/2022/12/29/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png" alt="287.png"></p><p>综上<br>1.数组中有一个重复的整数 &lt;&#x3D;&#x3D;&gt; 链表中存在环<br>2.找到数组中的重复整数 &lt;&#x3D;&#x3D;&gt; 找到链表的环入口</p><p>因此：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">题中慢指针走一步 slow <span class="hljs-operator">=</span> slow.next <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; 本题 slow <span class="hljs-operator">=</span> nums[slow]<br>题中快指针走两步 fast <span class="hljs-operator">=</span> fast.next.next <span class="hljs-operator">=</span><span class="hljs-operator">=</span>&gt; 本题 fast <span class="hljs-operator">=</span> nums[nums[fast]]<br></code></pre></td></tr></table></figure><p><strong>也就转化了，求循环链表中环的入口的做法一样。</strong></p><p>（1）快慢指针走，如果相等则停止。</p><p>（2）快指针指向第一个，慢指针不动，两个指针一次走一步，相等为结果。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        slow = nums[slow];<br>        fast = nums[nums[fast]];<br>        <span class="hljs-keyword">while</span> (nums[slow]!=nums[fast])&#123;<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> slow;<br>        <span class="hljs-keyword">while</span> (nums[p1]!=nums[p2])&#123;<br>            p1 = nums[p1];<br>            p2 = nums[p2];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[p1];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第七次-325场周赛</title>
    <link href="/2022/12/25/%E7%AC%AC%E4%B8%83%E6%AC%A1-325%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/12/25/%E7%AC%AC%E4%B8%83%E6%AC%A1-325%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1-到目标字符串的最短距离（6269）"><a href="#算法1-到目标字符串的最短距离（6269）" class="headerlink" title="算法1:到目标字符串的最短距离（6269）"></a>算法1:到目标字符串的最短距离（6269）</h1><p>给你一个下标从 <strong>0</strong> 开始的 <strong>环形</strong> 字符串数组 <code>words</code> 和一个字符串 <code>target</code> 。<strong>环形数组</strong> 意味着数组首尾相连。</p><ul><li>形式上， <code>words[i]</code> 的下一个元素是 <code>words[(i + 1) % n]</code> ，而 <code>words[i]</code> 的前一个元素是 <code>words[(i - 1 + n) % n]</code> ，其中 <code>n</code> 是 <code>words</code> 的长度。</li></ul><p>从 <code>startIndex</code> 开始，你一次可以用 <code>1</code> 步移动到下一个或者前一个单词。</p><p>返回到达目标字符串 <code>target</code> 所需的最短距离。如果 <code>words</code> 中不存在字符串 <code>target</code> ，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：words = [<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;am&quot;</span>,<span class="hljs-string">&quot;leetcode&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>], target = <span class="hljs-string">&quot;hello&quot;</span>, startIndex = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：从下标 <span class="hljs-number">1</span> 开始，可以经由以下步骤到达 <span class="hljs-string">&quot;hello&quot;</span> ：<br>- 向右移动 <span class="hljs-number">3</span> 个单位，到达下标 <span class="hljs-number">4</span> 。<br>- 向左移动 <span class="hljs-number">2</span> 个单位，到达下标 <span class="hljs-number">4</span> 。<br>- 向右移动 <span class="hljs-number">4</span> 个单位，到达下标 <span class="hljs-number">0</span> 。<br>- 向左移动 <span class="hljs-number">1</span> 个单位，到达下标 <span class="hljs-number">0</span> 。<br>到达 <span class="hljs-string">&quot;hello&quot;</span> 的最短距离是 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：words = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;leetcode&quot;</span>], target = <span class="hljs-string">&quot;leetcode&quot;</span>, startIndex = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br>解释：从下标 <span class="hljs-number">0</span> 开始，可以经由以下步骤到达 <span class="hljs-string">&quot;leetcode&quot;</span> ：<br>- 向右移动 <span class="hljs-number">2</span> 个单位，到达下标 <span class="hljs-number">3</span> 。<br>- 向左移动 <span class="hljs-number">1</span> 个单位，到达下标 <span class="hljs-number">3</span> 。<br>到达 <span class="hljs-string">&quot;leetcode&quot;</span> 的最短距离是 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：words = [<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;leetcode&quot;</span>], target = <span class="hljs-string">&quot;ate&quot;</span>, startIndex = <span class="hljs-number">0</span><br>输出：-<span class="hljs-number">1</span><br>解释：因为 words 中不存在字符串 <span class="hljs-string">&quot;ate&quot;</span> ，所以返回 -<span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>+++++++++++++</p><p><strong>简单题</strong></p><p><strong>思路：</strong>自己的思路，感觉想复杂了，首先先求出目标字符串在字符串数组中的什么位置，通过从start开始取最小的位置。。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closetTarget</span><span class="hljs-params">(String[] words, String target, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;words.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (words[i].equals(target)) &#123;<br>                f = <span class="hljs-literal">true</span>;<br>                list.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!f) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (list.size()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> Math.min(Math.abs(startIndex-list.get(<span class="hljs-number">0</span>)),Math.min(startIndex,list.get(<span class="hljs-number">0</span>))+words.length-Math.max(startIndex,list.get(<span class="hljs-number">0</span>)));<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;<br>                min = Math.min(Math.min(min,Math.min(startIndex,list.get(i))+words.length-Math.max(startIndex,list.get(i))),Math.abs(startIndex-list.get(i)));<br>            &#125;<br>            <span class="hljs-keyword">return</span> min;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>大佬的思路</strong>：就是妙~~，<strong>从start出发，分别判断向左移和向右移，是否相等，如果相等直接返回，相当于中心扩散法，从start扩散，则首先返回的一定是距离start最近的一个。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closetTarget</span><span class="hljs-params">(String[] words, String target, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> words.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;words.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (target.equals(words[(startIndex+i)%n]) || target.equals(words[(startIndex-i+n)%n])) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h1><p>给你一个由字符 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code>、<code>&#39;c&#39;</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p><p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;aabaaaacaabc&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">8</span><br>解释：<br>从 s 的左侧取三个字符，现在共取到两个字符 <span class="hljs-string">&#x27;a&#x27;</span> 、一个字符 <span class="hljs-string">&#x27;b&#x27;</span> 。<br>从 s 的右侧取五个字符，现在共取到四个字符 <span class="hljs-string">&#x27;a&#x27;</span> 、两个字符 <span class="hljs-string">&#x27;b&#x27;</span> 和两个字符 <span class="hljs-string">&#x27;c&#x27;</span> 。<br>共需要 <span class="hljs-number">3</span> + <span class="hljs-number">5</span> = <span class="hljs-number">8</span> 分钟。<br>可以证明需要的最少分钟数是 <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;a&quot;</span>, k = <span class="hljs-number">1</span><br>输出：-<span class="hljs-number">1</span><br>解释：无法取到一个字符 <span class="hljs-string">&#x27;b&#x27;</span> 或者 <span class="hljs-string">&#x27;c&#x27;</span>，所以返回 -<span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>++++++++++++</p><p><strong>中等题</strong></p><p><strong>思路</strong>：滑动窗口求出，先求出，中间最多能删除几个字符可以使条件成立，最后再根据总长度-中间长度为答案</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">takeCharacters</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> count[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span> ;i&lt;s.length();i++)&#123;<br>            count[s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (count[i]&lt;k) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>;r&lt;s.length();r++) &#123;<br>            count[s.charAt(r) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">while</span> (count[s.charAt(r) - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; k) &#123;<br>                count[s.charAt(l) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>                l++;<br>            &#125;<br>            res = Math.max(res, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n-res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h1><p>给你一个正整数数组 <code>price</code> ，其中 <code>price[i]</code> 表示第 <code>i</code> 类糖果的价格，另给你一个正整数 <code>k</code> 。</p><p>商店组合 <code>k</code> 类 <strong>不同</strong> 糖果打包成礼盒出售。礼盒的 <strong>甜蜜度</strong> 是礼盒中任意两种糖果 <strong>价格</strong> 绝对差的最小值。</p><p>返回礼盒的 <strong>最大</strong> 甜蜜度。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：price = [<span class="hljs-number">13</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">21</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">8</span><br>解释：选出价格分别为 [<span class="hljs-number">13</span>,<span class="hljs-number">5</span>,<span class="hljs-number">21</span>] 的三类糖果。<br>礼盒的甜蜜度为 min(|<span class="hljs-number">13</span> - <span class="hljs-number">5</span>|, |<span class="hljs-number">13</span> - <span class="hljs-number">21</span>|, |<span class="hljs-number">5</span> - <span class="hljs-number">21</span>|) = min(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>) = <span class="hljs-number">8</span> 。<br>可以证明能够取得的最大甜蜜度就是 <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：price = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br>解释：选出价格分别为 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 的两类糖果。 <br>礼盒的甜蜜度为 min(|<span class="hljs-number">1</span> - <span class="hljs-number">3</span>|) = min(<span class="hljs-number">2</span>) = <span class="hljs-number">2</span> 。<br>可以证明能够取得的最大甜蜜度就是 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：price = [<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0</span><br>解释：从现有的糖果中任选两类糖果，甜蜜度都会是 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>+++++++++++++++++</p><p><strong>中等题</strong></p><p><strong>思路</strong>：二分法，对可能的结果进行二分。最小值取0，最大值为所给数组中的最大值。结果一定在这个最小值和最大值区间 ，所以对该区间进行二分。对于一个二分结果，进行判断，是否能取到k个数，如果能说明这个mid取小了，还可以再大，所以在区间【mid，max】中找，如果不能取到k个数，说明mid值取大了，就要在【min，mid】中找。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumTastiness</span><span class="hljs-params">(<span class="hljs-type">int</span>[] price, <span class="hljs-type">int</span> k)</span> &#123;<br>        Arrays.sort(price);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> price.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> price[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (check(mid,k,price))&#123;<br>                l = mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                r = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断是否能够取到k个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> price[])</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> price[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;price.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (price[i]-pre&gt;=mid)&#123;<br>                count++;<br>                pre = price[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count&gt;=k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法4"><a href="#算法4" class="headerlink" title="算法4"></a>算法4</h1>]]></content>
    
    
    <categories>
      
      <category>力扣周赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="/2022/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-–236（二叉树的最近公共祖先）"><a href="#LeetCode-–236（二叉树的最近公共祖先）" class="headerlink" title="LeetCode –236（二叉树的最近公共祖先）"></a>LeetCode –236（二叉树的最近公共祖先）</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="/2022/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/binarytree.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], p = <span class="hljs-number">5</span>, q = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/12/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/binarytree.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], p = <span class="hljs-number">5</span>, q = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">5</span><br>解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span> 。因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], p = <span class="hljs-number">1</span>, q = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>通过存储每个节点对应的父节点，来寻找最近公共祖先</p><ul><li>首先通过map存储节点对应的父节点</li><li>寻找其中一个节点p的所有的父节点，存储在list中</li><li>遍历q节点的父节点是否在list中，如果在list中表示找到，直接返回。否则没找到返回null。</li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    HashMap&lt;TreeNode,TreeNode&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <span class="hljs-comment">//存储节点所对应的直接父节点</span><br>    List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        ceature(root);<br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">null</span>)&#123;<br>            list.add(p); <span class="hljs-comment">//将p所涉及到的父节点存储到list中</span><br>            p = map.get(p);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (list.contains(q)) <span class="hljs-keyword">return</span> q;  <span class="hljs-comment">//判断是否在p的父节点中，如果在则直接是最近的祖先节点，如果不在，则在判断该节点的父节点</span><br>            q = map.get(q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//将节点所对应的父节点存储到map中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ceature</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>)&#123;<br>            map.put(root.left,root);<br>            ceature(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right!=<span class="hljs-literal">null</span>)&#123;<br>            map.put(root.right,root);<br>            ceature(root.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>递归，分别判断p和q节点是否在根节点的两侧还是左侧还是右侧。</p><ul><li>在左侧查找节点p和节点q，判断是否存在。</li><li>如果都存在左侧或右侧，则在左侧或右侧查找</li><li>否则直接返回根节点</li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (p.val==root.val || q.val==root.val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//如果p和q在左子树中</span><br>        <span class="hljs-keyword">if</span> (find(root.left,p) &amp;&amp; find(root.left,q)) <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left,p,q);<br>        <span class="hljs-comment">//如果p和q在右子树中</span><br>        <span class="hljs-keyword">if</span> (find(root.right,p) &amp;&amp; find(root.right,q)) <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right,p,q);<br>        <span class="hljs-comment">//如果p和q在根节点两侧，</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">//判断node是否在root中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find</span><span class="hljs-params">(TreeNode root,TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root.val==node.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> find(root.left,node) || find(root.right,node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第六次-324场周赛</title>
    <link href="/2022/12/18/%E7%AC%AC%E5%85%AD%E6%AC%A1-324%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/12/18/%E7%AC%AC%E5%85%AD%E6%AC%A1-324%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1：统计相似字符串对的数目（6265）"><a href="#算法1：统计相似字符串对的数目（6265）" class="headerlink" title="算法1：统计相似字符串对的数目（6265）"></a>算法1：统计相似字符串对的数目（6265）</h1><p>给你一个下标从 0 开始的字符串数组 <code>words</code> 。</p><p>如果两个字符串由相同的字符组成，则认为这两个字符串 相似 。</p><ul><li>例如，<code>&quot;abca&quot;</code> 和 <code>&quot;cba&quot;</code> 相似，因为它们都由字符 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code>、<code>&#39;c&#39;</code> 组成。</li><li>然而，<code>&quot;abacba&quot;</code> 和 <code>&quot;bcfd&quot;</code> 不相似，因为它们不是相同字符组成的。<br>请你找出满足字符串 <code>words[i]</code> 和 <code>words[j]</code> 相似的下标对 <code>(i, j)</code> ，并返回下标对的数目，其中 <code>0 &lt;= i &lt; j &lt;= word.length - 1</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：words = [<span class="hljs-string">&quot;aba&quot;</span>,<span class="hljs-string">&quot;aabb&quot;</span>,<span class="hljs-string">&quot;abcd&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;aabc&quot;</span>]<br>输出：<span class="hljs-number">2</span><br>解释：共有 <span class="hljs-number">2</span> 对满足条件：<br>- i = <span class="hljs-number">0</span> 且 j = <span class="hljs-number">1</span> ：words[<span class="hljs-number">0</span>] 和 words[<span class="hljs-number">1</span>] 只由字符 <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-string">&#x27;b&#x27;</span> 组成。 <br>- i = <span class="hljs-number">3</span> 且 j = <span class="hljs-number">4</span> ：words[<span class="hljs-number">3</span>] 和 words[<span class="hljs-number">4</span>] 只由字符 <span class="hljs-string">&#x27;a&#x27;</span>、<span class="hljs-string">&#x27;b&#x27;</span> 和 <span class="hljs-string">&#x27;c&#x27;</span> 。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：words = [<span class="hljs-string">&quot;aabb&quot;</span>,<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;ba&quot;</span>]<br>输出：<span class="hljs-number">3</span><br>解释：共有 <span class="hljs-number">3</span> 对满足条件：<br>- i = <span class="hljs-number">0</span> 且 j = <span class="hljs-number">1</span> ：words[<span class="hljs-number">0</span>] 和 words[<span class="hljs-number">1</span>] 只由字符 <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-string">&#x27;b&#x27;</span> 组成。 <br>- i = <span class="hljs-number">0</span> 且 j = <span class="hljs-number">2</span> ：words[<span class="hljs-number">0</span>] 和 words[<span class="hljs-number">2</span>] 只由字符 <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-string">&#x27;b&#x27;</span> 组成。 <br>- i = <span class="hljs-number">1</span> 且 j = <span class="hljs-number">2</span> ：words[<span class="hljs-number">1</span>] 和 words[<span class="hljs-number">2</span>] 只由字符 <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-string">&#x27;b&#x27;</span> 组成。 <br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：words = [<span class="hljs-string">&quot;nba&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>,<span class="hljs-string">&quot;dba&quot;</span>]<br>输出：<span class="hljs-number">0</span><br>解释：不存在满足条件的下标对，返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>+++++++++++</p><p><strong>简单题</strong></p><p><strong>思路</strong>：暴力，使用set来统计每个字符串的字符，通过对比两个set来判断是否相等</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">similarPairs</span><span class="hljs-params">(String[] words)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;words.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> words[i];<br>            HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;a&lt;s.length();a++)&#123;<br>                set.add(s.charAt(a));<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j&lt;words.length;j++)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> words[j];<br>                HashSet&lt;Character&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;b&lt;s1.length();b++)&#123;<br>                    set1.add(s1.charAt(b));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (set1.equals(set)) res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法2：使用质因数之和替换后可以取到得最小值（2507）"><a href="#算法2：使用质因数之和替换后可以取到得最小值（2507）" class="headerlink" title="算法2：使用质因数之和替换后可以取到得最小值（2507）"></a>算法2：使用质因数之和替换后可以取到得最小值（2507）</h1><p>给你一个正整数 <code>n</code> 。</p><p>请你将 <code>n</code> 的值替换为 <code>n</code> 的 质因数 之和，重复这一过程。</p><p>注意，如果 <code>n</code> 能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。<br>返回 <code>n</code> 可以取到的最小值。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">15</span><br>输出：<span class="hljs-number">5</span><br>解释：最开始，n = <span class="hljs-number">15</span> 。<br><span class="hljs-number">15</span> = <span class="hljs-number">3</span> * <span class="hljs-number">5</span> ，所以 n 替换为 <span class="hljs-number">3</span> + <span class="hljs-number">5</span> = <span class="hljs-number">8</span> 。<br><span class="hljs-number">8</span> = <span class="hljs-number">2</span> * <span class="hljs-number">2</span> * <span class="hljs-number">2</span> ，所以 n 替换为 <span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">6</span> 。<br><span class="hljs-number">6</span> = <span class="hljs-number">2</span> * <span class="hljs-number">3</span> ，所以 n 替换为 <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span> 。<br><span class="hljs-number">5</span> 是 n 可以取到的最小值。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：最开始，n = <span class="hljs-number">3</span> 。<br><span class="hljs-number">3</span> 是 n 可以取到的最小值。<br></code></pre></td></tr></table></figure><p>+++++++++++++</p><p><strong>中等题</strong></p><p><strong>思路</strong>：对n进行拆分，再对剩下得进行拆分，在这个过程中对结果进行相加，如果最后得结果是质数则直接返回，如果不是质数则再次进行整除拆分。</p><blockquote><p>分解质因数：sum为质因数i的和，n不断分解出质因数i，并更新n&#x2F;&#x3D;i，直到n不可再分（质因数为自身和1），此时sum就是初始n的所有质因数之和</p></blockquote><p><strong>代码为;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallestValue</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">4</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;&#125;<br>        <span class="hljs-keyword">if</span> (isPrime(n)) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">while</span> (!isPrime(n))&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span> (n % i==<span class="hljs-number">0</span>) &#123;<br>                    sum += i;<br>                    n /= i;<br>                &#125;<span class="hljs-keyword">else</span> i++;<br>            &#125;<br>            n = sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-comment">//判断是否是质数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;i&lt;x;i++)&#123;<br>            <span class="hljs-keyword">if</span> (x%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法3：添加边使得所有节点的度都为偶数（6267）"><a href="#算法3：添加边使得所有节点的度都为偶数（6267）" class="headerlink" title="算法3：添加边使得所有节点的度都为偶数（6267）"></a>算法3：添加边使得所有节点的度都为偶数（6267）</h1><p>给你一个有 <code>n</code> 个节点的 无向 图，节点编号为 <code>1</code> 到 <code>n</code> 。再给你整数 <code>n</code> 和一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条边。图不一定连通。</p><p>你可以给图中添加 至多 两条额外的边（也可以一条边都不添加），使得图中没有重边也没有自环。</p><p>如果添加额外的边后，可以使得图中所有点的度数都是偶数，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>点的度数是连接一个点的边的数目。</p><p><strong>示例 1：</strong></p><p><img src="/2022/12/18/%E7%AC%AC%E5%85%AD%E6%AC%A1-324%E5%9C%BA%E5%91%A8%E8%B5%9B/agraphdrawio.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">5</span>, edges = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]]<br>输出：<span class="hljs-literal">true</span><br>解释：上图展示了添加一条边的合法方案。<br>最终图中每个节点都连接偶数条边。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/12/18/%E7%AC%AC%E5%85%AD%E6%AC%A1-324%E5%9C%BA%E5%91%A8%E8%B5%9B/aagraphdrawio.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">4</span>, edges = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<br>输出：<span class="hljs-literal">true</span><br>解释：上图展示了添加两条边的合法方案。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/2022/12/18/%E7%AC%AC%E5%85%AD%E6%AC%A1-324%E5%9C%BA%E5%91%A8%E8%B5%9B/aaagraphdrawio.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">4</span>, edges = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]]<br>输出：<span class="hljs-literal">false</span><br>解释：无法添加至多 <span class="hljs-number">2</span> 条边得到一个符合要求的图。<br></code></pre></td></tr></table></figure><p>++++++++++++</p><p><strong>困难题</strong></p><p><strong>思路</strong>：</p><p>（1）首先构建图</p><p>（2）保留度数为奇数的节点，并计算奇数节点的个数</p><p>（3）如果度数为奇数的节点个数为奇数时，无论怎么连接，最后的节点度数都不会为偶数。（因为增加一条边会导致两个节点的度数发生变化）。如果度数为奇数的节点个数大于4时，则不成立</p><p>（4）之后对于偶数分情况讨论，分别为0，2，4</p><ul><li><p>当个数为0时，直接返回<code>true</code>，已经满足题意得要求。</p></li><li><p>当个数为2时，节点分别为<code>x</code>和<code>y</code></p><ul><li>如果节点x和节点y之间没有连线，则直接返回true，将x和y连接即可。</li><li>如果有连线，则遍历其他偶数度得节点，如果其中某个节点与x和y都没有连接，则返回true，进行连接即可。</li></ul></li><li><p>当个数为4时，节点分别为a,b,c,d</p><ul><li>如果 a 和 b 以及 c 和 d 之间没有边，那么连边之后就符合要求了。</li><li>如果 a 和 c 以及 b 和 d 之间没有边，那么连边之后就符合要求了。</li><li>如果 a 和 d 以及 b 和 c 之间没有边，那么连边之后就符合要求了。</li></ul><p>其他情况不满足。</p></li></ul><p><strong>代码为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPossible</span><span class="hljs-params">(<span class="hljs-type">int</span> n, List&lt;List&lt;Integer&gt;&gt; edges)</span> &#123;<br>        List&lt;Integer&gt; list[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span> ;i&lt;=n;i++)&#123;<br>            list[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-comment">//建立图</span><br>        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; l:edges)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> l.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> l.get(<span class="hljs-number">1</span>);<br>            list[x].add(y);<br>            list[y].add(x);<br>        &#125;<br>        <span class="hljs-comment">//度为奇数得节点</span><br>        List&lt;Integer&gt; oddList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span> ((list[i].size())%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                oddList.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> oddList.size();<br>        <span class="hljs-keyword">if</span> (size==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (size==<span class="hljs-number">1</span> || size==<span class="hljs-number">3</span> || size&gt;<span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (size==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> oddList.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> oddList.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (!isConnect(a,b,list)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>                <span class="hljs-keyword">if</span> (i==a || i==b) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (!isConnect(i,a,list) &amp;&amp; !isConnect(i,b,list)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (size==<span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> oddList.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> oddList.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> oddList.get(<span class="hljs-number">2</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> oddList.get(<span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">if</span> (!isConnect(a,b,list) &amp;&amp; !isConnect(c,d,list)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (!isConnect(a,c,list) &amp;&amp; !isConnect(b,d,list)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (!isConnect(a,d,list) &amp;&amp; !isConnect(b,c,list)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断是否有连边</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnect</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,List&lt;Integer&gt; list[])</span>&#123;<br>        <span class="hljs-keyword">return</span> list[x].contains(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法4：查询树中环的长度"><a href="#算法4：查询树中环的长度" class="headerlink" title="算法4：查询树中环的长度"></a>算法4：查询树中环的长度</h1><p>给你一个整数 <code>n</code> ，表示你有一棵含有 <code>2n - 1</code> 个节点的 完全二叉树 。根节点的编号是 <code>1</code> ，树中编号在<code>[1, 2n - 1 - 1]</code> 之间，编号为 <code>val</code> 的节点都有两个子节点，满足：</p><ul><li><p>左子节点的编号为 <code>2 * val</code></p></li><li><p>右子节点的编号为 <code>2 * val + 1</code></p><p>给你一个长度为 <code>m</code> 的查询数组 <code>queries</code> ，它是一个二维整数数组，其中 <code>queries[i] = [ai, bi]</code> 。对于每个查询，求出以下问题的解：</p></li></ul><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-number">1</span>.在节点编号为 `ai` 和 `bi` 之间添加一条边。<br><span class="hljs-number">2</span>.求出图中环的长度。<br><span class="hljs-number">3</span>.删除节点编号为 `ai` 和 `bi` 之间新添加的边。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>环</strong> 是开始和结束于同一节点的一条路径，路径中每条边都只会被访问一次。</li><li>环的长度是环中边的数目。</li><li>在树中添加额外的边后，两个点之间可能会有多条边。<br>请你返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个查询的结果。</li></ul><p><strong>示例 1：</strong></p><p><img src="/2022/12/18/%E7%AC%AC%E5%85%AD%E6%AC%A1-324%E5%9C%BA%E5%91%A8%E8%B5%9B/bexample1.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">3</span>, queries = [[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>]<br>解释：上图是一棵有 <span class="hljs-number">23</span> - <span class="hljs-number">1</span> 个节点的树。红色节点表示添加额外边后形成环的节点。<br>- 在节点 <span class="hljs-number">3</span> 和节点 <span class="hljs-number">5</span> 之间添加边后，环为 [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] ，所以第一个查询的结果是 <span class="hljs-number">4</span> 。删掉添加的边后处理下一个查询。<br>- 在节点 <span class="hljs-number">4</span> 和节点 <span class="hljs-number">7</span> 之间添加边后，环为 [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>] ，所以第二个查询的结果是 <span class="hljs-number">5</span> 。删掉添加的边后处理下一个查询。<br>- 在节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">3</span> 之间添加边后，环为 [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] ，所以第三个查询的结果是 <span class="hljs-number">3</span> 。删掉添加的边。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/12/18/%E7%AC%AC%E5%85%AD%E6%AC%A1-324%E5%9C%BA%E5%91%A8%E8%B5%9B/aexample2.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：n = <span class="hljs-number">2</span>, queries = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]<br>输出：[<span class="hljs-number">2</span>]<br>解释：上图是一棵有 <span class="hljs-number">22</span> - <span class="hljs-number">1</span> 个节点的树。红色节点表示添加额外边后形成环的节点。<br>- 在节点 <span class="hljs-number">1</span> 和节点 <span class="hljs-number">2</span> 之间添加边后，环为 [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] ，所以第一个查询的结果是 <span class="hljs-number">2</span> 。删掉添加的边。<br></code></pre></td></tr></table></figure><p>++++++++++++++</p><p><strong>困难题</strong></p><p><strong>思路</strong>：<strong>找到想要询问的两个点的最近公共祖先。</strong></p><p>环可以看成是从 a出发往上走，在某个位置「拐弯」，往下走到 b。</p><p>这个拐弯的地方就是 a 和 b的<strong>最近公共祖先</strong>。</p><p>设 LCA 为 a 和 b 的最近公共祖先，那么环长等于LCA 到 a 的距离加LCA 到 b 的距离加一。</p><p><strong>如何找 LCA？</strong></p><p>注意到在完全二叉树中，深度越深的点，其编号必定大于上一层的节点编号，根据这个性质，我们可以不断循环，每次循环比较 a 和 b 的大小：</p><ul><li>如果 a&gt;b，则 a 的深度大于等于 b的深度，那么把 a移动到其父节点，即 a&#x3D;a&#x2F;2；</li><li>如果 a&lt;b，则 a 的深度小于等于 b 的深度，那么把 bb 移动到其父节点，即 b&#x3D;b&#x2F;2；</li><li>如果 a&#x3D;b，则找到了LCA，退出循环。</li></ul><blockquote><p>也就是一点点向上寻找，找到最近的公共祖先，找的过程中记录长度。</p></blockquote><p><strong>代码为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] cycleLengthQueries(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;queries.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">1</span>];<br>            f = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (a!=b) &#123;<br>                <span class="hljs-keyword">if</span> (a &gt; b) a = a / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span>  b = b / <span class="hljs-number">2</span>;<br>                f++;<br>            &#125;<br>            res[index++] = f+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣周赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第五次-323场周赛</title>
    <link href="/2022/12/17/%E7%AC%AC%E4%BA%94%E6%AC%A1-323%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/12/17/%E7%AC%AC%E4%BA%94%E6%AC%A1-323%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1：删除每行中的最大值（2500）"><a href="#算法1：删除每行中的最大值（2500）" class="headerlink" title="算法1：删除每行中的最大值（2500）"></a>算法1：删除每行中的最大值（2500）</h1><p>给你一个 <code>m x n</code> 大小的矩阵 <code>grid</code> ，由若干正整数组成。</p><p>执行下述操作，直到 <code>grid</code> 变为空矩阵：</p><ul><li>从每一行删除值最大的元素。如果存在多个这样的值，删除其中任何一个。</li><li>将删除元素中的最大值与答案相加。<br><strong>注意</strong> 每执行一次操作，矩阵中列的数据就会减 1 。</li></ul><p>返回执行上述操作后的答案。</p><p><strong>示例 1：</strong></p><p><img src="/2022/12/17/%E7%AC%AC%E4%BA%94%E6%AC%A1-323%E5%9C%BA%E5%91%A8%E8%B5%9B/q1ex1.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：grid = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]]<br>输出：<span class="hljs-number">8</span><br>解释：上图展示在每一步中需要移除的值。<br>- 在第一步操作中，从第一行删除 <span class="hljs-number">4</span> ，从第二行删除 <span class="hljs-number">3</span>（注意，有两个单元格中的值为 <span class="hljs-number">3</span> ，我们可以删除任一）。在答案上加 <span class="hljs-number">4</span> 。<br>- 在第二步操作中，从第一行删除 <span class="hljs-number">2</span> ，从第二行删除 <span class="hljs-number">3</span> 。在答案上加 <span class="hljs-number">3</span> 。<br>- 在第三步操作中，从第一行删除 <span class="hljs-number">1</span> ，从第二行删除 <span class="hljs-number">1</span> 。在答案上加 <span class="hljs-number">1</span> 。<br>最终，答案 = <span class="hljs-number">4</span> + <span class="hljs-number">3</span> + <span class="hljs-number">1</span> = <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/12/17/%E7%AC%AC%E4%BA%94%E6%AC%A1-323%E5%9C%BA%E5%91%A8%E8%B5%9B/q1ex2.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：grid = [[<span class="hljs-number">10</span>]]<br>输出：<span class="hljs-number">10</span><br>解释：上图展示在每一步中需要移除的值。<br>- 在第一步操作中，从第一行删除 <span class="hljs-number">10</span> 。在答案上加 <span class="hljs-number">10</span> 。<br>最终，答案 = <span class="hljs-number">10</span> 。<br></code></pre></td></tr></table></figure><p>++++++++++++++</p><p><strong>简单题</strong></p><p><strong>思路1</strong>：暴力做法，循环遍历每一行中的最大值，再拿出每一行中最大值的最大数。使用一个辅助变量来验证该数是否之前已经取过。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteGreatestValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (m==<span class="hljs-number">0</span> &amp;&amp; n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> max;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max_ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,b = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> used[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">while</span> (y--&gt;=<span class="hljs-number">0</span>) &#123;<br>            max_ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                max = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                   <span class="hljs-keyword">if</span> (!used[i][j] &amp;&amp; grid[i][j]&gt;=max) &#123;<br>                       max = grid[i][j];<br>                       a = i;<br>                       b = j;<br>                   &#125;<br>                &#125;<br>                used[a][b] = <span class="hljs-literal">true</span>;<br>                max_ans = Math.max(max,max_ans);<br>            &#125;<br>            res+=max_ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路2</strong>：很巧妙。我咋就没想到呢~~。将数组的每一行进行排序，相加每一列的最大的数就是结果</p><p><strong>代码为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteGreatestValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;grid.length;i++)&#123;<br>            Arrays.sort(grid[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;grid[<span class="hljs-number">0</span>].length;i++)&#123;<br>            max = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;grid.length;j++)&#123;<br>                max = Math.max(max,grid[j][i]);<br>            &#125;<br>            res+=max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法2：数组中最长的方波（2501）"><a href="#算法2：数组中最长的方波（2501）" class="headerlink" title="算法2：数组中最长的方波（2501）"></a>算法2：数组中最长的方波（2501）</h1><p>给你一个整数数组 <code>nums</code> 。如果 <code>nums</code> 的子序列满足下述条件，则认为该子序列是一个 <strong>方波</strong> ：</p><ul><li>子序列的长度至少为 <code>2</code> ，并且</li><li>将子序列从小到大排序 <strong>之后</strong> ，除第一个元素外，每个元素都是前一个元素的 平方 。<br>返回 <code>nums</code> 中 <strong>最长方波</strong> 的长度，如果不存在 方波 则返回 <code>-1</code> 。</li></ul><p><strong>子序列</strong> 也是一个数组，可以由另一个数组删除一些或不删除元素且不改变剩余元素的顺序得到。</p><p><strong>示例 1 ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">3</span><br>解释：选出子序列 [<span class="hljs-number">4</span>,<span class="hljs-number">16</span>,<span class="hljs-number">2</span>] 。排序后，得到 [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">16</span>] 。<br>- <span class="hljs-number">4</span> = <span class="hljs-number">2</span> * <span class="hljs-number">2.</span><br>- <span class="hljs-number">16</span> = <span class="hljs-number">4</span> * <span class="hljs-number">4.</span><br>因此，[<span class="hljs-number">4</span>,<span class="hljs-number">16</span>,<span class="hljs-number">2</span>] 是一个方波.<br>可以证明长度为 <span class="hljs-number">4</span> 的子序列都不是方波。<br></code></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>输出：-<span class="hljs-number">1</span><br>解释：nums 不存在方波，所以返回 -<span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>++++++++++++</p><p><strong>中等题</strong></p><p><strong>思路</strong>：先对数组排序，再进行遍历搜索，在对每一个元素搜索的时候使用二分法进行查找。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSquareStreak</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-comment">//优化</span><br>            <span class="hljs-keyword">if</span> (a*a&gt;nums[nums.length-<span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">while</span> (binSearch(nums,a*a))&#123;<br>                count++;<br>                a= a*a;<br>            &#125;<br>            max = Math.max(count,max);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (max&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> max;<br>    &#125;<br>    <span class="hljs-comment">//二分法查找</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">binSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[],<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid]&lt;x) l = mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l]==x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用封装好的二分法进行查找，代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestSquareStreak</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[i]*nums[i]&gt;nums[nums.length-<span class="hljs-number">1</span>]) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (idx&gt;=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//封装好的二分查找法</span><br>                idx = Arrays.binarySearch(nums,nums[idx]*nums[idx]);<br>                <span class="hljs-keyword">if</span> (idx &gt;= <span class="hljs-number">0</span>) ++count;<br>            &#125;<br>            max = Math.max(count,max);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (max&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法3：设计内存分配器（2502）"><a href="#算法3：设计内存分配器（2502）" class="headerlink" title="算法3：设计内存分配器（2502）"></a>算法3：设计内存分配器（2502）</h1><p>给你一个整数 <code>n</code> ，表示下标从 <strong>0</strong> 开始的内存数组的大小。所有内存单元开始都是空闲的。</p><p>请你设计一个具备以下功能的内存分配器：</p><ol><li><strong>分配</strong> 一块大小为 <code>size</code> 的连续空闲内存单元并赋 id <code>mID</code> 。</li><li><strong>释放</strong> 给定 id <code>mID</code> 对应的所有内存单元。</li></ol><p><strong>注意：</strong></p><ul><li>多个块可以被分配到同一个 <code>mID</code> 。</li><li>你必须释放 <code>mID</code> 对应的所有内存单元，即便这些内存单元被分配在不同的块中。</li></ul><p>实现 <code>Allocator</code> 类：</p><ul><li><code>Allocator(int n)</code> 使用一个大小为 <code>n</code> 的内存数组初始化 <code>Allocator</code> 对象。</li><li><code>int allocate(int size, int mID)</code> 找出大小为 <code>size</code> 个连续空闲内存单元且位于  <strong>最左侧</strong> 的块，分配并赋 id <code>mID</code> 。返回块的第一个下标。如果不存在这样的块，返回 <code>-1</code> 。</li><li><code>int free(int mID)</code> 释放 id <code>mID</code> 对应的所有内存单元。返回释放的内存单元数目。</li></ul><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">输入<br>[<span class="hljs-string">&quot;Allocator&quot;</span>, <span class="hljs-string">&quot;allocate&quot;</span>, <span class="hljs-string">&quot;allocate&quot;</span>, <span class="hljs-string">&quot;allocate&quot;</span>, <span class="hljs-string">&quot;free&quot;</span>, <span class="hljs-string">&quot;allocate&quot;</span>, <span class="hljs-string">&quot;allocate&quot;</span>, <span class="hljs-string">&quot;allocate&quot;</span>, <span class="hljs-string">&quot;free&quot;</span>, <span class="hljs-string">&quot;allocate&quot;</span>, <span class="hljs-string">&quot;free&quot;</span>]<br>[[<span class="hljs-number">10</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">7</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br><br>解释<br><span class="hljs-type">Allocator</span> <span class="hljs-variable">loc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Allocator</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 初始化一个大小为 10 的内存数组，所有内存单元都是空闲的。</span><br>loc.allocate(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 最左侧的块的第一个下标是 0 。内存数组变为 [1, , , , , , , , , ]。返回 0 。</span><br>loc.allocate(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 最左侧的块的第一个下标是 1 。内存数组变为 [1,2, , , , , , , , ]。返回 1 。</span><br>loc.allocate(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 最左侧的块的第一个下标是 2 。内存数组变为 [1,2,3, , , , , , , ]。返回 2 。</span><br>loc.free(<span class="hljs-number">2</span>); <span class="hljs-comment">// 释放 mID 为 2 的所有内存单元。内存数组变为 [1, ,3, , , , , , , ] 。返回 1 ，因为只有 1 个 mID 为 2 的内存单元。</span><br>loc.allocate(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 最左侧的块的第一个下标是 3 。内存数组变为 [1, ,3,4,4,4, , , , ]。返回 3 。</span><br>loc.allocate(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 最左侧的块的第一个下标是 1 。内存数组变为 [1,1,3,4,4,4, , , , ]。返回 1 。</span><br>loc.allocate(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 最左侧的块的第一个下标是 6 。内存数组变为 [1,1,3,4,4,4,1, , , ]。返回 6 。</span><br>loc.free(<span class="hljs-number">1</span>); <span class="hljs-comment">// 释放 mID 为 1 的所有内存单元。内存数组变为 [ , ,3,4,4,4, , , , ] 。返回 3 ，因为有 3 个 mID 为 1 的内存单元。</span><br>loc.allocate(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 无法找出长度为 10 个连续空闲内存单元的空闲块，所有返回 -1 。</span><br>loc.free(<span class="hljs-number">7</span>); <span class="hljs-comment">// 释放 mID 为 7 的所有内存单元。内存数组保持原状，因为不存在 mID 为 7 的内存单元。返回 0 。</span><br></code></pre></td></tr></table></figure><p>++++++++++++++++</p><p><strong>中等题</strong></p><p><strong>思路</strong>：暴力</p><p><strong>代码为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span> &#123;<br><br>    <span class="hljs-type">int</span> allocator[];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Allocator</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        allocator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> mID)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;allocator.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span> (j&lt;allocator.length &amp;&amp; allocator[j]==<span class="hljs-number">0</span> &amp;&amp; j-i&lt;size)&#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j-i==size)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i;k&lt;j;k++) allocator[k] = mID;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            i = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">int</span> mID)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;allocator.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (allocator[i]==mID) &#123;<br>                allocator[i] = <span class="hljs-number">0</span>;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Allocator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Allocator obj = new Allocator(n);</span><br><span class="hljs-comment"> * int param_1 = obj.allocate(size,mID);</span><br><span class="hljs-comment"> * int param_2 = obj.free(mID);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣周赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第四次-322场周赛</title>
    <link href="/2022/12/04/%E7%AC%AC%E5%9B%9B%E6%AC%A1-322%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/12/04/%E7%AC%AC%E5%9B%9B%E6%AC%A1-322%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1：回环句（6253）"><a href="#算法1：回环句（6253）" class="headerlink" title="算法1：回环句（6253）"></a>算法1：回环句（6253）</h1><p><strong>句子</strong> 是由单个空格分隔的一组单词，且不含前导或尾随空格。</p><ul><li>例如，<code>&quot;Hello World&quot;</code>、<code>&quot;HELLO&quot;</code>、<code>&quot;hello world hello world&quot;</code> 都是符合要求的句子。</li></ul><p>单词 <strong>仅</strong> 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。</p><p>如果句子满足下述全部条件，则认为它是一个 <strong>回环句</strong> ：</p><ul><li><p>单词的最后一个字符和下一个单词的第一个字符相等。</p></li><li><p>最后一个单词的最后一个字符和第一个单词的第一个字符相等。</p><p>例如，<code>&quot;leetcode exercises sound delightful&quot;</code>、<code>&quot;eetcode&quot;</code>、<code>&quot;leetcode eats soul&quot;</code> 都<strong>是</strong>回环句。然而，<code>&quot;Leetcode is cool&quot;</code>、<code>&quot;happy Leetcode&quot;</code>、<code>&quot;Leetcode&quot;</code> 和 <code>&quot;I like Leetcode&quot;</code> 都 <strong>不</strong> 是回环句。</p></li></ul><p>给你一个字符串 <code>sentence</code> ，请你判断它是不是一个回环句。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：sentence = <span class="hljs-string">&quot;leetcode exercises sound delightful&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：句子中的单词是 [<span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-string">&quot;exercises&quot;</span>, <span class="hljs-string">&quot;sound&quot;</span>, <span class="hljs-string">&quot;delightful&quot;</span>] 。<br>- leetcode 的最后一个字符和 exercises 的第一个字符相等。<br>- exercises 的最后一个字符和 sound 的第一个字符相等。<br>- sound 的最后一个字符和 delightful 的第一个字符相等。<br>- delightful 的最后一个字符和 leetcode 的第一个字符相等。<br>这个句子是回环句。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：sentence = <span class="hljs-string">&quot;eetcode&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：句子中的单词是 [<span class="hljs-string">&quot;eetcode&quot;</span>] 。<br>- eetcode 的最后一个字符和 eetcode 的第一个字符相等。<br>这个句子是回环句。<br></code></pre></td></tr></table></figure><p>+++++++++++++++++++</p><p><strong>简单题</strong></p><p><strong>思路</strong>：将字符串通过空格分隔，遍历字符串按照要求比较</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCircularSentence</span><span class="hljs-params">(String sentence)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> sentence.length();<br>        <span class="hljs-keyword">if</span> (sentence.charAt(<span class="hljs-number">0</span>)!=sentence.charAt(len-<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        String[] s = sentence.split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;s.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> s[i];<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s[i+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (s1.charAt(s1.length()-<span class="hljs-number">1</span>)!=s2.charAt(<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法2：划分技能点相等的团队（6254）"><a href="#算法2：划分技能点相等的团队（6254）" class="headerlink" title="算法2：划分技能点相等的团队（6254）"></a>算法2：划分技能点相等的团队（6254）</h1><p>给你一个正整数数组 <code>skill</code> ，数组长度为 偶数 <code>n</code> ，其中 <code>skill[i]</code> 表示第 <code>i</code> 个玩家的技能点。将所有玩家分成 <code>n / 2</code> 个 <code>2</code> 人团队，使每一个团队的技能点之和 相等 。</p><p>团队的 化学反应 等于团队中玩家的技能点 乘积 。</p><p>返回所有团队的 化学反应 之和，如果无法使每个团队的技能点之和相等，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：skill = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">22</span><br>解释：<br>将玩家分成 <span class="hljs-number">3</span> 个团队 (<span class="hljs-number">1</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) ，每个团队的技能点之和都是 <span class="hljs-number">6</span> 。<br>所有团队的化学反应之和是 <span class="hljs-number">1</span> * <span class="hljs-number">5</span> + <span class="hljs-number">2</span> * <span class="hljs-number">4</span> + <span class="hljs-number">3</span> * <span class="hljs-number">3</span> = <span class="hljs-number">5</span> + <span class="hljs-number">8</span> + <span class="hljs-number">9</span> = <span class="hljs-number">22</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：skill = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">12</span><br>解释：<br>两个玩家形成一个团队，技能点之和是 <span class="hljs-number">7</span> 。<br>团队的化学反应是 <span class="hljs-number">3</span> * <span class="hljs-number">4</span> = <span class="hljs-number">12</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：skill = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：-<span class="hljs-number">1</span><br>解释：<br>无法将玩家分成每个团队技能点都相等的若干个 <span class="hljs-number">2</span> 人团队。<br></code></pre></td></tr></table></figure><p>+++++++++++++++++</p><p><strong>中等题</strong></p><p><strong>自己的思路</strong>：使用hash表记录个数</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dividePlayers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] skill)</span> &#123;<br>        Arrays.sort(skill);<br>        <span class="hljs-keyword">if</span> (skill.length==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> skill[<span class="hljs-number">0</span>]*skill[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;skill.length;i++)&#123;<br>            sum+=skill[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum%(skill.length/<span class="hljs-number">2</span>)!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> sum/(skill.length/<span class="hljs-number">2</span>);<br><br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;skill.length;i++) map.put(skill[i],map.getOrDefault(skill[i],<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;skill.length/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (skill[i]&gt;ans) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (map.containsKey(ans-skill[i]) &amp;&amp; map.get(ans-skill[i])!=<span class="hljs-number">0</span>)&#123;<br>                res+=skill[i]*(ans-skill[i]);<br>                map.put(ans-skill[i],map.get(ans-skill[i])-<span class="hljs-number">1</span>);<br>                map.put(skill[i],map.get(skill[i])-<span class="hljs-number">1</span>);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(count==skill.length/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>大佬的思路</strong>：首先对数组进行排序，大哥带小弟进行组队，如果最大的数和最小的数不能匹配，那么最大的和一个比最小数更大的数匹配，因此直接返回负数一。否则向里进行遍历。</p><p><strong>代码为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dividePlayers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] skill)</span> &#123;<br>        Arrays.sort(skill);<br>        <span class="hljs-keyword">if</span> (skill.length==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> skill[<span class="hljs-number">0</span>]*skill[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(skill).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sum/(skill.length/<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (skill[<span class="hljs-number">0</span>]+skill[skill.length-<span class="hljs-number">1</span>]==a)&#123;<br>            res+=skill[<span class="hljs-number">0</span>]*skill[skill.length-<span class="hljs-number">1</span>];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,j = skill.length-<span class="hljs-number">2</span>;i&lt;j;i++,j--)&#123;<br>            <span class="hljs-keyword">if</span> (skill[i]+skill[j]!=a) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            res+=skill[i]*skill[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dividePlayers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] skill)</span> &#123;<br>        Arrays.sort(skill);<br>        <span class="hljs-keyword">if</span> (skill.length==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> skill[<span class="hljs-number">0</span>]*skill[<span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> skill[<span class="hljs-number">0</span>]+skill[skill.length-<span class="hljs-number">1</span>];<br>        res+=skill[<span class="hljs-number">0</span>]*skill[skill.length-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,j = skill.length-<span class="hljs-number">2</span>;i&lt;j;i++,j--)&#123;<br>            <span class="hljs-keyword">if</span> (skill[i]+skill[j]!=sum) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            res+=skill[i]*skill[j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法3：两个城市间路径的最小分数（6255）"><a href="#算法3：两个城市间路径的最小分数（6255）" class="headerlink" title="算法3：两个城市间路径的最小分数（6255）"></a>算法3：<a href="https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/">两个城市间路径的最小分数</a>（6255）</h1><p>给你一个正整数 <code>n</code> ，表示总共有 <code>n</code> 个城市，城市从 <code>1</code> 到 <code>n</code> 编号。给你一个二维数组 <code>roads</code> ，其中 <code>roads[i] = [ai, bi, distancei]</code> 表示城市 <code>ai</code> 和 <code>bi</code> 之间有一条 双向 道路，道路距离为 <code>distancei</code> 。城市构成的图不一定是连通的。</p><p>两个城市之间一条路径的 分数 定义为这条路径中道路的 最小 距离。</p><p>城市 <code>1</code> 和城市 n 之间的所有路径的 <strong>最小</strong> 分数。</p><p>注意：</p><ul><li>一条路径指的是两个城市之间的道路序列。</li><li>一条路径可以 多次 包含同一条道路，你也可以沿着路径多次到达城市 1 和城市 n 。</li><li>测试数据保证城市 1 和城市n 之间 至少 有一条路径。</li></ul><p><strong>示例 1：</strong></p><p><img src="/2022/12/04/%E7%AC%AC%E5%9B%9B%E6%AC%A1-322%E5%9C%BA%E5%91%A8%E8%B5%9B/graph11.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">4</span>, roads = <span class="hljs-string">[[1,2,9],[2,3,6],[2,4,5],[1,4,7]]</span><br>输出：<span class="hljs-number">5</span><br>解释：城市 <span class="hljs-number">1</span> 到城市 <span class="hljs-number">4</span> 的路径中，分数最小的一条为：<span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> 。这条路径的分数是 <span class="hljs-built_in">min</span>(<span class="hljs-number">9</span>,<span class="hljs-number">5</span>) = <span class="hljs-number">5</span> 。<br>不存在分数更小的路径。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/12/04/%E7%AC%AC%E5%9B%9B%E6%AC%A1-322%E5%9C%BA%E5%91%A8%E8%B5%9B/graph22.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]<br>输出：2<br>解释：城市<span class="hljs-number"> 1 </span>到城市<span class="hljs-number"> 4 </span>分数最小的路径是：1 -&gt;<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 3 </span>-&gt;<span class="hljs-number"> 4 </span>。这条路径的分数是 min(2,2,4,7) =<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>+++++++++++</p><p><strong>中等题</strong></p><p><strong>思路</strong>：直接使用并查集，在一个连通图中查找最小的边权值。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> p[];<br>    <span class="hljs-comment">//并查集</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minScore</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] roads)</span> &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        init(n);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;roads.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> roads[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> roads[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (find(a)!=find(b)) merge(a,b); <span class="hljs-comment">//合并为一个集合</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;roads.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> roads[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (find(<span class="hljs-number">1</span>)==find(k) &amp;&amp; roads[i][<span class="hljs-number">2</span>]&lt;min) min = roads[i][<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>    <span class="hljs-comment">//合并</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>&#123;<br>        p[find(x)] = find(y);<br>    &#125;<br><br>    <span class="hljs-comment">///初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            p[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查找父节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x]!=x)&#123;<br>            p[x] = find(p[x]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>也可以dfs进行解决</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//dfs</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minScore</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] roads)</span> &#123;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; graph[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            graph[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        <span class="hljs-comment">//建立图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] r : roads) &#123;<br>            graph[r[<span class="hljs-number">0</span>]].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;r[<span class="hljs-number">1</span>], r[<span class="hljs-number">2</span>]&#125;);<br>            graph[r[<span class="hljs-number">1</span>]].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;r[<span class="hljs-number">0</span>], r[<span class="hljs-number">2</span>]&#125;);<br>        &#125;<br>        <span class="hljs-type">boolean</span> used[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(graph,<span class="hljs-number">1</span>,used);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;<span class="hljs-type">int</span>[]&gt; graph[],<span class="hljs-type">int</span> a,<span class="hljs-type">boolean</span> used[])</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        used[a] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> to[]:graph[a])&#123;<br>            min = Math.min(min,to[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (!used[to[<span class="hljs-number">0</span>]])&#123;<br>                min = Math.min(min,dfs(graph,to[<span class="hljs-number">0</span>],used));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法4："><a href="#算法4：" class="headerlink" title="算法4："></a>算法4：</h1>]]></content>
    
    
    <categories>
      
      <category>力扣周赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java代码的执行过程</title>
    <link href="/2022/12/04/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/12/04/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java代码的执行过程"><a href="#Java代码的执行过程" class="headerlink" title="Java代码的执行过程"></a>Java代码的执行过程</h1><p><strong>首先Java程序从源文件创建到程序运行需要两个步骤：</strong></p><p><img src="/2022/12/04/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/1445502-20220515170637515-493454243.png" alt="img"></p><p><strong>编译期</strong></p><p>编译器把 <code>.java</code> 源代码文件编译成 <code>.class</code> 字节码文件</p><p><strong>运行期</strong></p><p>Java类加载器将 .class 字节码文件加载到内存，在 JVM 中进行解释并生成可执行代码。</p><h2 id="编译期"><a href="#编译期" class="headerlink" title="编译期"></a>编译期</h2><p><code>.java</code>文件编译为<code>.class</code>文件，如果在编译类的过程中，这个类所依赖的类还没有被编译，则先编译所依赖的类，如果在该路径下没有找到<code>.class</code>文件或<code>.java</code>文件，则报错。</p><p>编译后的字节码文件主要分为两种：<strong>常量池和方法字节码</strong></p><ul><li>常量池：代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、方法引用，成员变量引用等）</li><li>方法字节码：各个方法的字节码</li></ul><h2 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h2><p>Java 类运行的过程大概分为：<strong>类的加载和类的执行</strong>。（JVM在程序第一次运行主动使用类的时候，才会立即去加载。）</p><p>在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p><strong>类被加载到jvm虚拟机内存开始，到卸载出内存为止，他的生命周期可以分为：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载。</strong></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><strong>将我们的编译好的.class文件加载到jvm中。</strong>此时就会有一个“类加载器”的概念。</p><blockquote><p> 那么类加载器何时会将一个.class加载带jvm？也就是说什么情况下会加载一个类？</p></blockquote><blockquote><p> 回答：首先就会将main（）方法所在的类加载到jvm，当代码执行遇到new的时候又继续将该对象加载到jvm。所以总结来说，就是在你的代码中需要用到这个类的时候，就会将其加载到jvm中。</p></blockquote><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><strong>该阶段就是来校验加载进来的.class文件是否符合指定的规则。</strong></p><blockquote><p>每个.class文件都很浪漫，因为每一个.class文件都是以8个十六进制的 0×CAFEBABE,翻译过来就是咖啡宝贝。浪漫吧？在验证阶段的第一步就是检查.class文件是否以咖啡宝贝来开头的。</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>首先为这个类分配内存空间，然后为类变量（被static修饰的变量）赋值一个默认的初始值。但是如果类变量同时被final修饰的话，就不是赋值初始值而是具体的值。</strong></p><p><img src="/2022/12/04/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/1445502-20220515212723549-313092955.png" alt="img"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>jvm将常量池的符号引用替换为直接引用。</strong></p><p>在<code>.class</code>文件中是以符号引用来存储的。在解析阶段就需要将其解析为直接引用。如果有了直接引用，那引用的目标必定已经在内存中存在。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>而到了初始化阶段，才真正开始执行类中定义的java程序代码。主要有以下步骤：</p><ul><li>为类的静态变量赋予正确的初始值。</li><li>执行类的静态代码块。</li></ul><p><img src="/2022/12/04/Java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/1445502-20220515212822572-1487676086.png" alt="img"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试题-Spring</title>
    <link href="/2022/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98-Spring/"/>
    <url>/2022/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98-Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是Spring-Bean"><a href="#什么是Spring-Bean" class="headerlink" title="什么是Spring Bean"></a>什么是Spring Bean</h2><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h2 id="将一个类声明为Bean的注解有哪些"><a href="#将一个类声明为Bean的注解有哪些" class="headerlink" title="将一个类声明为Bean的注解有哪些"></a>将一个类声明为Bean的注解有哪些</h2><p><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</p><p><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p><p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p><h2 id="Autowired和-Resource区别"><a href="#Autowired和-Resource区别" class="headerlink" title="@Autowired和@Resource区别"></a>@Autowired和@Resource区别</h2><ul><li><p><code>Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</p></li><li><p><code>Autowired</code>默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</p></li><li><p>一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例，单例模式</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>注解方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">personPrototype</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>xml文件方式</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ul><li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动装配到 Spring 容器中，<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li></ul><h2 id="注入bean的注解有哪些"><a href="#注入bean的注解有哪些" class="headerlink" title="注入bean的注解有哪些"></a>注入bean的注解有哪些</h2><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>（1）通过构造器创建 bean 实例（无参数构造）</p><p>（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p><p>（3）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p><p>（4）bean 可以使用了（对象获取到了）</p><p>（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p><h2 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为?"></a>Spring 事务中哪几种事务传播行为?</h2><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p><p>默认的事务传播行为，如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p><p>不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性），这个使用的很少。</p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="SpringMVC的核心组件"><a href="#SpringMVC的核心组件" class="headerlink" title="SpringMVC的核心组件"></a>SpringMVC的核心组件</h2><p>记住下面这些核心组件，也就记住了工作原理</p><ul><li><code>DispatcherServlet</code>：<strong>核心中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code></strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code></strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code></strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code></strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h2 id="SpringMVC工作原理"><a href="#SpringMVC工作原理" class="headerlink" title="SpringMVC工作原理"></a>SpringMVC工作原理</h2><p>（1）客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</p><p>（2）<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 uri 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</p><p>（3）<code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配执行 <code>Handler</code> 。</p><p>（4）<code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p><p>（5）<code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p><p>（6）<code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p><p>（7）把 <code>View</code> 返回给请求者（浏览器）</p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="SpringBoot的启动类"><a href="#SpringBoot的启动类" class="headerlink" title="SpringBoot的启动类"></a>SpringBoot的启动类</h2><p><img src="/2022/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98-Spring/image-20221207213045946.png" alt="image-20221207213045946"></p><blockquote><p>元注解：可以注解到注解上的注解，对其它注解进行说明的注解</p></blockquote><ul><li>Target：元注解，说明注解作用的目标，（允许被修饰的注解作用在类、接口和枚举上）</li><li>Retention：表示注解的生命周期，（保存到class文件，jvm加载class文件后，仍然存在，运行时也存在）</li><li>Documented：java在生成文档后，是否显示注解</li><li>Inherited：表示子类可以继承父类的注解</li></ul><p>启动类上面的注解为**@springBootApplication**，是 Spring Boot 的核心注解，包含了以下三个注解：</p><p>（1）<code>@SpringBootConfiguration</code>：里面 是 <code>@Configuration</code>注解，它的作用就是<strong>将当前类声明为配置类</strong>，同时还可以使用<code>@bean</code>注解修饰的方法交给Spring容器，实例化对象，而方法名就是实例名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication(scanBasePackages = &quot;com.xxx&quot;)</span><span class="hljs-comment">//扫描com.xxx包下的相关Configuration文件、自动映射文件、组件文件</span><br></code></pre></td></tr></table></figure><p>（2）<code>@ComponentScan</code>：<strong>他的作用就是扫描当前包以及子包，将有<code>@Component</code>，<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>等注解的类注册到容器中，以便调用。</strong></p><p>（3）<code>@EnableAutoConfiguration</code>：<strong>会对我们配置的一些类自动注入的spring容器中。</strong>（对<code>spring.factories</code>包下的文件进行扫描）</p><p>它主要就是通过内部的方法，扫描<code>classpath</code>的<code>META-INF/spring.factories</code>配置文件（key-value），将其中的<br><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 对应的配置项实例化并且注册到<code>spring</code>容器。</p><p>打开<code>@EnableAutoConfiguration</code>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br></code></pre></td></tr></table></figure><p>我们springboot项目为什么可以自动载入应用程序所需的<code>bean</code>？<strong>就是因为这个神奇的注解<code>@Import</code>。</strong></p><p>进入<code>AutoConfigurationImportSelector</code>类，可以看到他有一个方法<code>selectImports()</code>，</p><p><img src="/2022/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98-Spring/20201015162555853.png" alt="在这里插入图片描述"></p><p>进入<code>getAutoConfigurationEntry()</code>方法</p><p>可以看到这里有个<code>List</code>集合，那这个<code>List</code>集合又是干嘛的？没事，我们继续跟踪<code>getCandidateConfigurations()</code>方法！</p><p><img src="/2022/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98-Spring/20201015163850335.png" alt="在这里插入图片描述"></p><p>红框中的方法：<strong>就是读取<code>classpath</code>下的<code>META-INF/spring.factories</code>文件的配置，将<code>key</code>为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 对应的配置项读取出来，通过反射机制实例化为配置文件，然后注入<code>spring</code>容器。</strong></p><p><strong>这个方法可以返回集合里找到我们自定义的配置文件路径！</strong></p><h2 id="SpringBoot的starter"><a href="#SpringBoot的starter" class="headerlink" title="SpringBoot的starter"></a>SpringBoot的starter</h2><p>starter是启动依赖，日常企业应用研发中的各种场景都抽取出来，做成一个个的 starter（启动器），starter 中整合了该场景下各种可能用到的依赖，用户只需要在 Maven 中引入 starter 依赖，SpringBoot 就能自动扫描到要加载的信息并启动相应的默认配置。让用户摆脱了处理各种依赖和配置的困扰。</p><p>主要的作用有：</p><p>（1）以功能为维度，维护对应的jar包的版本依赖</p><p>（2）开发者不需要关注版本冲突问题</p><p>（3）starter会把所有jar包依赖的全部导入进来，避免开发者自己去引入依赖带来麻烦</p><p>（4）只需要在application.properties文件里面进行维护就行了，比如Redis这个starter，只需要在application.properties文件里面添加redis的连接信息就可以直接使用了.</p><p>（5）starter中集成了自动装配的机制，也就是说程序中依赖对应的starter组件以后，这个组件会自动集成到Spring中，</p><h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><p>使用@<strong>EnableAutoConfiguration</strong>注解来实现的，将所有符合条件的配置都加载到当前的SpringBoot创建。</p><p>在EnableAutoConfiguration 这个注解中发现有下面这个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br></code></pre></td></tr></table></figure><p>对<code>spring.factories</code>包下的文件进行扫描，添加到容器中去。</p><h2 id="SpringBoot的核心配置文件是什么"><a href="#SpringBoot的核心配置文件是什么" class="headerlink" title="SpringBoot的核心配置文件是什么"></a>SpringBoot的核心配置文件是什么</h2><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</li></ul><ul><li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li></ul><h2 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h2><ol><li>定义了 Java 编译版本为 1.8 。</li><li>使用 UTF-8 格式编码。</li><li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li><li>执行打包操作的配置。</li><li>自动化的资源过滤。</li><li>自动化的插件配置。</li></ol><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="mybatis中-和-的区别"><a href="#mybatis中-和-的区别" class="headerlink" title="mybatis中#和$的区别"></a>mybatis中#和$的区别</h2><p><strong>#传入的参数在SQL中显示为字符串，$传入的参数在SqL中直接显示为传入的值</strong>.</p><p><strong>#方式能够很大程度防止sql注入，$方式无法防止Sql注入；</strong></p>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java网络中的IO模型</title>
    <link href="/2022/11/27/java%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/11/27/java%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="学习IO模型需要的基础"><a href="#学习IO模型需要的基础" class="headerlink" title="学习IO模型需要的基础"></a>学习IO模型需要的基础</h1><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>Linux 的内核将所有外部设备<strong>都看做一个文件来操作</strong>，对一个文件的读写操作会<strong>调用内核提供的系统命令(api)<strong>，返回一个<code>file descriptor</code>（fd，文件描述符）。而对一个socket的读写也会有响应的描述符，称为<code>socket fd</code>（socket文件描述符），描述符就是一个数字，</strong>指向内核中的一个结构体</strong>（文件路径，数据区等一些属性）。</p><h2 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h2><p>为了保证用户进程不能直接操作内核（kernel），<strong>保证内核的安全</strong>，操心系统将虚拟空间划分为两部分</p><ul><li><strong>一部分为内核空间</strong>。</li><li><strong>一部分为用户空间</strong>。</li></ul><h2 id="I-x2F-O运行过程"><a href="#I-x2F-O运行过程" class="headerlink" title="I&#x2F;O运行过程"></a>I&#x2F;O运行过程</h2><p><strong>以read为例：</strong></p><p><img src="/2022/11/27/java%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84IO%E6%A8%A1%E5%9E%8B/image-20221127200400663.png" alt="image-20221127200400663"></p><p>通过上图的操作流程可以发现，应用程序调用read方法时，是需要<strong>等待</strong>的，有两个过程：</p><ul><li>从内核空间中找数据</li><li>将内核空间的数据拷贝到用户空间中</li></ul><h1 id="阻塞IO模型（BIO）"><a href="#阻塞IO模型（BIO）" class="headerlink" title="阻塞IO模型（BIO）"></a>阻塞IO模型（BIO）</h1><p>应用程序发起系统调用到数据包被复制到应用程序的缓冲区中或者发生错误返回，在此期间是一直等待的。</p><p><img src="/2022/11/27/java%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84IO%E6%A8%A1%E5%9E%8B/image-20221127200735955.png" alt="image-20221127200735955"></p><p><strong>优点：</strong>开发简单，容易入门。在阻塞等待期间，用户线程挂起，在挂起期间不会占用 CPU 资源</p><p><strong>缺点：</strong>一个线程维护一个 IO ，不适合大并发，在并发量大的时候需要创建大量的线程来维护网络连接，内存、线程开销非常大</p><h1 id="非阻塞IO模型（NIO）"><a href="#非阻塞IO模型（NIO）" class="headerlink" title="非阻塞IO模型（NIO）"></a>非阻塞IO模型（NIO）</h1><p>进程<strong>反复</strong>进行系统调用，如果数据没有准备好，则返回一个EAGAIN。一般都对非阻塞I&#x2F;O模型<strong>进行轮询检查这个状态</strong>，看内核是不是有数据到来。</p><p><img src="/2022/11/27/java%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84IO%E6%A8%A1%E5%9E%8B/image-20221127201120197.png" alt="image-20221127201120197"></p><p>在非阻塞状态下，recv() 接口在被调用后立即返回，返回值代表了不同的含义。如在本例中</p><ul><li>recv() 返回值大于 0，表示接受数据完毕，返回值即是接受到的字节数；</li><li>recv() 返回 0，表示连接已经正常断开；</li><li>recv() 返回 -1，且 errno 等于 EAGAIN，表示 recv 操作还没执行完成；</li><li>recv() 返回 -1，且 errno 不等于 EAGAIN，表示 recv 操作遇到系统错误 errno。</li></ul><p><strong>同步非阻塞 IO 优点：</strong>每次发起 IO 调用，在内核等待数据的过程中可以立即返回，用户线程不会阻塞，实时性好</p><p><strong>同步非阻塞 IO 缺点：</strong>多个线程不断轮询内核是否有数据，占用大量 CPU 资源，效率不高。一般 Web 服务器不会采用此模式</p><h1 id="IO多路复用模型"><a href="#IO多路复用模型" class="headerlink" title="IO多路复用模型"></a>IO多路复用模型</h1><p>它的基本原理就是 select&#x2F;epoll 这个 function会不断的轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。</p><p><img src="/2022/11/27/java%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84IO%E6%A8%A1%E5%9E%8B/image-20221127201540663.png" alt="image-20221127201540663"></p><p><strong>IO多路复用的流程</strong></p><p>（1）当用户进程调用了select，那么整个进程会被block；</p><p>（2）而同时，kernel会“监视”所有select负责的socket；</p><p>（3）当任何一个socket中的数据准备好了，select就会返回；</p><p>（4）这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程(空间)。</p><p>所以，I&#x2F;O 多路复用的特点是<strong>通过一种机制一个进程能同时等待多个文件描述符</strong>，而这些文件描述符<strong>其中的任意一个进入读就绪状态</strong>，select()函数<strong>就可以返回</strong>。</p><h1 id="异步模型（AIO）"><a href="#异步模型（AIO）" class="headerlink" title="异步模型（AIO）"></a>异步模型（AIO）</h1><p>用户进程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel的角度，当它收到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三次-321场周赛</title>
    <link href="/2022/11/27/%E7%AC%AC%E4%B8%89%E6%AC%A1-321%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/11/27/%E7%AC%AC%E4%B8%89%E6%AC%A1-321%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="第一题：找出中枢整数（6245）"><a href="#第一题：找出中枢整数（6245）" class="headerlink" title="第一题：找出中枢整数（6245）"></a>第一题：找出中枢整数（6245）</h1><p>给你一个正整数 <code>n</code> ，找出满足下述条件的 中枢整数 <code>x</code> ：</p><ul><li><p><code>1</code> 和 <code>x</code> 之间的所有元素之和等于 <code>x</code> 和 <code>n</code> 之间所有元素之和。</p><p>返回中枢整数 <code>x</code> 。如果不存在中枢整数，则返回 <code>-1</code> 。题目保证对于给定的输入，至多存在一个中枢整数。</p></li></ul><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 8<br>输出：6<br>解释：6 是中枢整数，因为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 21 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">1</span> 是中枢整数，因为 <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出：-<span class="hljs-number">1</span><br>解释：可以证明不存在满足题目要求的整数。<br></code></pre></td></tr></table></figure><p>+++++++++</p><p><strong>简单题</strong></p><p><strong>我的思路：</strong>通过前缀和，计算数组之间前缀和的差值。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> arr[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            arr[i] = arr[i-<span class="hljs-number">1</span>]+i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i&lt;j)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> arr[i]-arr[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> arr[n]-arr[j];<br>            <span class="hljs-keyword">if</span> (a==b &amp;&amp; (j-i==<span class="hljs-number">1</span> || i-j==<span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">return</span> i-j==<span class="hljs-number">1</span>?i:j;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a&lt;b) i++; <br>            <span class="hljs-keyword">else</span> j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他思路1：</strong>通过数学的思想，复杂度只需要<code>O(1)</code>，太妙了！！</p><p><img src="/2022/11/27/%E7%AC%AC%E4%B8%89%E6%AC%A1-321%E5%9C%BA%E5%91%A8%E8%B5%9B/image-20221127143242785.png" alt="image-20221127143242785"></p><p>因此，通过以上公式，只需要判断数组中遍历的数是否等于上述公式即可</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (i== Math.sqrt(n*(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>其他思路2：</strong>遍历数组，分别以数组中的每个数为中心点，计算该数的左右两边的和，判断是否相等。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;a&lt;=i;a++) l+=a;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> i;b&lt;=n;b++) r+=b;<br>            <span class="hljs-keyword">if</span> (l==r) <span class="hljs-keyword">return</span> i;<br>            l = <span class="hljs-number">0</span>;<br>            r = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二题：追加字符以获得子序列（6246）"><a href="#第二题：追加字符以获得子序列（6246）" class="headerlink" title="第二题：追加字符以获得子序列（6246）"></a>第二题：追加字符以获得子序列（6246）</h1><p>给你两个仅由小写英文字母组成的字符串 <code>s</code> 和 <code>t</code> 。</p><p>现在需要通过向 <code>s</code> 末尾追加字符的方式使 <code>t</code> 变成 <code>s</code> 的一个 子序列 ，返回需要追加的最少字符数。</p><p>子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;coaching&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;coding&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：向 s 末尾追加字符串 <span class="hljs-string">&quot;ding&quot;</span> ，s = <span class="hljs-string">&quot;coachingding&quot;</span> 。<br>现在，<span class="hljs-built_in">t</span> 是 s (<span class="hljs-string">&quot;coachingding&quot;</span>) 的一个子序列。<br>可以证明向 s 末尾追加任何 <span class="hljs-number">3</span> 个字符都无法使 <span class="hljs-built_in">t</span> 成为 s 的一个子序列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-built_in">t</span> 已经是 s (<span class="hljs-string">&quot;abcde&quot;</span>) 的一个子序列。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;abcde&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：向 s 末尾追加字符串 <span class="hljs-string">&quot;abcde&quot;</span> ，s = <span class="hljs-string">&quot;zabcde&quot;</span> 。<br>现在，<span class="hljs-built_in">t</span> 是 s (<span class="hljs-string">&quot;zabcde&quot;</span>) 的一个子序列。 <br>可以证明向 s 末尾追加任何 <span class="hljs-number">4</span> 个字符都无法使 <span class="hljs-built_in">t</span> 成为 s 的一个子序列。<br></code></pre></td></tr></table></figure><p>+++++++++++</p><p><strong>中等题</strong></p><p><strong>思路：</strong>很简单，遍历整个s。t有几个没被匹配上就要添加几个</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">appendCharacters</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> t.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span>  <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len1 &amp;&amp; index&lt;len2;)&#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i)==t.charAt(index))&#123;<br>                i++;<br>                index++;<br>            &#125;<span class="hljs-keyword">else</span> i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len2-index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三题：从链表中移除节点（6247）"><a href="#第三题：从链表中移除节点（6247）" class="headerlink" title="第三题：从链表中移除节点（6247）"></a>第三题：从链表中移除节点（6247）</h1><p>给你一个链表的头节点 <code>head</code> 。</p><p>对于列表中的每个节点 <code>node</code> ，如果其右侧存在一个具有 严格更大 值的节点，则移除 <code>node</code> 。</p><p>返回修改后链表的头节点 <code>head</code> 。</p><p><strong>示例 1：</strong></p><p><img src="/2022/11/27/%E7%AC%AC%E4%B8%89%E6%AC%A1-321%E5%9C%BA%E5%91%A8%E8%B5%9B/image-20221127144625459.png" alt="image-20221127144625459"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>]<br>输出：[<span class="hljs-number">13</span>,<span class="hljs-number">8</span>]<br>解释：需要移除的节点是 <span class="hljs-number">5</span> ，<span class="hljs-number">2</span> 和 <span class="hljs-number">3</span> 。<br>- 节点 <span class="hljs-number">13</span> 在节点 <span class="hljs-number">5</span> 右侧。<br>- 节点 <span class="hljs-number">13</span> 在节点 <span class="hljs-number">2</span> 右侧。<br>- 节点 <span class="hljs-number">8</span> 在节点 <span class="hljs-number">3</span> 右侧。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>解释：每个节点的值都是 <span class="hljs-number">1</span> ，所以没有需要移除的节点。<br></code></pre></td></tr></table></figure><p>++++++++++</p><p><strong>中等题</strong></p><p><strong>思路</strong>：使用一个队列维护，使队列中的元素是降序排列。最后从队列中取元素建立链表。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNodes</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> ( p!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast()&lt;p.val) deque.removeLast();<br>            deque.addLast(p.val);<br>            p = p.next;<br>        &#125;<br>        p = dummy;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(deque.removeFirst());<br>            p.next = node;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他思路</strong>：递归，从后向前遍历，维护一个最大值（当前节点右边的最大值），如果当前节点小于这个max，则返回当前节点的next，否则返回当前节点。debug可以知道流程</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> max;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNodes</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        head.next = removeNodes(head.next);<br>        <br>        max = Math.max(max, head.val);<br>        <span class="hljs-keyword">if</span>(head.val &lt; max) &#123;<br>            <span class="hljs-keyword">return</span> head.next;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><p>给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 <strong>不同</strong> 整数组成。另给你一个正整数 k 。</p><p>统计并返回 num 中的 <strong>中位数</strong> 等于 k 的非空子数组的数目。</p><p><strong>注意：</strong></p><ul><li>数组的中位数是按 <strong>递增</strong> 顺序排列后位于 <strong>中间</strong> 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 <strong>左</strong> 的那个元素。<br>例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。</li><li>子数组是数组中的一个连续部分。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,4,5]</span>, k = 4<br>输出：3<br>解释：中位数等于 4 的子数组有：<span class="hljs-comment">[4]</span>、<span class="hljs-comment">[4,5]</span> 和 <span class="hljs-comment">[1,4,5]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,3,1]</span>, k = 3<br>输出：1<br>解释：<span class="hljs-comment">[3]</span> 是唯一一个中位数等于 3 的子数组。<br></code></pre></td></tr></table></figure><p>++++++++</p><p><strong>困难题，真难呀</strong></p><p><strong>思路：</strong>展开为一个数学公式：</p><p>就是中位数&#x3D;&#x3D;》在奇数的情况下：小于中位数的个数 &#x3D; 大于中位数的个数</p><p>但该题目求得是子数组，所以不能将数组排序，所以将中位数分为左右两侧来看：</p><p>中位数左侧小于+中位数右侧小于 &#x3D; 中位数左侧大于+中位数右侧大于</p><p>在计算得过程中，将左右合为一侧：中位数左侧小于 - 中位数左侧大于 &#x3D; 中位数右侧大于 - 中位数右侧小于（+1-1 &#x3D; +1-1）</p><p>偶数情况下，小于中位数的个数+1 &#x3D; 大于中位数的个数。</p><p><img src="/2022/11/27/%E7%AC%AC%E4%B8%89%E6%AC%A1-321%E5%9C%BA%E5%91%A8%E8%B5%9B/image-20221127162357884.png" alt="image-20221127162357884"></p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]==k) index = i;<br>        &#125;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index+<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;<br>            c+=nums[i]&lt;k?-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>            map.put(c,map.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        &#125;<br>        res+=map.get(<span class="hljs-number">0</span>)+map.getOrDefault(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            c+=nums[i]&lt;k?<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>            res+=map.getOrDefault(c,<span class="hljs-number">0</span>)+map.getOrDefault(c+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣周赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快手一面</title>
    <link href="/2022/11/21/%E5%BF%AB%E6%89%8B%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/11/21/%E5%BF%AB%E6%89%8B%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="volatile关键字有什么作用"><a href="#volatile关键字有什么作用" class="headerlink" title="volatile关键字有什么作用"></a>volatile关键字有什么作用</h1><h1 id="volatile可见性是怎么实现的"><a href="#volatile可见性是怎么实现的" class="headerlink" title="volatile可见性是怎么实现的"></a>volatile可见性是怎么实现的</h1><h1 id="hashmap底层put操作"><a href="#hashmap底层put操作" class="headerlink" title="hashmap底层put操作"></a>hashmap底层put操作</h1><h1 id="hashmap的扩容问题"><a href="#hashmap的扩容问题" class="headerlink" title="hashmap的扩容问题"></a>hashmap的扩容问题</h1><p><code>Hash&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(10000)</code>，要进行几次扩容</p><h1 id="concurrenthashmap中的size方法是怎么求的"><a href="#concurrenthashmap中的size方法是怎么求的" class="headerlink" title="concurrenthashmap中的size方法是怎么求的"></a>concurrenthashmap中的size方法是怎么求的</h1><h1 id="CAS的底层原理"><a href="#CAS的底层原理" class="headerlink" title="CAS的底层原理"></a>CAS的底层原理</h1><h1 id="Mysql的数据结构"><a href="#Mysql的数据结构" class="headerlink" title="Mysql的数据结构"></a>Mysql的数据结构</h1><h1 id="B-树的特点"><a href="#B-树的特点" class="headerlink" title="B+树的特点"></a>B+树的特点</h1><h1 id="int-11-中的11代表什么"><a href="#int-11-中的11代表什么" class="headerlink" title="int(11)中的11代表什么"></a>int(11)中的11代表什么</h1><h1 id="java的内存模型了解么？不了解，就没问了"><a href="#java的内存模型了解么？不了解，就没问了" class="headerlink" title="java的内存模型了解么？不了解，就没问了"></a>java的内存模型了解么？不了解，就没问了</h1><h1 id="zset的底层是什么实现的"><a href="#zset的底层是什么实现的" class="headerlink" title="zset的底层是什么实现的"></a>zset的底层是什么实现的</h1><h1 id="跳表的时间复杂度是多少"><a href="#跳表的时间复杂度是多少" class="headerlink" title="跳表的时间复杂度是多少"></a>跳表的时间复杂度是多少</h1><h1 id="动态String的结构"><a href="#动态String的结构" class="headerlink" title="动态String的结构"></a>动态String的结构</h1><h1 id="最左匹配了解么？应该是这个没太听清，不了解"><a href="#最左匹配了解么？应该是这个没太听清，不了解" class="headerlink" title="最左匹配了解么？应该是这个没太听清，不了解"></a>最左匹配了解么？应该是这个没太听清，不了解</h1><h1 id="Spring的循环依赖怎么解决"><a href="#Spring的循环依赖怎么解决" class="headerlink" title="Spring的循环依赖怎么解决"></a>Spring的循环依赖怎么解决</h1><h1 id="JVM的内存分布，都是干什么的"><a href="#JVM的内存分布，都是干什么的" class="headerlink" title="JVM的内存分布，都是干什么的"></a>JVM的内存分布，都是干什么的</h1><h1 id="垃圾回收器都有哪些"><a href="#垃圾回收器都有哪些" class="headerlink" title="垃圾回收器都有哪些"></a>垃圾回收器都有哪些</h1><h1 id="算法题-回文子串"><a href="#算法题-回文子串" class="headerlink" title="算法题:回文子串"></a>算法题:回文子串</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>快手</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IOC和AOP</title>
    <link href="/2022/11/21/IOC%E5%92%8CAOP/"/>
    <url>/2022/11/21/IOC%E5%92%8CAOP/</url>
    
    <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>IOC（控制反转）：就是把创建和管理bean的过程交给第三方，这个第三方就是IOC容器。（也就是说它负责创建、管理bean，管理bean的生命周期，控制bean的依赖注入）。</p><p>因为，我们每次创建对象都很麻烦，所以使用Spring IOC容器来管理这些对象，需要的时候你就直接用，不用管它是怎么来的、什么时候要销毁，只管用就好了。</p><blockquote><p>举个例子，就好像父母没时间管孩子，就把小朋友交给托管所，就安心的去上班而不用管孩子了。托儿所，就是第三方容器，负责管理小朋友的吃喝玩乐；父母，相当于程序员，只管接送孩子，不用管他们吃喝。</p></blockquote><ul><li><p><strong>控制是什么</strong></p><p>是bean的创建和管理，控制bean的生命周期。</p></li><li><p><strong>反转是什么</strong></p><p>把这个权力交给Spring容器，而不是自己去控制，就是反转。由之前的自己主动创建对象，变成现在被动接收别人给我们的对象的过程，这就是反转。</p></li></ul><blockquote><p>自己炒股、选股票的人就是主动投资，主动权掌握在自己的手中；而买基金的人就是被动投资，把主动权交给了基金经理，除非你把这个基金卖了，否则具体选哪些投资产品都是基金经理决定的。</p></blockquote><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ul><li>依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。</li><li>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。</li><li>IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</li><li>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。<br>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</li></ul><h2 id="IOC能带来什么好处"><a href="#IOC能带来什么好处" class="headerlink" title="IOC能带来什么好处"></a>IOC能带来什么好处</h2><p>答：解耦，把对象之间的依赖关系，转成配置文件来管理，由 Spring IoC Container 来管理。</p><blockquote><p>在项目中，底层的实现都是由很多个对象组成的，对象之间彼此合作实现项目的业务逻辑。但是，很多很多对象紧密结合在一起，一旦有一方出问题了，必然会对其他对象有所影响，所以才有了解藕的这种设计思想。</p></blockquote><p><img src="/2022/11/21/IOC%E5%92%8CAOP/image-20221121144019680.png" alt="image-20221121144019680"></p><p><img src="/2022/11/21/IOC%E5%92%8CAOP/image-20221121144046016.png" alt="image-20221121144046016"></p><h2 id="Spring中的八大模块"><a href="#Spring中的八大模块" class="headerlink" title="Spring中的八大模块"></a>Spring中的八大模块</h2><p><img src="/2022/11/21/IOC%E5%92%8CAOP/image-20221121144057699.png" alt="image-20221121144057699"></p><p>每个「绿框」，对应一个模块，总共8个模块；「黑色包」，表示要实现这个模块的 jar 包。</p><p><strong>既然说容器是 IoC 最重要的部分，那么 Spring 如何设计容器的呢？</strong></p><p>答：使用 <code>ApplicationContext</code>，它是 <code>BeanFactory</code> 的子类，更好的补充并实现了 <code>BeanFactory</code> 的。</p><p><code>ApplicationContext</code> 的里面有两个具体的实现子类，用来读取配置配件的：</p><ul><li><code>ClassPathXmlApplicationContext</code> - 从 class path 中加载配置文件，更常用一些；</li><li><code>FileSystemXmlApplicationContext</code> - 从本地文件中加载配置文件，不是很常用，如果再到 Linux 环境中，还要改路径，不是很方便。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过 <code>ApplicationContext</code> 这个 IoC 容器的入口，用它的两个具体的实现子类，从 class path 或者 file path 中读取数据，用 <code>getBean()</code> 获取具体的 bean instance。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBean3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// ApplicationContext context =</span><br>    <span class="hljs-comment">// new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);</span><br>     <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean4.xml&quot;</span>);<br>     <span class="hljs-type">Orders</span> <span class="hljs-variable">orders</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;orders&quot;</span>, Orders.class);<br>     System.out.println(<span class="hljs-string">&quot;第四步 获取创建 bean 实例对象&quot;</span>);<br>     System.out.println(orders);<br>     <span class="hljs-comment">//手动让 bean 实例销毁</span><br>     context.close();<br> &#125;<br></code></pre></td></tr></table></figure><p>那使用 Spring 到底省略了我们什么工作？</p><p>答：<code>new 的过程</code>。把 new 的过程交给第三方来创建、管理，这就是「解藕」。</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP：面向切面编程，将那些与业务无关，却被业务模块共同调用的逻辑或责任（事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>AOP 切面编程设计到的一些专业术语：</p><table><thead><tr><th align="left">术语</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">目标(Target)</td><td align="center">被通知的对象</td></tr><tr><td align="left">代理(Proxy)</td><td align="center">向目标对象应用通知之后创建的代理对象</td></tr><tr><td align="left">连接点(JoinPoint)</td><td align="center">目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr><td align="left">切入点(Pointcut)</td><td align="center">被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr><td align="left">通知(Advice)</td><td align="center">包括处理时机和处理内容。处理内容就是要做什么事，处理时机就是在什么时机执行处理内容（前，后）</td></tr><tr><td align="left">切面(Aspect)</td><td align="center">切入点(Pointcut)+通知(Advice)</td></tr><tr><td align="left">Weaving(织入)</td><td align="center">将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table><p><strong>切点：</strong>切点分为<code>execution</code>方式和<code>annotation</code>方式。前者可以用路径表达式指定哪些类织入切面，后者可以指定被哪些注解修饰的代码织入切面。</p><p><img src="/2022/11/21/IOC%E5%92%8CAOP/image-20221121144148718.png" alt="image-20221121144148718"></p><h2 id="为什么用AOP"><a href="#为什么用AOP" class="headerlink" title="为什么用AOP"></a>为什么用AOP</h2><p>Java是一个面向对象(OOP)的编程语言，但它有个弊端就是<strong>当需要为多个不具有继承关系的对象引入一个公共行为时</strong>，例如日志记录、权限校验、事务管理、统计等功能，<strong>只能在每个对象里都引用公共行为</strong>，这样做不便于维护，而且有大量重复代码，AOP的出现弥补了OOP的这点不足。</p><p><img src="/2022/11/21/IOC%E5%92%8CAOP/image-20221121144210983.png" alt="image-20221121144210983"></p><p>有多少个业务操作，就要写多少重复的校验和日志记录代码，这显然是无法接受的。当然用面向对象的思想，<strong>可以把这些重复的代码抽离出来</strong>，写成公共方法，就是下面这样：</p><p><img src="/2022/11/21/IOC%E5%92%8CAOP/image-20221121144222459.png" alt="image-20221121144222459"></p><p>代码冗余和可维护性的问题得到了解决，<strong>但每个业务方法中依然要依次手动调用这些公共方法，也是略显繁琐</strong>。 有没有更好的方式呢？有的，那就是AOP，<strong>AOP将权限校验、日志记录等非业务代码完全提取出来，与业务代码分离，并寻找节点切入业务代码中</strong></p><p><img src="/2022/11/21/IOC%E5%92%8CAOP/image-20221121144238833.png" alt="image-20221121144238833"></p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第二次-320场周赛</title>
    <link href="/2022/11/20/%E7%AC%AC%E4%BA%8C%E6%AC%A1-320%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/11/20/%E7%AC%AC%E4%BA%8C%E6%AC%A1-320%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="第一题：数组中不等三元组的数目"><a href="#第一题：数组中不等三元组的数目" class="headerlink" title="第一题：数组中不等三元组的数目"></a>第一题：数组中不等三元组的数目</h1><p>给你一个下标从 <strong>0</strong> 开始的正整数数组 <code>nums</code> 。请你找出并统计满足下述条件的三元组 (i, j, k) 的数目：</p><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; nums.length</code></li><li><code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 两两不同 。<ul><li>换句话说：<code>nums[i] != nums[j]</code>、<code>nums[i] != nums[k]</code> 且 <code>nums[j] != nums[k]</code> 。</li></ul></li></ul><p><strong>返回满足上述条件三元组的数目<em>。</em></strong></p><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs MAKEFILE">输入：nums = [4,4,2,4,3]<br>输出：3<br>解释：下面列出的三元组均满足题目条件：<br><br>- (0, 2, 4) 因为 4 != 2 != 3<br>- (1, 2, 4) 因为 4 != 2 != 3<br>- (2, 3, 4) 因为 2 != 4 != 3<br>  共计 3 个三元组，返回 3 。<br>  注意 (2, 0, 4) 不是有效的三元组，因为 2 &gt; 0 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MAKEFILE">输入：nums = [1,1,1,1,1]<br>输出：0<br>解释：不存在满足条件的三元组，所以返回 0 。<br></code></pre></td></tr></table></figure><p>+++++++++++++++</p><p><strong>简单题</strong></p><p><strong>思路：</strong>自己用暴力做的</p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">unequalTriplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;l&lt;len-<span class="hljs-number">1</span>;l++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> l + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (r&lt;len) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[i] == nums[l] || nums[i] == nums[r] || nums[l] == nums[r]) &#123;<br>                        r++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        r++;<br>                        res++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>很妙的思路：<a href="https://leetcode.cn/problems/number-of-unequal-triplets-in-array/solution/fei-bao-li-zuo-fa-by-endlesscheng-9ekp/">https://leetcode.cn/problems/number-of-unequal-triplets-in-array/solution/fei-bao-li-zuo-fa-by-endlesscheng-9ekp/</a></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">unequalTriplets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,r = <span class="hljs-number">1</span>;r&lt;nums.length;)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]!=nums[r])&#123;<br>                res+=i*(r-i)*(nums.length-r);<br>                i = r;  <br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二题：二叉搜索树最近节点查询"><a href="#第二题：二叉搜索树最近节点查询" class="headerlink" title="第二题：二叉搜索树最近节点查询"></a>第二题：二叉搜索树最近节点查询</h1><p>给你一个 <strong>二叉搜索树</strong> 的根节点 <code>root</code> ，和一个由正整数组成、长度为 <code>n</code> 的数组 <code>queries</code> 。</p><p>请你找出一个长度为 <code>n</code> 的 二维 答案数组 <code>answer</code> ，其中 <code>answer[i] = [mini, maxi]</code> ：</p><ul><li><code>mini</code> 是树中小于等于 <code>queries[i]</code> 的 最大值 。如果不存在这样的值，则使用 <code>-1</code> 代替。</li><li><code>maxi</code> 是树中大于等于 <code>queries[i]</code> 的 最小值 。如果不存在这样的值，则使用 <code>-1</code> 代替。</li></ul><p>返回数组 <code>answer</code> 。</p><p><strong>示例 1 ：</strong></p><p><img src="/2022/11/20/%E7%AC%AC%E4%BA%8C%E6%AC%A1-320%E5%9C%BA%E5%91%A8%E8%B5%9B/bstreeedrawioo.png" alt="img"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MAKEFILE">输入：root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]<br>输出：[[2,2],[4,6],[15,-1]]<br>解释：按下面的描述找出并返回查询的答案：<br>- 树中小于等于 2 的最大值是 2 ，且大于等于 2 的最小值也是 2 。所以第一个查询的答案是 [2,2] 。<br>- 树中小于等于 5 的最大值是 4 ，且大于等于 5 的最小值是 6 。所以第二个查询的答案是 [4,6] 。<br>- 树中小于等于 16 的最大值是 15 ，且大于等于 16 的最小值不存在。所以第三个查询的答案是 [15,-1] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><p><img src="/2022/11/20/%E7%AC%AC%E4%BA%8C%E6%AC%A1-320%E5%9C%BA%E5%91%A8%E8%B5%9B/bstttreee.png" alt="img"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MAKEFILE">输入：root = [4,null,9], queries = [3]<br>输出：[[-1,4]]<br>解释：树中不存在小于等于 3 的最大值，且大于等于 3 的最小值是 4 。所以查询的答案是 [-1,4] 。<br></code></pre></td></tr></table></figure><p>++++++++++++</p><p><strong>中等题</strong></p><p><strong>思路</strong>：<strong>首先对树进行遍历，存储到<code>TreeSet</code>中，因为<code>TreeSet</code>中有两个内置方法可以直接获取本题答案。</strong></p><p>开始的时候用了二分查找，没有做出来，但感觉应该可以，也许是哪种情况没有考虑对把。我再去试试~~成功了！成功了！</p><p><code>TreeSet</code>中的内置函数<code>floor</code>和<code>ceiling</code>，没有做出来，情况太多，内置函数真的太重要了！！</p><p><strong><code>floor</code>：方法返回在这个集合中小于或者等于给定元素的最大元素，如果不存在这样的元素,返回null.</strong></p><p><strong><code>ceiling</code>：方法返回在这个集合中大于或者等于给定元素的最小元素，如果不存在这样的元素,返回null.</strong></p><p>知道这两个方法这题瞬间就变为简单题，hhhh~</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        inSearch(root,set);<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q : queries) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> set.floor(q);<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-literal">null</span>) &#123;<br>                min = -<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> set.ceiling(q);<br>            <span class="hljs-keyword">if</span> (max == <span class="hljs-literal">null</span>) &#123;<br>                max = -<span class="hljs-number">1</span>;<br>            &#125;<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            list.add(min);<br>            list.add(max);<br>            ans.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">//树的遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inSearch</span><span class="hljs-params">(TreeNode root,TreeSet&lt;Integer&gt; set)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>            inSearch(root.left,set);<br>            set.add(root.val);<br>            inSearch(root.right,set);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>看吧！！！！哈哈哈 我就说可以嘛~</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Definition for a binary tree node.</span><br><span class="hljs-comment">    * public class TreeNode &#123;</span><br><span class="hljs-comment">    *     int val;</span><br><span class="hljs-comment">    *     TreeNode left;</span><br><span class="hljs-comment">    *     TreeNode right;</span><br><span class="hljs-comment">    *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment">    *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment">    *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment">    *         this.val = val;</span><br><span class="hljs-comment">    *         this.left = left;</span><br><span class="hljs-comment">    *         this.right = right;</span><br><span class="hljs-comment">    *     &#125;</span><br><span class="hljs-comment">    * &#125;</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">closestNodes</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; queries)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        inSearch(root);<br>        <span class="hljs-type">int</span>[] arr = list.stream().mapToInt(Integer::intValue).toArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;queries.size();i++)&#123;<br>            List&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> queries.get(i);<br>            list2.add(search1(arr,a));<br>            list2.add(search2(arr,a));<br>            res.add(list2);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search1</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> arr.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (arr[mid]&lt;=a)&#123;<br>                l = mid;<br>            &#125;<span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[l]&lt;=a?arr[l]:-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search2</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> arr.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (arr[mid]&gt;=a)&#123;<br>                r = mid;<br>            &#125;<span class="hljs-keyword">else</span> l = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[l]&gt;=a?arr[l]:-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//树的遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inSearch</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>) inSearch(root.left);<br>            list.add(root.val);<br>            <span class="hljs-keyword">if</span> (root.right!=<span class="hljs-literal">null</span>) inSearch(root.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三题：到达首都的最少油耗"><a href="#第三题：到达首都的最少油耗" class="headerlink" title="第三题：到达首都的最少油耗"></a>第三题：到达首都的最少油耗</h1><p><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/">https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/</a></p><p>难呀难~~没怎么看懂。</p><p>简单写一下把。</p><p>给你一棵 <code>n</code> 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条路。<code>0</code> 是首都。给你一个二维整数数组 <code>roads</code> ，其中 <code>roads[i] = [ai, bi]</code> ，表示城市 <code>ai</code> 和 <code>bi</code> 之间有一条 双向路 。</p><p>每个城市里有一个代表，他们都要去首都参加一个会议。</p><p>每座城市里有一辆车。给你一个整数 <code>seats</code> 表示每辆车里面座位的数目。</p><p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p><p>请你返回到达首都最少需要多少升汽油。</p><p><strong>示例 1：</strong></p><p><img src="/2022/11/20/%E7%AC%AC%E4%BA%8C%E6%AC%A1-320%E5%9C%BA%E5%91%A8%E8%B5%9B/a4c380025e3ff0c379525e96a7d63a3.png" alt="img"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MAKEFILE">输入：roads = [[0,1],[0,2],[0,3]], seats = 5<br>输出：3<br>解释：<br>- 代表 1 直接到达首都，消耗 1 升汽油。<br>- 代表 2 直接到达首都，消耗 1 升汽油。<br>- 代表 3 直接到达首都，消耗 1 升汽油。<br>最少消耗 3 升汽油。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/11/20/%E7%AC%AC%E4%BA%8C%E6%AC%A1-320%E5%9C%BA%E5%91%A8%E8%B5%9B/2.png" alt="img"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs MAKEFILE">输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2<br>输出：7<br>解释：<br>- 代表 2 到达城市 3 ，消耗 1 升汽油。<br>- 代表 2 和代表 3 一起到达城市 1 ，消耗 1 升汽油。<br>- 代表 2 和代表 3 一起到达首都，消耗 1 升汽油。<br>- 代表 1 直接到达首都，消耗 1 升汽油。<br>- 代表 5 直接到达首都，消耗 1 升汽油。<br>- 代表 6 到达城市 4 ，消耗 1 升汽油。<br>- 代表 4 和代表 6 一起到达首都，消耗 1 升汽油。<br>最少消耗 7 升汽油。<br></code></pre></td></tr></table></figure><p>++++++++++</p><p><strong>中等题</strong></p><p><strong>思路：将消耗的汽油转化消耗多少辆车，为以0为根节点，分别计算每个子树（每个子树也用同样的方式计算它们的子树–递归操作）所要消耗的车，最后结果相加。</strong></p><p><strong>消耗车的数量：</strong>每个连边所要经过的人&#x2F;车的座位数&#x3D;车的数量，将每个连边加在一起就是总共所需要的数量</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span> res;<br>    List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumFuelCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] roads, <span class="hljs-type">int</span> seats)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> roads.length+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-comment">//建立图，双向边</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;roads.length;i++)&#123;<br>            list.get(roads[i][<span class="hljs-number">0</span>]).add(roads[i][<span class="hljs-number">1</span>]);<br>            list.get(roads[i][<span class="hljs-number">1</span>]).add(roads[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">//以0为根节点，遍历子树</span><br>        dfs(<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,seats);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur,<span class="hljs-type">int</span> father,<span class="hljs-type">int</span> seats)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i:list.get(cur))&#123;<br>            <span class="hljs-comment">//因为是从根节点计算的，所以该节点与根节点连接的那条边就不用计算，因为在计算根节点的时候已经计算过了</span><br>            <span class="hljs-keyword">if</span> (i!=father)&#123;<br>                size += dfs(i,cur,seats);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur!=<span class="hljs-number">0</span>) res+=(<span class="hljs-type">int</span>)Math.ceil((<span class="hljs-type">double</span>) size/seats);  <span class="hljs-comment">//每个子树需要车子的数量</span><br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四题：完美分割的方案数"><a href="#第四题：完美分割的方案数" class="headerlink" title="第四题：完美分割的方案数"></a>第四题：完美分割的方案数</h1><p><a href="https://leetcode.cn/problems/number-of-beautiful-partitions/">https://leetcode.cn/problems/number-of-beautiful-partitions/</a></p>]]></content>
    
    
    <categories>
      
      <category>力扣周赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一次-319场周赛</title>
    <link href="/2022/11/13/%E7%AC%AC%E4%B8%80%E6%AC%A1-319%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/11/13/%E7%AC%AC%E4%B8%80%E6%AC%A1-319%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="第一题（温度转换）"><a href="#第一题（温度转换）" class="headerlink" title="第一题（温度转换）"></a>第一题（温度转换）</h1><p>给你一个四舍五入到两位小数的非负浮点数 <code>celsius</code> 来表示温度，以 <strong>摄氏度（Celsius）</strong>为单位。</p><p>你需要将摄氏度转换为 开氏度<strong>（Kelvin）</strong>和 <strong>华氏度（Fahrenheit）</strong>，并以数组 <code>ans = [kelvin, fahrenheit]</code> 的形式返回结果。</p><p>返回数组 <code>ans</code> 。与实际答案误差不超过 <code>10-5</code> 的会视为正确答案。</p><p><strong>注意：</strong></p><ul><li><code>开氏度 = 摄氏度 + 273.15</code></li><li><code>华氏度 = 摄氏度 * 1.80 + 32.00</code></li></ul><p><strong>示例 1 ：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">输入：celsius = 36.50<br>输出：[309.65000,97.70000]<br>解释：36.50 摄氏度：转换为开氏度是 309.65 ，转换为华氏度是 97.70 。<br></code></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">输入：celsius = 122.11<br>输出：[395.26000,251.79800]<br>解释：122.11 摄氏度：转换为开氏度是 395.26 ，转换为华氏度是 251.798 。<br></code></pre></td></tr></table></figure><p>+++++++</p><p><strong>简单题</strong></p><p>一开始还想复杂了，，哈哈，没有思路可说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] convertTemperature(<span class="hljs-type">double</span> celsius) &#123;<br>        <span class="hljs-type">double</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">2</span>];<br>        res[<span class="hljs-number">0</span>] = celsius+<span class="hljs-number">273.15</span>;<br>        res[<span class="hljs-number">1</span>] = (celsius*<span class="hljs-number">1.8</span>)+<span class="hljs-number">32.00</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二题（最小公倍数为k的子数组数目）"><a href="#第二题（最小公倍数为k的子数组数目）" class="headerlink" title="第二题（最小公倍数为k的子数组数目）"></a>第二题（最小公倍数为k的子数组数目）</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <code>nums</code> 的 子数组 中满足 元素最小公倍数为 <code>k</code> 的子数组数目。</p><p><strong>子数组</strong> 是数组中一个连续非空的元素序列。</p><p><strong>数组的最小公倍数</strong> 是可被所有数组元素整除的最小正整数。</p><p><strong>示例 1 ：</strong></p><ul><li><p>&#96;&#96;&#96;makefile<br>输入：nums &#x3D; [3,6,2,7,1], k &#x3D; 6<br>输出：4<br>解释：以 6 为最小公倍数的子数组是：</p><ul><li>[3,6,2,7,1]</li><li>[3,6,2,7,1]</li><li>[3,6,2,7,1]</li><li>[3,6,2,7,1]<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>**示例 <span class="hljs-number">2</span> ：**<br><br>```makefile<br>输入：nums = [<span class="hljs-number">3</span>], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0</span><br>解释：不存在以 <span class="hljs-number">2</span> 为最小公倍数的子数组。<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>++++</p><p><strong>中等题</strong></p><p><strong>思路：</strong><code>最小公倍数=数的乘积/最大公约数</code>，这题没有做出来的原因是，不会计算最大公约数，，真绝。。还有就是不会算多个数的最小公倍数。</p><p><strong>其实多个数的最小公倍数 就是 两个数的最小公倍数的结果再依次和后面的数求最小公倍</strong></p><p><strong>求两个数最大公约数的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">///最大公约数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a%b;<br>            a = b;<br>            b =temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarrayLCM</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;j&lt;len;j++)&#123;<br>                <span class="hljs-comment">//多个数的最小公倍数</span><br>                t = cap(t,nums[j]);<br>                <span class="hljs-keyword">if</span>(t==k)&#123;<br>                    count++;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t&gt;k)&#123;<br>                    <span class="hljs-comment">//如果前面几个数的最小公倍数已经不满足条件的时候，再加上后面的数就不用算了，因为一定不满足</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-comment">///最小公倍数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> a*b;<br>        <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a%b;<br>            a = b;<br>            b =temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum/a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第三题（逐层排序二叉树所需的最少操作数目）"><a href="#第三题（逐层排序二叉树所需的最少操作数目）" class="headerlink" title="第三题（逐层排序二叉树所需的最少操作数目）"></a>第三题（逐层排序二叉树所需的最少操作数目）</h1><p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 root 。</p><p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p><p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p><p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p><p><strong>示例 1 ：</strong></p><p><img src="/2022/11/13/%E7%AC%AC%E4%B8%80%E6%AC%A1-319%E5%9C%BA%E5%91%A8%E8%B5%9B/image-20220918174006-2.png" alt="img"></p><ul><li><p>&#96;&#96;&#96;makefile<br>输入：root &#x3D; [1,4,3,7,6,8,5,null,null,null,null,9,null,10]<br>输出：3<br>解释：</p><ul><li>交换 4 和 3 。第 2 层变为 [3,4] 。</li><li>交换 7 和 5 。第 3 层变为 [5,6,8,7] 。</li><li>交换 8 和 7 。第 3 层变为 [5,6,7,8] 。<br>共计用了 3 步操作，所以返回 3 。<br>可以证明 3 是需要的最少操作数目。<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mel"><br>**示例 <span class="hljs-number">2</span> ：**<br><br>![img](%E7%AC%AC%E4%B8%80%E6%AC%A1<span class="hljs-number">-319</span>%E5%9C%BA%E5%91%A8%E8%B5%9B/<span class="hljs-keyword">image</span><span class="hljs-number">-20220918174026</span><span class="hljs-number">-3.</span>png)<br><br>- <span class="hljs-string">``</span><span class="hljs-string">`makefile</span><br><span class="hljs-string">  输入：root = [1,3,2,7,6,5,4]</span><br><span class="hljs-string">  输出：3</span><br><span class="hljs-string">  解释：</span><br><span class="hljs-string">  </span><br><span class="hljs-string">  - 交换 3 和 2 。第 2 层变为 [2,3] 。 </span><br><span class="hljs-string">  - 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 </span><br><span class="hljs-string">  - 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。</span><br><span class="hljs-string">    共计用了 3 步操作，所以返回 3 。 </span><br><span class="hljs-string">    可以证明 3 是需要的最少操作数目。</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p>+++++++++++++++++++++</p><p><strong>中等题</strong></p><p><strong>思路：</strong>层序遍历，将每层的数据存储到链表中，分别对每层的链表进行排序，在排序的过程中，计算交换的位置。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">null</span>) queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.remove();<br>                <span class="hljs-keyword">if</span> (node.left!=<span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.left);<br>                    list.add(node.left.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right!=<span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.right);<br>                    list.add(node.right.val);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (list.size()==<span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">if</span> (list.get(<span class="hljs-number">0</span>)&gt;list.get(<span class="hljs-number">1</span>)) count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list.size()&gt;<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-comment">//list.stream().mapToInt(Integer::intValue)：将链表转化为整型数组</span><br>                count+=selectSort(list.stream().mapToInt(Integer::intValue).toArray());<br>            &#125;<br>            list.clear();<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-comment">//选择排序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> min;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>            min = arr[j];<br>            t = j;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j+<span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;<br>                    min = arr[i];<br>                    t = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t!=j)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> arr[j];<br>                arr[j] = arr[t];<br>                arr[t] = m;<br>                <span class="hljs-comment">//计算交换的位置</span><br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四题（不重叠回文子字符串的最大数目）"><a href="#第四题（不重叠回文子字符串的最大数目）" class="headerlink" title="第四题（不重叠回文子字符串的最大数目）"></a>第四题（不重叠回文子字符串的最大数目）</h1><p>给你一个字符串 <code>s</code> 和一个 正 整数 <code>k</code> 。</p><p>从字符串 <code>s</code> 中选出一组满足下述条件且 <strong>不重叠</strong> 的子字符串：</p><p>每个子字符串的长度 <strong>至少</strong> 为 k 。<br>每个子字符串是一个 <strong>回文串</strong> 。<br>返回最优方案中能选择的子字符串的 <strong>最大</strong> 数目。</p><p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p><p><strong>示例 1 ：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">输入：s = <span class="hljs-string">&quot;abaccdbbd&quot;</span>, k = 3<br>输出：2<br>解释：可以选择 s = <span class="hljs-string">&quot;abaccdbbd&quot;</span> 中斜体加粗的子字符串。<span class="hljs-string">&quot;aba&quot;</span> 和 <span class="hljs-string">&quot;dbbd&quot;</span> 都是回文，且长度至少为 k = 3 。<br>可以证明，无法选出两个以上的有效子字符串<br></code></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">输入：s = <span class="hljs-string">&quot;adbcda&quot;</span>, k = 2<br>输出：0<br>解释：字符串中不存在长度至少为 2 的回文子字符串。<br></code></pre></td></tr></table></figure><p>++++++++++++</p><p><strong>困难题</strong></p><p><strong>思路：</strong>两次动态规划，第一次动态规划算出<code>dp[i][j]</code>：位置<code>i</code>到<code>j</code>的子字符串是否是回文字符串。第二次计算出<code>dp2[i]</code>:前<code>i</code>个字符满足条件的最大回文串的数量。。</p><p>其实第二个动态规划有点没搞懂。等过段时间再来看看。。。希望我不会忘。。。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxPalindromes</span><span class="hljs-params">(String S, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 动态规划法</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[S.length()][S.length()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;S.length();i++)&#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">if</span> (S.charAt(i)==S.charAt(j))&#123;<br>                    <span class="hljs-keyword">if</span> (i-j==<span class="hljs-number">1</span>)&#123;<br>                        dp[j][i] = <span class="hljs-literal">true</span>;<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        dp[j][i] = dp[j+<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> S.length();<br>        <span class="hljs-comment">//第二个动态规划</span><br>        <span class="hljs-type">int</span> dp2[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k;i&lt;=len;i++)&#123;<br>            dp2[i] = dp2[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i-k+<span class="hljs-number">1</span>;j&gt;<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">if</span> (dp[j-<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>])&#123;<br>                    dp2[i] = Math.max(dp2[i],dp2[j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp2[len];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣周赛</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程交替打印</title>
    <link href="/2022/11/10/%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/"/>
    <url>/2022/11/10/%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="三个线程交替打印"><a href="#三个线程交替打印" class="headerlink" title="三个线程交替打印"></a>三个线程交替打印</h1><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p><strong>用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行,为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leetcode;<br><br><span class="hljs-keyword">import</span> sort.count;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    A.join();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    B.join();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;C&quot;</span>);<br>            &#125;<br>        &#125;);<br>        A.start();<br>        B.start();<br>        C.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h2><p>通过设置 等待标记 <code>flag</code> 来记录当前拥有锁的是哪个线程， 设置 下一个标记，来记录下一个唤醒的该是哪个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify</span> <span class="hljs-variable">wn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<span class="hljs-comment">// 首先把等待标记设为1, 循环次数设为5次</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);    <span class="hljs-comment">// a的等待标记是1, 下一个标记是2</span><br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);    <span class="hljs-comment">// b的等待标记是2, 下一个标记是3</span><br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);    <span class="hljs-comment">// c的等待标记是3, 下一个标记是1</span><br>        &#125;).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify</span> &#123;<br>    <span class="hljs-comment">// 等待标记</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-comment">// 循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaitNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-comment">// 未获得锁</span><br>                <span class="hljs-keyword">while</span>(flag != waitFlag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();        <span class="hljs-comment">// 进入等待</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 获得了锁</span><br>                System.out.print(str);<br>                flag = nextFlag;            <span class="hljs-comment">// 等待标记改为下一个标记</span><br>                <span class="hljs-built_in">this</span>.notifyAll();           <span class="hljs-comment">// 唤醒所有线程, 再与等待标记对比</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="交替循环输出"><a href="#交替循环输出" class="headerlink" title="交替循环输出"></a>交替循环输出</h1><h2 id="使用Semaphore（信号量）"><a href="#使用Semaphore（信号量）" class="headerlink" title="使用Semaphore（信号量）"></a>使用Semaphore（信号量）</h2><p>有个可以控制线程启动后执行顺序，又简单的实现方式，就是用Semaphore（信号量），它可以控制共享资源的访问个数。</p><p><strong>使用方式：</strong></p><p>初始化的时候，指定共享资源的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化一个资源</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">1</span>);<br>获取资源，获取资源后，semaphore资源个数减<span class="hljs-number">1</span>，变成<span class="hljs-number">0</span>，其他线程再获取资源的时候就会阻塞等待<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">semaphore.acquire();<br></code></pre></td></tr></table></figure><p>释放资源，semaphore资源个数加1，其他阻塞的线程就可以获取到资源了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">semaphore.release();<br></code></pre></td></tr></table></figure><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 初始化三把锁，只有A锁是可用的</span><br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 创建并启动三个线程，线程1获取A锁，释放B锁</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>(A, B, <span class="hljs-string">&quot;A&quot;</span>).start();<br>        <span class="hljs-comment">// 线程2获取B锁，释放C锁</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>(B, C, <span class="hljs-string">&quot;B&quot;</span>).start();<br>        <span class="hljs-comment">// 线程3获取C锁，释放A锁</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadDemo</span>(C, A, <span class="hljs-string">&quot;C&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Semaphore current;<br>        <span class="hljs-keyword">private</span> Semaphore next;<br>        <span class="hljs-keyword">private</span> String name;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 构造方法</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> current 要获取的当前锁</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> next    要释放的下一把锁</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> name    打印内容</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadDemo</span><span class="hljs-params">(Semaphore current, Semaphore next, String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.current = current;<br>            <span class="hljs-built_in">this</span>.next = next;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 获取当前锁，然后打印</span><br>                    current.acquire();<br>                    System.out.print(name);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 释放下一把锁</span><br>                next.release();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用lock"><a href="#使用lock" class="headerlink" title="使用lock"></a>使用lock</h2><p><strong>这种情况下使用锁即可,在上锁之后进行判断 只有满足顺序的时候才打印 不然就解锁走人了 所以三个线程不管谁拿到锁,都必须是按照ABC的顺序进行打印,同时成功之后改变状态,使得顺序能够正常的执行.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreeThread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> time;<span class="hljs-comment">// 控制打印次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> state;<span class="hljs-comment">// 当前状态值：保证三个线程之间交替打印</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreeThread</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span> &#123;<br>        <span class="hljs-built_in">this</span>.time = time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> targetNum)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; time; ) &#123;<br>            lock.lock();<span class="hljs-comment">//上锁</span><br>            <span class="hljs-comment">//只有满足顺序条件的时候才打印 并且state++和i++</span><br>            <span class="hljs-keyword">if</span> (state % <span class="hljs-number">3</span> == targetNum) &#123;<br>                state++;<br>                i++;<br>                System.out.print(str);<br>            &#125;<br>            lock.unlock();<span class="hljs-comment">//解锁</span><br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//ABC三个线程都进入print方法 但是条件中必须满足ABC这样的顺序打印</span><br>    <span class="hljs-comment">//他们三个每个线程都有一个i 所以一共每个线程都要打印5次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreeThread</span> <span class="hljs-variable">th</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreeThread</span>(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            th.print(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            th.print(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">1</span>);<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            th.print(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">2</span>);<br>        &#125;);<br><br>        B.start();<br>        A.start();<br>        C.start();<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="park-amp-unpark-版"><a href="#park-amp-unpark-版" class="headerlink" title="park &amp; unpark 版"></a>park &amp; unpark 版</h2><p>由于 LockSupport 的 park() 方法可以暂停当前线程，unpark() 方法可以唤醒指定的线程，所以可以在执行完当前线程中的代码后，唤醒指定的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br> <br><span class="hljs-comment">// 交替输出实现 之 park &amp; unpark</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test13AlternateOutput</span> &#123;<br>    <span class="hljs-keyword">static</span> Thread t1;<br>    <span class="hljs-keyword">static</span> Thread t2;<br>    <span class="hljs-keyword">static</span> Thread t3;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ParkUnpark</span> <span class="hljs-variable">pu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParkUnpark</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 循环5次</span><br>        t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            pu.print(<span class="hljs-string">&quot;a&quot;</span>,t2);   <span class="hljs-comment">// 线程1下一个要唤醒线程2 </span><br>        &#125;);<br>        t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            pu.print(<span class="hljs-string">&quot;b&quot;</span>,t3);   <span class="hljs-comment">// 线程2下一个要唤醒线程3</span><br>        &#125;);<br>        t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            pu.print(<span class="hljs-string">&quot;c&quot;</span>,t1);   <span class="hljs-comment">// 线程3下一个要唤醒线程1</span><br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br> <br>        LockSupport.unpark(t1);     <span class="hljs-comment">// 先通过主线程唤醒t1线程</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkUnpark</span>&#123;<br>    <span class="hljs-comment">// 循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParkUnpark</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br> <br>    <span class="hljs-comment">// 打印函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Thread next)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            LockSupport.park();         <span class="hljs-comment">// 暂停当前线程</span><br>            System.out.print(str);<br>            LockSupport.unpark(next);   <span class="hljs-comment">// 唤醒指定的下一个线程</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动一面</title>
    <link href="/2022/11/10/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/11/10/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h1 id="登录的时候怎么保证安全性"><a href="#登录的时候怎么保证安全性" class="headerlink" title="登录的时候怎么保证安全性"></a>登录的时候怎么保证安全性</h1><p>高配版的方法，就是用户每次登录时，由服务端生成一个随机密钥对，将公钥返回给前端，私钥保存到服务器，并设置该密钥对的有效期为30分钟（有效时间大家随意），用户登录的时候，要求前端对用户的明文密码进行公钥加密后传给后端，然后后端用私钥对密码进行解密，然后与数据库保存的密码进行匹配，登录成功之后，服务器立即清除这个密钥对。这样即使攻击者拦截到了加密后的密码，并用这个加密后的密码再次伪造登录，也无法成功。</p><p><strong>实现过程：</strong></p><p><a href="https://blog.csdn.net/weixin_42023666/article/details/89706659">https://blog.csdn.net/weixin_42023666/article/details/89706659</a></p><p><a href="https://blog.csdn.net/weixin_42023666/article/details/96338723">https://blog.csdn.net/weixin_42023666/article/details/96338723</a></p><h1 id="在项目中，Session是怎么用的，怎么实现的"><a href="#在项目中，Session是怎么用的，怎么实现的" class="headerlink" title="在项目中，Session是怎么用的，怎么实现的"></a>在项目中，Session是怎么用的，怎么实现的</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">httpSession.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,user.getId());<br></code></pre></td></tr></table></figure><blockquote><p> 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p></blockquote><p>用户登录成功之后，将用户的id存储到Session中。可以在浏览器关闭之前，随时获取用户的id，如果关闭浏览器，则需要重新登录</p><p>在过滤器中使用到了session：用户访问页面的时候，判断Session中是否存在用户id，如果存在则证明用户已经登录可以访问页面，如果不存在，则进行过滤拦截。</p><p>退出登录的时候，将该用户的id从session中删除。</p><p>禁用员工的账号的时候，通过获取session中员工的账号进行更新，</p><h1 id="3个线程abc，怎么交替输出"><a href="#3个线程abc，怎么交替输出" class="headerlink" title="3个线程abc，怎么交替输出"></a>3个线程abc，怎么交替输出</h1><h1 id="sql的一个简单查询语句，具体到innodb中怎么执行的，具体实现"><a href="#sql的一个简单查询语句，具体到innodb中怎么执行的，具体实现" class="headerlink" title="sql的一个简单查询语句，具体到innodb中怎么执行的，具体实现"></a>sql的一个简单查询语句，具体到innodb中怎么执行的，具体实现</h1><h1 id="事务的ACID特性中，持久化是怎么保证的"><a href="#事务的ACID特性中，持久化是怎么保证的" class="headerlink" title="事务的ACID特性中，持久化是怎么保证的"></a>事务的ACID特性中，持久化是怎么保证的</h1><h1 id="隔离性是什么，怎么实现的"><a href="#隔离性是什么，怎么实现的" class="headerlink" title="隔离性是什么，怎么实现的"></a>隔离性是什么，怎么实现的</h1><h1 id="redis怎么处理多线程"><a href="#redis怎么处理多线程" class="headerlink" title="redis怎么处理多线程"></a>redis怎么处理多线程</h1><h1 id="io多路复用是怎么实现的"><a href="#io多路复用是怎么实现的" class="headerlink" title="io多路复用是怎么实现的"></a>io多路复用是怎么实现的</h1><h1 id="虚拟内存是什么，为什么要用"><a href="#虚拟内存是什么，为什么要用" class="headerlink" title="虚拟内存是什么，为什么要用"></a>虚拟内存是什么，为什么要用</h1><h1 id="sql（有姓名和分数，求前2到5名的分数）"><a href="#sql（有姓名和分数，求前2到5名的分数）" class="headerlink" title="sql（有姓名和分数，求前2到5名的分数）"></a>sql（有姓名和分数，求前2到5名的分数）</h1><p>很简单，但当时没写出来。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name,score<br>from exam<br>order by score DESC<br>LIMIT 1,4<br></code></pre></td></tr></table></figure><h1 id="算法题（全排列）"><a href="#算法题（全排列）" class="headerlink" title="算法题（全排列）"></a>算法题（全排列）</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>字节跳动</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手撕准备</title>
    <link href="/2022/11/07/%E6%89%8B%E6%92%95%E5%87%86%E5%A4%87/"/>
    <url>/2022/11/07/%E6%89%8B%E6%92%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>分析：</strong>双指针，l是左边，i是右边，不断变换l，如果遇到相同的元素，则改变l，l变为最后出现相同值得下一个位置。max是存储最大长度。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (map.containsKey(ch))&#123;<br>                l = Math.max(l,map.get(ch));<br>            &#125;<br>            max = Math.max(max,i-l+<span class="hljs-number">1</span>);<br>            map.put(ch,i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoLinked</span>&#123;<br>        <span class="hljs-type">int</span> value;<br>        <span class="hljs-type">int</span> key;<br>        TwoLinked pre;<br>        TwoLinked next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TwoLinked</span><span class="hljs-params">()</span>&#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TwoLinked</span><span class="hljs-params">(<span class="hljs-type">int</span> key,<span class="hljs-type">int</span> value)</span>&#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br>    &#125;<br><br>    Map&lt;Integer,TwoLinked&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> capacity;<br>    TwoLinked head;<br>    TwoLinked tail;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoLinked</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoLinked</span>();<br>        head.next = tail;<br>        tail.pre = head;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-type">TwoLinked</span> <span class="hljs-variable">twoLinked</span> <span class="hljs-operator">=</span> map.get(key);<br>        <span class="hljs-keyword">if</span> (twoLinked!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> twoLinked.value;<br>            removeToHead(twoLinked);<br>            <span class="hljs-keyword">return</span> v;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-type">TwoLinked</span> <span class="hljs-variable">twoLinked1</span> <span class="hljs-operator">=</span> map.get(key);<br><br>        <span class="hljs-keyword">if</span> (twoLinked1!=<span class="hljs-literal">null</span>)&#123;<br>            twoLinked1.value  =value;<br>            removeToHead(twoLinked1);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (map.size()==capacity)&#123;<br>                map.remove(tail.pre.key);<br>                deleteLastLinked();<br>                size--;<br>            &#125;<br>            <span class="hljs-type">TwoLinked</span> <span class="hljs-variable">newLinked</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoLinked</span>(key, value);<br>            map.put(key,newLinked);<br>            addHeadLinked(newLinked);<br>            ++size;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteLastLinked</span><span class="hljs-params">()</span>&#123;<br>        deleteLinked(tail.pre);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeToHead</span><span class="hljs-params">(TwoLinked linked)</span>&#123;<br>        deleteLinked(linked);<br>        addHeadLinked(linked);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteLinked</span><span class="hljs-params">(TwoLinked linked)</span>&#123;<br>        linked.next.pre = linked.pre;<br>        linked.pre.next = linked.next;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHeadLinked</span><span class="hljs-params">(TwoLinked linked)</span>&#123;<br>        linked.next = head.next;<br>        linked.pre = head;<br>        head.next.pre = linked;<br><br>        head.next = linked;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj.get(key);</span><br><span class="hljs-comment"> * obj.put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h1><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="/2022/11/07/%E6%89%8B%E6%92%95%E5%87%86%E5%A4%87/reverse_ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (end!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;k &amp;&amp; end!=<span class="hljs-literal">null</span>;i++)&#123;<br>                end = end.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (end==<span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> pre.next;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> end.next;<br>            end.next = <span class="hljs-literal">null</span>;<br>            pre.next = reverse(start);<br>            start.next = next;<br>            pre = start;<br>            end = pre;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode start)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> start;<br>        <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h1><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [3,2,1,5,6,4], k = 2</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p><strong>优化快速排序和堆排序</strong></p><p><strong>快速代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> sort(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>,nums.length-k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span>(l&lt;=r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> quickSort(nums,l,r);<br>            <span class="hljs-comment">//优化</span><br>            <span class="hljs-keyword">if</span> (index==k) <span class="hljs-keyword">return</span> nums[k];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> index&lt;k ? sort(nums,index+<span class="hljs-number">1</span>,r,k):sort(nums,l,index-<span class="hljs-number">1</span>,k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[l];<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-keyword">while</span> (l&lt;r &amp;&amp; nums[r]&gt;=t)&#123;<br>                r--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[r]&lt;t)&#123;<br>                nums[l] = nums[r];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (l&lt;r &amp;&amp; nums[l]&lt;=t)&#123;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[l]&gt;t)&#123;<br>                nums[r] = nums[l];<br>            &#125;<br>        &#125;<br>        nums[l] = t;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>堆排序代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> HeapSort(nums, k);<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">HeapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[],<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            sort(nums,i,nums.length);<br>        &#125;<br>        <span class="hljs-comment">//优化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;i&gt;=nums.length-k;i--)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]&lt;nums[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[<span class="hljs-number">0</span>];<br>                nums[<span class="hljs-number">0</span>] =t;<br>            &#125;<br>            sort(nums,<span class="hljs-number">0</span>,i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[nums.length-k];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[],<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>;a&lt;n;a = <span class="hljs-number">2</span>*a+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (a+<span class="hljs-number">1</span>&lt;n &amp;&amp; nums[a]&lt;nums[a+<span class="hljs-number">1</span>])&#123;<br>                a++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[i]&lt;nums[a])&#123;<br>                nums[i] = nums[a];<br>                i = a;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            nums[a] = t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树锯齿形层序遍历"><a href="#二叉树锯齿形层序遍历" class="headerlink" title="二叉树锯齿形层序遍历"></a>二叉树锯齿形层序遍历</h1><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p><strong>示例 1：</strong></p><p><img src="/2022/11/07/%E6%89%8B%E6%92%95%E5%87%86%E5%A4%87/tree1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[20,9]</span>,<span class="hljs-comment">[15,7]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：root = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>分析：</strong>使用一个数来控制奇偶，根节点为设置为第一层，所以奇数正序，偶数逆序。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.addLast(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>            Deque&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">//如果该层是奇数，则正序存放</span><br>                    list1.addLast(node.val);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果该层是偶数，则逆序存放</span><br>                    list1.addFirst(node.val);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    queue.add(node.right);<br>                &#125;<br>            &#125;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list1));<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j、i != k 且 j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">4</span>]<br>输出：[[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br>解释：<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] = (-<span class="hljs-number">1</span>) + <span class="hljs-number">0</span> + <span class="hljs-number">1</span> = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>] + nums[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span> + <span class="hljs-number">1</span> + (-<span class="hljs-number">1</span>) = <span class="hljs-number">0</span> 。<br>nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">3</span>] + nums[<span class="hljs-number">4</span>] = (-<span class="hljs-number">1</span>) + <span class="hljs-number">2</span> + (-<span class="hljs-number">1</span>) = <span class="hljs-number">0</span> 。<br>不同的三元组是 [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] 和 [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>固定一个数<code>i</code>，改变<code>l</code>和<code>r</code>。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Arrays.sort(nums);<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i]+nums[l]+nums[r];<br>                <span class="hljs-keyword">if</span> (sum==<span class="hljs-number">0</span>)&#123;<br>                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));<br>                    <span class="hljs-keyword">while</span> (l+<span class="hljs-number">1</span>&lt;n &amp;&amp; nums[l+<span class="hljs-number">1</span>]==nums[l]) l++;<br>                    <span class="hljs-keyword">while</span> (r-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[r]==nums[r-<span class="hljs-number">1</span>]) r--;<br>                    l++;<br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&lt;<span class="hljs-number">0</span>)&#123;<br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p>整数数组 <code>nums</code> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 旋转后 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,5,6,7,0,1,2]</span>, target = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>分析：</strong>二分法，首先将数组进行二分，二分之后两边肯定有一个有序有一个无序，在有序的一边进行查找。无序的一边再进行一分为二。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>            <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]==target?<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left+right)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (target==nums[mid]) <span class="hljs-keyword">return</span> mid;<br>                <span class="hljs-comment">//如果左边有序</span><br>                <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>]&lt;=nums[mid])&#123;<br>                    <span class="hljs-comment">//看目标值是否在左边</span><br>                    <span class="hljs-keyword">if</span> (target&lt;nums[mid] &amp;&amp; target&gt;=nums[<span class="hljs-number">0</span>])&#123;<br>                        right = mid-<span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//如果右边有序</span><br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//看目标值是否在右边</span><br>                    <span class="hljs-keyword">if</span> (target&gt;nums[mid] &amp;&amp; target&lt;=nums[n-<span class="hljs-number">1</span>])&#123;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[left]==target) <span class="hljs-keyword">return</span> left;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h1><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="/2022/11/07/%E6%89%8B%E6%92%95%E5%87%86%E5%A4%87/rainwatertrap.png" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。<br></code></pre></td></tr></table></figure><p><strong>分析：</strong>每个可以接受雨水的位置是，左右两边最大高度的最小值-该位置的高度。</p><p>因此我们可以定义两个数组，来存储每个位置 <strong>左边的最大高度</strong> 和 <strong>右边的最大高度</strong> </p><p><code>leftMax[i] = Math.max(leftMax[i-1],height[i]);</code></p><p><code>rightMax[i] = Math.max(rightMax[i+1],height[i]);</code></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> leftMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> rightMax[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            leftMax[i] = Math.max(leftMax[i-<span class="hljs-number">1</span>],height[i]);<br>        &#125;<br>        rightMax[n-<span class="hljs-number">1</span>] = height[n-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            rightMax[i] = Math.max(rightMax[i+<span class="hljs-number">1</span>],height[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res+=Math.min(rightMax[i],leftMax[i])-height[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析：使用双指针，来表示左右连边的最大高度。</strong></p><p><strong>代码为:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> height.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            leftMax = Math.max(leftMax,height[left]);<br>            rightMax = Math.max(rightMax,height[right]);<br>            <span class="hljs-keyword">if</span> (height[left]&lt;height[right])&#123;<br>                res+=leftMax-height[left];<br>                ++left;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                res+=rightMax-height[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a><strong>旋转链</strong>表</h1><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><p><strong>示例 1：</strong></p><p><img src="/2022/11/07/%E6%89%8B%E6%92%95%E5%87%86%E5%A4%87/rotate1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[4,5,1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/11/07/%E6%89%8B%E6%92%95%E5%87%86%E5%A4%87/roate2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[0,1,2]</span>, k = 4<br>输出：<span class="hljs-comment">[2,0,1]</span><br></code></pre></td></tr></table></figure><p><strong>分析：就是将，从尾部开始的第k个节点作为头结点，原来的头结点作为链表结尾的下一个节点。</strong></p><p>我们仅需要向右移动 k mod n 次即可。因为每 <em>n</em> 次移动都会让链表变为原状。</p><ul><li>我们首先计算出链表的长度 n，</li><li>并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。</li><li>然后我们找新链表的最后一个节点，进行断开。</li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">null</span> || head.next==<span class="hljs-literal">null</span>||k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//求出链表的长度</span><br>        <span class="hljs-keyword">while</span> (p.next!=<span class="hljs-literal">null</span>)&#123;<br>            p = p.next;<br>            n++;<br>        &#125;<br>        <span class="hljs-comment">//在哪断开</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n-k%n;<br>        <span class="hljs-keyword">if</span> (a==n)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>         <span class="hljs-comment">//将链表弄成环形链表</span><br>        p.next = head;<br>        <span class="hljs-comment">//找到断开点</span><br>        <span class="hljs-keyword">while</span> (a--&gt;<span class="hljs-number">0</span>)&#123;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-comment">////结果链表的头部为断开点的下一个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> p.next;<br>        <span class="hljs-comment">//断开点的下一个节点置为null</span><br>        p.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="买股票的最佳时期"><a href="#买股票的最佳时期" class="headerlink" title="买股票的最佳时期"></a>买股票的最佳时期</h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>分析：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] prices)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minPrice</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;prices.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (prices[i]&lt;minPrice)&#123;<br>                minPrice = prices[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (prices[i]-minPrice&gt;max)&#123;<br>                max = prices[i]-minPrice;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h1><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>分析：将链表两两合并。像合并两个有序链表一样</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt; lists.length;i++)&#123;<br>            res = merge(res,lists[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode a,ListNode b)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> pre;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> a;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> b;<br>        <span class="hljs-keyword">while</span> (aa!=<span class="hljs-literal">null</span> &amp;&amp; bb!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (aa.val&lt;bb.val)&#123;<br>                p.next = aa;<br>                aa = aa.next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                p.next = bb;<br>                bb = bb.next;<br>            &#125;<br>            p = p.next;<br>        &#125;<br>        p.next=aa==<span class="hljs-literal">null</span>?bb:aa;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="螺旋数组"><a href="#螺旋数组" class="headerlink" title="螺旋数组"></a>螺旋数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        LinkedList&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(matrix==<span class="hljs-literal">null</span>||matrix.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numEle</span> <span class="hljs-operator">=</span> matrix.length * matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">while</span> (numEle &gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; i &lt;= right &amp;&amp; numEle &gt;= <span class="hljs-number">1</span>; i++) &#123;<br>                result.add(matrix[top][i]);<br>                numEle--;<br>            &#125;<br>            top++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> top; i &lt;= bottom &amp;&amp; numEle &gt;= <span class="hljs-number">1</span>; i++) &#123;<br>                result.add(matrix[i][right]);<br>                numEle--;<br>            &#125;<br>            right--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> right; i &gt;= left &amp;&amp; numEle &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>                result.add(matrix[bottom][i]);<br>                numEle--;<br>            &#125;<br>            bottom--;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> bottom; i &gt;= top &amp;&amp; numEle &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>                result.add(matrix[i][left]);<br>                numEle--;<br>            &#125;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="最有效括号"><a href="#最有效括号" class="headerlink" title="最有效括号"></a>最有效括号</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestValidParentheses</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        stack.push(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stack.push(i);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.pop();<br>                <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                    stack.push(i);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    maxans = Math.max(maxans, i - stack.peek());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxans;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            dp[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = Math.max(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            maxans = Math.max(maxans, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer, TreeNode&gt; parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, TreeNode&gt;();<br>    Set&lt;Integer&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>            parent.put(root.left.val, root);<br>            dfs(root.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>            parent.put(root.right.val, root);<br>            dfs(root.right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        dfs(root);<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>            visited.add(p.val);<br>            p = parent.get(p.val);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (visited.contains(q.val)) &#123;<br>                <span class="hljs-keyword">return</span> q;<br>            &#125;<br>            q = parent.get(q.val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        backtrack(ans, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(List&lt;String&gt; ans, StringBuilder cur, <span class="hljs-type">int</span> open, <span class="hljs-type">int</span> close, <span class="hljs-type">int</span> max)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cur.length() == max * <span class="hljs-number">2</span>) &#123;<br>            ans.add(cur.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (open &lt; max) &#123;<br>            cur.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>            backtrack(ans, cur, open + <span class="hljs-number">1</span>, close, max);<br>            cur.deleteCharAt(cur.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (close &lt; open) &#123;<br>            cur.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            backtrack(ans, cur, open, close + <span class="hljs-number">1</span>, max);<br>            cur.deleteCharAt(cur.length() - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a>最短无序连续子数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxn</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE, right = -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minn</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, left = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (maxn &gt; nums[i]) &#123;<br>                right = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                maxn = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minn &lt; nums[n - i - <span class="hljs-number">1</span>]) &#123;<br>                left = n - i - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                minn = nums[n - i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span>= -<span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : right - left + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[len-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; max)&#123;      <span class="hljs-comment">//从左到右维持最大值，寻找右边界end</span><br>                end = i;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                max = nums[i];<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span>(nums[len-i-<span class="hljs-number">1</span>] &gt; min)&#123;    <span class="hljs-comment">//从右到左维持最小值，寻找左边界begin</span><br>                begin = len-i-<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                min = nums[len-i-<span class="hljs-number">1</span>];<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> end-begin+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>字节跳动</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2022/11/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/11/06/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="无重复字符的最长子串-leetCode3"><a href="#无重复字符的最长子串-leetCode3" class="headerlink" title="无重复字符的最长子串-leetCode3"></a>无重复字符的最长子串-leetCode3</h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p> <strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,r = <span class="hljs-number">0</span>;r&lt;s.length();r++)&#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(s.charAt(r)))&#123;<br>                l = Math.max(l,map.get(s.charAt(r)));<br>            &#125;<br>            res = Math.max(res,r-l+<span class="hljs-number">1</span>);<br>            map.put(s.charAt(r),r+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>岛屿问题</title>
    <link href="/2022/11/04/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"/>
    <url>/2022/11/04/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h1><p>我们所熟悉的 DFS（深度优先搜索）问题通常是在树或者图结构上进行的。</p><p>只需要在树的遍历的基础上进行改进就好。</p><p>树是访问相邻的左右子树节点，而图是访问上下左右的节点。</p><p>树是要判断该root节点是否为null，而图是要判断该节点是否出界。</p><p><strong>树的框架代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">traverse</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-comment">// 判断 base case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 访问两个相邻结点：左子结点、右子结点</span><br>    traverse(root.left);<br>    traverse(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>网络的框架代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> used[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;<br>    <span class="hljs-comment">// 判断 base case，判断坐标是否在网格中</span><br>    <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span> || i&gt;grid.length-<span class="hljs-number">1</span> || j&gt;grid[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span> || used[i][j] || grid[i][j]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br>    <br>    grid[r][c] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 将格子标记为「已遍历过」</span><br>    <br>    <span class="hljs-comment">// 访问上、下、左、右四个相邻结点</span><br>    dfs(grid, r - <span class="hljs-number">1</span>, c);<br>    dfs(grid, r + <span class="hljs-number">1</span>, c);<br>    dfs(grid, r, c - <span class="hljs-number">1</span>);<br>    dfs(grid, r, c + <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="岛屿数量-leetCode200"><a href="#岛屿数量-leetCode200" class="headerlink" title="岛屿数量-leetCode200"></a>岛屿数量-leetCode200</h1><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p> <strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h2><p>首先遍历数组，如果数组的元素为1，则遍历它的上下左右。而它的上下左右元素也使用同样的方法进行上下左右的遍历。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span> used[][];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;grid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !used[i][j])&#123;<br>                    dfs(grid,i,j,used);<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">boolean</span> used[][])</span>&#123;<br>        <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span> || i&gt;grid.length-<span class="hljs-number">1</span> || j&gt;grid[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span> || used[i][j] || grid[i][j]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span>;<br>        used[i][j] = <span class="hljs-literal">true</span>;<br>        dfs(grid,i+<span class="hljs-number">1</span>,j,used);<br>        dfs(grid,i-<span class="hljs-number">1</span>,j,used);<br>        dfs(grid,i,j+<span class="hljs-number">1</span>,used);<br>        dfs(grid,i,j-<span class="hljs-number">1</span>,used);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度"><a href="#广度" class="headerlink" title="广度"></a>广度</h2><p>遍历网路，将为1的格子加入到队列中，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 11 都会被重新标记为 00。直到队列为空，搜索结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">boolean</span> used[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;grid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-comment">//如果为1且没有访问过，则加入到队列中，加入队列时使用i * grid[0].length + j，方便通过值算出横纵坐标</span><br>                    <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !used[i][j]) &#123;<br>                        count++;<br>                        queue.add(i * grid[<span class="hljs-number">0</span>].length + j);<br>                        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> queue.remove();<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> a / grid[<span class="hljs-number">0</span>].length;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> a % grid[<span class="hljs-number">0</span>].length;<br>                            <span class="hljs-keyword">if</span> (row-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; grid[row-<span class="hljs-number">1</span>][col]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !used[row-<span class="hljs-number">1</span>][col])&#123;<br>                                queue.add((row-<span class="hljs-number">1</span>)*grid[<span class="hljs-number">0</span>].length+col);<br>                                used[row-<span class="hljs-number">1</span>][col] = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (row+<span class="hljs-number">1</span>&lt;grid.length &amp;&amp; grid[row+<span class="hljs-number">1</span>][col]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !used[row+<span class="hljs-number">1</span>][col])&#123;<br>                                queue.add((row+<span class="hljs-number">1</span>)*grid[<span class="hljs-number">0</span>].length+col);<br>                                used[row+<span class="hljs-number">1</span>][col] = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (col-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; grid[row][col-<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !used[row][col-<span class="hljs-number">1</span>])&#123;<br>                                queue.add((row)*grid[<span class="hljs-number">0</span>].length+col-<span class="hljs-number">1</span>);<br>                                used[row][col-<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (col+<span class="hljs-number">1</span>&lt;grid[<span class="hljs-number">0</span>].length &amp;&amp; grid[row][col+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; !used[row][col+<span class="hljs-number">1</span>])&#123;<br>                                queue.add((row)*grid[<span class="hljs-number">0</span>].length+col+<span class="hljs-number">1</span>);<br>                                used[row][col+<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="岛屿的周长"><a href="#岛屿的周长" class="headerlink" title="岛屿的周长"></a>岛屿的周长</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><img src="/2022/11/04/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/66d817362c1037ebe7705aacfbc6546e321c2b6a2e4fec96791f47604f546638.jpg" alt="将岛屿周长中的边分为两类"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">islandPerimeter</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">boolean</span> used[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;grid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-number">1</span> &amp;&amp; !used[i][j])&#123;<br>                    <span class="hljs-comment">//由于所有的陆地都是相连的，所以一次就行</span><br>                    <span class="hljs-keyword">return</span> dfs(grid,i,j,used);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> grid[][],<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">boolean</span> used[][])</span>&#123;<br>        <span class="hljs-comment">//当是黄色边界以及，周围是海洋的蓝色边界时+1</span><br>        <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span> || i&gt;grid.length-<span class="hljs-number">1</span> || j&gt;grid[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span> || grid[i][j]==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//当前格子是已经遍历过的陆地格子</span><br>        <span class="hljs-keyword">if</span>(used[i][j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        used[i][j] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> dfs(grid,i+<span class="hljs-number">1</span>,j,used)<br>        + dfs(grid,i-<span class="hljs-number">1</span>,j,used)<br>        + dfs(grid,i,j+<span class="hljs-number">1</span>,used)<br>        + dfs(grid,i,j-<span class="hljs-number">1</span>,used);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 1）加入答案 ans 中即可。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dx = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dy = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">islandPerimeter</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length, m = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; ++k) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">tx</span> <span class="hljs-operator">=</span> i + dx[k];<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">ty</span> <span class="hljs-operator">=</span> j + dy[k];<br>                        <span class="hljs-keyword">if</span> (tx &lt; <span class="hljs-number">0</span> || tx &gt;= n || ty &lt; <span class="hljs-number">0</span> || ty &gt;= m || grid[tx][ty] == <span class="hljs-number">0</span>) &#123;<br>                            cnt += <span class="hljs-number">1</span>;<br>                        &#125;<br>                    &#125;<br>                    ans += cnt;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>或者设置遍历每个为 1 的方格，初始周长都为4，遍历该方格的上下左右，如果为1，则减1。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">islandPerimeter</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;grid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;grid[i].length;j++)&#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    sum+=dfs(grid,i,j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> [][]grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span> (i&gt;=<span class="hljs-number">1</span> &amp;&amp; grid[i-<span class="hljs-number">1</span>][j]==<span class="hljs-number">1</span>)&#123;<br>            a--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>&lt;grid.length &amp;&amp; grid[i+<span class="hljs-number">1</span>][j]==<span class="hljs-number">1</span>)&#123;<br>            a--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j&gt;=<span class="hljs-number">1</span> &amp;&amp; grid[i][j-<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)&#123;<br>            a--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j+<span class="hljs-number">1</span>&lt;grid[i].length &amp;&amp; grid[i][j+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)&#123;<br>            a--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a>岛屿的最大面积</h1><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p><p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p><p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p><p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p><p><strong>示例 1：</strong></p><p><img src="/2022/11/04/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/maxarea1-grid.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：grid = [[<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,1,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,0,0</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">1,0,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,0,0</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">1,1,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：答案不应该是 <span class="hljs-number">11</span> ，因为岛屿只能包含水平或垂直这四个方向上的 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,0,0,0,0,0,0,0]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><p>与岛屿的数量很相似，这个是求岛屿中的最大岛屿的数量。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> max;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">boolean</span> used[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;grid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    count = <span class="hljs-number">0</span>;<br>                    max = <span class="hljs-number">0</span>;<br>                    ans = Math.max(dfs(grid,i,j,used),ans);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> grid[][],<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">boolean</span> used[][])</span>&#123;<br>        <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span> || i&gt;used.length-<span class="hljs-number">1</span> || j&gt;grid[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span> || grid[i][j]==<span class="hljs-number">0</span> || used[i][j])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>            count++;<br>            max = Math.max(max,count);<br>        &#125;<br><br>        used[i][j] = <span class="hljs-literal">true</span>;<br>        dfs(grid,i-<span class="hljs-number">1</span>,j,used);<br>        dfs(grid,i+<span class="hljs-number">1</span>,j,used);<br>        dfs(grid,i,j-<span class="hljs-number">1</span>,used);<br>        dfs(grid,i,j+<span class="hljs-number">1</span>,used);<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h2><p>遍历网络，如果网格是1，则加入到队列中，从队列中取数，遍历岛屿的数量，维护一个max，求岛屿中数量大最大值。</p><p>下面这段代码使用一个栈存储数据，该数据是<code>i*grid[0].length+j</code>，因为再取出数据后，可以通过这个数得到横纵坐标。</p><p>也可以使用两个栈去分别存储，横纵坐标。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> dx[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> dy[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAreaOfIsland</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">boolean</span> used[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;grid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    queue.add(i*grid[<span class="hljs-number">0</span>].length+j);<br>                    used[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> queue.remove();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> a/grid[<span class="hljs-number">0</span>].length;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> a%grid[<span class="hljs-number">0</span>].length;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;f&lt;<span class="hljs-number">4</span>;f++)&#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">newx</span> <span class="hljs-operator">=</span> row+dx[f];<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">newy</span> <span class="hljs-operator">=</span> col+dy[f];<br>                            <span class="hljs-keyword">if</span> (newx&gt;=<span class="hljs-number">0</span> &amp;&amp; newy&gt;=<span class="hljs-number">0</span> &amp;&amp; newx&lt;grid.length &amp;&amp; newy&lt;grid[<span class="hljs-number">0</span>].length &amp;&amp; grid[newx][newy]==<span class="hljs-number">1</span> &amp;&amp; !used[newx][newy])&#123;<br>                                count++;<br>                                queue.add(newx*grid[<span class="hljs-number">0</span>].length+newy);<br>                                used[newx][newy] = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    max = Math.max(max,count);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>岛屿问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表排序</title>
    <link href="/2022/11/04/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/11/04/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode-148-排序链表"><a href="#leetCode-148-排序链表" class="headerlink" title="leetCode-148 排序链表"></a>leetCode-148 排序链表</h1><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p>示例 1：</p><p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/sort_list_1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">4,2,1,3</span>]<br>输出：[<span class="hljs-number">1,2,3,4</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/sort_list_2.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [-<span class="hljs-number">1,5,3,4</span>,<span class="hljs-number">0</span>]<br>输出：[-<span class="hljs-number">1,0,3,4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p><p>在 <code>O(n log n)</code> 时间复杂度排序中，有快速排序和归并排序。</p><h2 id="使用归并排序"><a href="#使用归并排序" class="headerlink" title="使用归并排序"></a>使用归并排序</h2><p>对链表找到中间点进行截断，知道截断只剩下一个元素，再进行合并。</p><p>合并时，建立一个临时链表，按顺序添加到临时链表中。</p><blockquote><p> <strong>怎么找到链表的中间点：</strong>使用快慢指针，快指针每次走两步，满指针每次走一步。当快指针走到最后，慢指针所指向的链表节点就为中间节点。</p></blockquote><blockquote><p> <strong>注意：</strong>如果题目中给出的链表没有头结点，将设置一个头结点指向第一个节点，方便操作。</p></blockquote><p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png" alt="Picture2.png"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//设置一个头结点指向第一个节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        node.next = head;<br>        <span class="hljs-comment">//快慢指针首先都指向头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> node, slow = node;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-comment">//slow是将链表分为一半的节点位置，建立一个新链表存储中间节点后面的节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> slow.next;<br>        <span class="hljs-comment">//将中间节点作为切割，因此指向空节点</span><br>        slow.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sortList(head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sortList(tmp);<br>        <span class="hljs-comment">//临时链表存放排序后的节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> h;<br>        <span class="hljs-keyword">while</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (left.val &lt; right.val) &#123;<br>                h.next = left;<br>                left = left.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                h.next = right;<br>                right = right.next;<br>            &#125;<br>            h = h.next;<br>        &#125;<br>        h.next = left != <span class="hljs-literal">null</span> ? left : right;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用快速排序"><a href="#使用快速排序" class="headerlink" title="使用快速排序"></a>使用快速排序</h2><p>快速排序就是找到一个基准值，进行链表的分割，创建一个临时链表，添加比基准值小的节点，另一个原先得链表都是大于等于基准值得节点，</p><p>再将原来得链表拼接到临时链表得后面，进行下次排序。</p><p>下次排序分别对基准值得左边和右边进行排序。</p><p><img src="/2022/11/04/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/image-20221104133529454.png" alt="image-20221104133529454"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>||head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 没有条件，创造条件。自己添加头节点，最后返回时去掉即可。</span><br>        ListNode newHead=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        newHead.next=head;<br>        <span class="hljs-keyword">return</span> quickSort(newHead,<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">// 带头结点的链表快速排序</span><br>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">quickSort</span><span class="hljs-params">(ListNode head,ListNode end)</span>&#123;<br>        <span class="hljs-keyword">if</span> (head==end||head.next==end) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 将小于划分点的值存储在临时链表中</span><br>        ListNode tmpHead=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// partition为划分点，p为链表指针，tp为临时链表指针</span><br>        ListNode partition=head.next,p=partition,tp=tmpHead;<br>        <span class="hljs-comment">// 将小于划分点的结点放到临时链表中</span><br>        <span class="hljs-keyword">while</span> (p.next!=end)&#123;<br>            <span class="hljs-keyword">if</span> (p.next.val&lt;partition.val)&#123;<br>                tp.next=p.next;<br>                tp=tp.next;<br>                p.next=p.next.next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                p=p.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 合并临时链表和原链表，将原链表接到临时链表后面即可</span><br>        tp.next=head.next;<br>        <span class="hljs-comment">// 将临时链表插回原链表，注意是插回！（不做这一步在对右半部分处理时就断链了）</span><br>        head.next=tmpHead.next;<br>        quickSort(head,partition);<br>        quickSort(partition,end);<br>        <span class="hljs-comment">// 题目要求不带头节点，返回结果时去除</span><br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>阅文集团笔试</title>
    <link href="/2022/11/01/%E9%98%85%E6%96%87%E9%9B%86%E5%9B%A2%E7%AC%94%E8%AF%95/"/>
    <url>/2022/11/01/%E9%98%85%E6%96%87%E9%9B%86%E5%9B%A2%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h1><p>力扣328~</p><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p><p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 <code>O(1)</code> 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p><p><img src="/2022/11/01/%E9%98%85%E6%96%87%E9%9B%86%E5%9B%A2%E7%AC%94%E8%AF%95/oddeven-linked-list.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出: <span class="hljs-string">[1,3,5,2,4]</span><br></code></pre></td></tr></table></figure><p><img src="/2022/11/01/%E9%98%85%E6%96%87%E9%9B%86%E5%9B%A2%E7%AC%94%E8%AF%95/oddeven2-linked-list.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: head = <span class="hljs-string">[2,1,3,5,6,4,7]</span><br>输出: <span class="hljs-string">[2,3,6,7,1,5,4]</span><br></code></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>对于原始链表来说，头节点是奇数节点，头结点的下一个为偶数节点。令<code>evenHead=head.next</code>。则evenHead为偶数链表的头节点。</p><p>维护两个指针，<code>odd</code>和<code>even</code>分别指向奇数点和偶数点。初始值为<code>odd=head</code>，<code>even = evenHead</code>。</p><p>通过迭代的方式，将奇数节点和偶数节点分离成两个链表。每一步先更新奇数节点，后更新偶数节点。</p><p>更新奇数节点：<code>odd.next = even.next; odd=odd.nex;</code></p><p>更新偶数节点：<code>even = odd.next; even = even.next;</code></p><p>最后的结束条件是，<code>even</code>为<code>null</code>或者<code>even.next</code>为<code>null</code>。就是奇数链表的最后一个节点，最后将<code>odd.next=evenHead</code>。就是将奇数链表和偶数链表连接在一起。头节点仍然是<code>head</code>。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">oddEvenList</span> <span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">evenHead</span> <span class="hljs-operator">=</span> head.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">odd</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">even</span> <span class="hljs-operator">=</span> evenHead;<br>        <span class="hljs-keyword">while</span> (even!=<span class="hljs-literal">null</span> &amp;&amp; even.next!=<span class="hljs-literal">null</span>)&#123;<br>            odd.next = even.next;<br>            odd = odd.next;<br>            even.next = odd.next;<br>            even = even.next;<br>        &#125;<br>        odd.next = evenHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h1><p>力扣88~</p><p>合并两个有序链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], m = <span class="hljs-number">3</span>, nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], n = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：需要合并 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] 。<br>合并结果是 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] ，其中斜体加粗标注的为 nums1 中的元素。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums1 = [<span class="hljs-number">1</span>], m = <span class="hljs-number">1</span>, nums2 = [], n = <span class="hljs-number">0</span><br>输出：[<span class="hljs-number">1</span>]<br>解释：需要合并 [<span class="hljs-number">1</span>] 和 [] 。<br>合并结果是 [<span class="hljs-number">1</span>] 。<br></code></pre></td></tr></table></figure><p><strong>方法一：</strong></p><p>直接将nums2中的元素加入到num1中，再对num1排序就可。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != n; ++i) &#123;<br>            nums1[m + i] = nums2[i];<br>        &#125;<br>        Arrays.sort(nums1);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>方法二：</strong></p><p>借助一个数组，通过双指针，存放num1和num2比较结果最小的一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (p1&lt;m &amp;&amp; p2&lt;n)&#123;<br>            <span class="hljs-keyword">if</span> (nums1[p1]&lt;nums2[p2])&#123;<br>                res[index++] = nums1[p1];<br>                p1++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                res[index++] = nums2[p2];<br>                p2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (p1&lt;m) res[index++] = nums1[p1++];<br>        <span class="hljs-keyword">while</span> (p2&lt;n) res[index++] = nums2[p2++];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m+n;i++)&#123;<br>            nums1[i] = res[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法三：</strong></p><blockquote><p>方法二中，之所以要使用临时变量，是因为如果直接合并到数组nums 1中，nums 1中的元素可能会在取出之前被覆盖。那么如何直接避免覆盖nums 1中的元素呢？观察可知，nums 1的后半部分是空的，可以直接覆盖而不会影响结果。因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进nums 1 的最后面。</p></blockquote><ol><li><p>思路的重点一个是从后往前确定两组中该用哪个数字</p></li><li><p>另一个是结束条件以第二个数组全都插入进去为止</p><p><strong>直接在nums1数组上进行修改。</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums1.length;<br>        <br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span> &amp;&amp; nums1[m - <span class="hljs-number">1</span>] &gt; nums2[n - <span class="hljs-number">1</span>]) &#123;<br>                nums1[i - <span class="hljs-number">1</span>] = nums1[m - <span class="hljs-number">1</span>];<br>                i--;<br>                m--;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                nums1[i - <span class="hljs-number">1</span>] = nums2[n - <span class="hljs-number">1</span>];<br>                i--;<br>                n--;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>阅文集团</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试准备</title>
    <link href="/2022/10/31/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2022/10/31/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么选择银行"><a href="#为什么选择银行" class="headerlink" title="为什么选择银行"></a>为什么选择银行</h1><p>（1）首先，银行可以给自己提供一个稳定的职业发展环境，能够静下心来学习知识，提升个人技术水平，并且能够很快的持续性的成长。</p><p>（2）其次，我的本科和研究生都是软件工程专业，正式金融科技岗位所需要的技术，所以专业对口。</p><p>（3）最后，银行有不错的薪资待遇福利，也是吸引我的点。</p><h1 id="对银行有什么了解"><a href="#对银行有什么了解" class="headerlink" title="对银行有什么了解"></a>对银行有什么了解</h1><h1 id="说说金融科技的优缺点"><a href="#说说金融科技的优缺点" class="headerlink" title="说说金融科技的优缺点"></a>说说金融科技的优缺点</h1><p><strong>优点：</strong></p><p>（1）随着科技技术的进步，商业银行已经不能使用以前传统的方式开展业务，因此，金融科技使银行的业务种类增加，</p><p>（2）便利：客户可以使用手机来管理他们的财务状况，提高交易的效率和便利</p><p>（3）效率高：随时随地的服务，所有的操作都可以线上完成，不需要到柜台。</p><p><strong>缺点：</strong></p><p>（1）数据安全风险：客户的私人信息，如果金融机构对于信息的存储和保管力度不够，或被黑客攻击，则会使信息泄露，损失机构 和 个人。</p><p>（2）操作风险：不成熟的内部控制和员工培训系统，容易发生操作失误的现象，</p><h1 id="为什么选择招商银行？"><a href="#为什么选择招商银行？" class="headerlink" title="为什么选择招商银行？"></a>为什么选择招商银行？</h1><p>（1）招商银行是第一家股份制银行，也是排名前十的银行<br>（2）相较于国有银行，招商银行的服务更加人性化（柜面服务灵活，内部机制多元化），比如信用卡，是行业中最受欢迎的信用卡。<br>（3）零售业很多，占比很高，业务齐全<br>（4）薪酬待遇好，有更大的发展空间<br>（5）各种形式的企业文化活动，行庆，评先评优，企业文化月等等。</p><h1 id="为什么选择这个岗位？"><a href="#为什么选择这个岗位？" class="headerlink" title="为什么选择这个岗位？"></a>为什么选择这个岗位？</h1><p>（1）首先金融科技岗位与我目前所学的知识和专业非常的匹配。</p><p>（2）其次对于招商银行这个大规模的银行来说，有很好的职业发展。</p><p>（3）最后就是薪资待遇很好。</p><p>氛围好，也是我在求职过程中非常看中的因素</p><h1 id="对未来的工作计划？"><a href="#对未来的工作计划？" class="headerlink" title="对未来的工作计划？"></a>对未来的工作计划？</h1><p>（1）首先，当我进入公司以后，我会熟悉公司的环境，了解公司的业务流程，熟悉公司同事和相处模式，掌握自己的职位<br>（2）接着开始学习和提高自己本职工作的内容。认真完成领导布置的任务，虚心听取领导和同事的建议，争取做到可以独自处理问题的能力。</p><p>（3）不断的提升自我，为公司贡献一份微薄之力</p><h1 id="短时间内如何掌握知识技能？"><a href="#短时间内如何掌握知识技能？" class="headerlink" title="短时间内如何掌握知识技能？"></a>短时间内如何掌握知识技能？</h1><p>（1）制定学习目标，学习策略<br>（2）了解该技能能够干什么，能够应用在哪，快速了解整体的构成，这样会使我更加对这项技术产生兴趣，而不是直接拿来一个厚本的书去读，反而失去了了解它的兴趣<br>（3）了解后，再对里面很细小的内容进行学习，一部分一部分有规划的去学习，一点点的攻破，也不要忘了及时去复习<br>（4）在学习理论的同时也要与实践相结合，只有运用到实际的项目中，才是真正的会用。</p><h1 id="讲述你遇到的最大的困难，原因和结果？"><a href="#讲述你遇到的最大的困难，原因和结果？" class="headerlink" title="讲述你遇到的最大的困难，原因和结果？"></a>讲述你遇到的最大的困难，原因和结果？</h1><p>对于最大的困难，由于还没有走向社会，所以困难也就是学校中的一些问题，就说一个我在参加数学建模时遇到的困难把。</p><p>参加这次比赛的困难，主要是第一次参加，不是很了解数学建模方面的知识，并且只有三天的时间准备，恰巧那个时间我们的数学老师出差没在学校。所以一切的问题都需要我们第三个人自己解决。看着其他组的老师和学生讨论的沸沸扬扬，我们只好通过网路的渠道进行学习，偶尔也会去别的组听其他人的老师讲解。</p><p>在这个解决的过程中，我们做的最大的决定就是分配工作的时候，以每个人最擅长的领域进行了分配，通过三天的努力，最后做出了成果，其实无论结果怎样，在这个过程中最宝贵的是我们都没有放弃，有克服困难继续前进的精神。最后获得了辽宁省二等奖。我们学院只有我们这一组获得了省级奖。</p><h1 id="介绍三个学习工具并举例"><a href="#介绍三个学习工具并举例" class="headerlink" title="介绍三个学习工具并举例"></a>介绍三个学习工具并举例</h1><h1 id="在顾客的角度，你觉得什么是最好的服务。"><a href="#在顾客的角度，你觉得什么是最好的服务。" class="headerlink" title="在顾客的角度，你觉得什么是最好的服务。"></a>在顾客的角度，你觉得什么是最好的服务。</h1><p>（1）主动意识：积极主动的与客户进行沟通，及时的知道客户想要什么，该如何去解决。</p><p>（2）微笑服务：微笑是任何职能设备无法取代的，是人与人之间交往最具有魅力的名片。</p><p>（3）学会聆听：虚心接收客户的建议，耐心聆听客户的问题。</p><p>（4）保持热情：尽心尽力的解决客户的问题，耐心解答客户的问题。保持热情的同时也影响客户的心情，交谈融洽。</p><h1 id="谈一谈你对创新的认识，每人一分钟。"><a href="#谈一谈你对创新的认识，每人一分钟。" class="headerlink" title="谈一谈你对创新的认识，每人一分钟。"></a>谈一谈你对创新的认识，每人一分钟。</h1><p>每个人都可以有源源不断的创新来成功应对实际生活中遇到的问题和挑战，创造价值。</p><p>我所理解的创新就是能够推动一个国家的发展，比如说我们的论文，学校要求我们的论文要有3个创新点，以及在期刊和会议上发表的论文一定要创新点才可以发出，这是为什么呢，因为对于问题的解决我们要善于发现有无更好的办法去解决，可以国家给世界带来什么样的进步，这就是创新。</p><h1 id="什么样的雇主是好雇主"><a href="#什么样的雇主是好雇主" class="headerlink" title="什么样的雇主是好雇主"></a>什么样的雇主是好雇主</h1><p>（1）看重员工长期的职业发展</p><p>（2）内部晋升公平公正</p><p>（3）经常沟通，所谓：居庙堂之高则忧其民，处江湖之远则忧其君。所以身为领导人，不仅要看行业公司的发展，也要看到员工们的意见。</p><p>（4）营造公司的氛围，关系和谐，氛围轻松。</p><h1 id="说一说你对十九大的认识"><a href="#说一说你对十九大的认识" class="headerlink" title="说一说你对十九大的认识"></a>说一说你对十九大的认识</h1><h1 id="在团队中自己的优势是什么"><a href="#在团队中自己的优势是什么" class="headerlink" title="在团队中自己的优势是什么"></a>在团队中自己的优势是什么</h1><h1 id="工作不顺利，如何处理？"><a href="#工作不顺利，如何处理？" class="headerlink" title="工作不顺利，如何处理？"></a>工作不顺利，如何处理？</h1><p>（1）从头仔细的研究这项工作，找到是哪个地方导致的顺利。如果找到，则进行解决，</p><p>（2）如果没有找到，则寻求周围的同事或者领导，因为领导的经验丰富，可能通过领导的一句话就能解决。</p><p>（3）调整心态，解决问题，没有解决不了的问题，如果解决不了，就重头再来。</p><h1 id="学习中遇到的问题，是如何解决的。"><a href="#学习中遇到的问题，是如何解决的。" class="headerlink" title="学习中遇到的问题，是如何解决的。"></a>学习中遇到的问题，是如何解决的。</h1><p>科研。。</p><h1 id="怎样收集高质量信息，事例说明"><a href="#怎样收集高质量信息，事例说明" class="headerlink" title="怎样收集高质量信息，事例说明"></a>怎样收集高质量信息，事例说明</h1><h1 id="分享失败的经历，哪些收获和成长？"><a href="#分享失败的经历，哪些收获和成长？" class="headerlink" title="分享失败的经历，哪些收获和成长？"></a>分享失败的经历，哪些收获和成长？</h1><p>创新创业。。。</p><h1 id="领导私下向您了解某同事的基本情况，这位同事误以为您向老板告了状。在之后的工作中故意针对您，您怎么办？"><a href="#领导私下向您了解某同事的基本情况，这位同事误以为您向老板告了状。在之后的工作中故意针对您，您怎么办？" class="headerlink" title="领导私下向您了解某同事的基本情况，这位同事误以为您向老板告了状。在之后的工作中故意针对您，您怎么办？"></a>领导私下向您了解某同事的基本情况，这位同事误以为您向老板告了状。在之后的工作中故意针对您，您怎么办？</h1><h1 id="对不太熟悉的任务，有人会推掉，而有人会尽力争取，希望能从中学习。对此您怎么看？您会怎么选？请说明理由"><a href="#对不太熟悉的任务，有人会推掉，而有人会尽力争取，希望能从中学习。对此您怎么看？您会怎么选？请说明理由" class="headerlink" title="对不太熟悉的任务，有人会推掉，而有人会尽力争取，希望能从中学习。对此您怎么看？您会怎么选？请说明理由"></a>对不太熟悉的任务，有人会推掉，而有人会尽力争取，希望能从中学习。对此您怎么看？您会怎么选？请说明理由</h1><h1 id="一位同事为了促进自身成长，承担大量工作-每天加班，很多人说他傻-是自找的。您怎么看待这种现象？"><a href="#一位同事为了促进自身成长，承担大量工作-每天加班，很多人说他傻-是自找的。您怎么看待这种现象？" class="headerlink" title="一位同事为了促进自身成长，承担大量工作 每天加班，很多人说他傻 是自找的。您怎么看待这种现象？"></a>一位同事为了促进自身成长，承担大量工作 每天加班，很多人说他傻 是自找的。您怎么看待这种现象？</h1><p>（1）无论是在职场中还是在其他环境中，要是想在一个集合中获得喜爱，则都需要随主流。这样的随主流，表示你不能有自己的看法，要和大家站一起。但这也表示了 你忘记了自己的初心，不能取得自己的成就。</p><p>（2）首先要杜绝这种现象的发生，同事不是我们讨好的对象，不能为了很好的相处，和为了不被别人说而的放弃自己的目标。要想自己有很快的提升就是要付出更多的努力，坚守自我。</p><p>（3）没有那种为了和同事搞好关系而自己就不努力工作的这种规则，。这是每个人的目标不同，想要更高的舞台和提高能力，就要付出努力。不要在乎别人说什么而动摇自己。</p><h1 id="您认为要做到高效-准确地收集与整理信息。有哪些需要注意的地方？请分享一下您在这方面的方法和技巧"><a href="#您认为要做到高效-准确地收集与整理信息。有哪些需要注意的地方？请分享一下您在这方面的方法和技巧" class="headerlink" title="您认为要做到高效 准确地收集与整理信息。有哪些需要注意的地方？请分享一下您在这方面的方法和技巧"></a>您认为要做到高效 准确地收集与整理信息。有哪些需要注意的地方？请分享一下您在这方面的方法和技巧</h1><p>（1）明确想要收集信息的目标，也就是明确目前所存在的问题。<br>（2）做记录，对于搜集出来的信息要做记录，在闲暇的时候拿出来翻看，对比，保证信息收集和整理的高效和准确<br>（3）当完成前期信息的收集后，要及时舍弃无用的信息，保证信息及时更新和整理。</p><h1 id="工作中每天都要处理大量问题，您打算如何在接下来的工作中提升自己的问题解决能力？"><a href="#工作中每天都要处理大量问题，您打算如何在接下来的工作中提升自己的问题解决能力？" class="headerlink" title="工作中每天都要处理大量问题，您打算如何在接下来的工作中提升自己的问题解决能力？"></a>工作中每天都要处理大量问题，您打算如何在接下来的工作中提升自己的问题解决能力？</h1><h1 id="上级给您布置了某项任务，对质量的要求非常高。但给的时间并不多，还需要协调一些资源。您会如何做？"><a href="#上级给您布置了某项任务，对质量的要求非常高。但给的时间并不多，还需要协调一些资源。您会如何做？" class="headerlink" title="上级给您布置了某项任务，对质量的要求非常高。但给的时间并不多，还需要协调一些资源。您会如何做？"></a>上级给您布置了某项任务，对质量的要求非常高。但给的时间并不多，还需要协调一些资源。您会如何做？</h1><p>（1）分清任务的轻重缓急，紧急又重要的任务先完成</p><p>（2）发动团队其他成员，借力完成</p><p>（3）鼓励老人带新人，提高工作效率</p><p>（4）如果还是不行，则先完成重要的部分，其他不重要的部分缓办。</p><h1 id="同事做项目的思路是错的，但是始终固执己见，您作为这个项目组的成员。此时会怎么办？"><a href="#同事做项目的思路是错的，但是始终固执己见，您作为这个项目组的成员。此时会怎么办？" class="headerlink" title="同事做项目的思路是错的，但是始终固执己见，您作为这个项目组的成员。此时会怎么办？"></a>同事做项目的思路是错的，但是始终固执己见，您作为这个项目组的成员。此时会怎么办？</h1><h1 id="何为“职业素养”？"><a href="#何为“职业素养”？" class="headerlink" title="何为“职业素养”？"></a>何为“职业素养”？</h1><p>（1）体现在职场上的就是职业素养，体现在生活中的就是个人素质和道德修养。</p><p>（2）职业信念：正面积极的职业心态和正确的职业价值观，</p><p>（3）职业知识技能：做好一个职业应该具备的专业知识和能力</p><p>（4）职业行为习惯：就是在职场上通过长时间的学习和改变而形成的习惯。</p><h1 id="如何看待裸辞现象？"><a href="#如何看待裸辞现象？" class="headerlink" title="如何看待裸辞现象？"></a>如何看待裸辞现象？</h1><p><strong>（1）冲动下辞职，其实并没有想好：</strong></p><p>冲动下辞职，不提倡。因为裸辞的压力非常大，如果一时间没有找到工作，整个人会非常焦躁、焦虑，除非你是一个心态非常好的人。而且工作中出现愤怒的事，出现挫折、委屈的事太正常了，这次冲动了，下次呢，总不能碰上了全部冲动辞职。学会调节自己的情绪也是职场必修课。</p><p><strong>（2）实在无法忍受，对自己造成巨大的压力和困扰，即使没找到下家，也要辞职。</strong></p><p>如果这份工作已经给你造成很大的困扰了。无论是和领导的相处，或是公司的氛围、工作的内容等，你需要承受很大的压力和焦虑，又一时找不到新的好工作。那么实在挺不了，裸辞也不是什么大事，毕竟身心的健康才是最重要的。</p><p>‘裸辞’只是暂时逃避压力的方法，对于绝大多数白领来说，最终还是要回归职场。因此，当自己情绪激动时，尽量不要因为冲动而做出重大决定。”专家提醒各位职场人：冲动是魔鬼，“裸辞”前请一定要先做规划，三思而后行。</p><h1 id="如何理解“工作中要注重结果导向”？"><a href="#如何理解“工作中要注重结果导向”？" class="headerlink" title="如何理解“工作中要注重结果导向”？"></a>如何理解“工作中要注重结果导向”？</h1><p>就是看重工作的结果，不在乎过程怎么样，</p><p>这类人的优点就是目标明确，一旦认准目标，便不达目的不罢休。</p><p>如果你是领导，相信也会对结果导向的员工青眼有加，因这类人更能为企业带来价值</p><p><strong>那么如果理解职场中的结果导向：</strong></p><p>（1）确认对象是第一步：认清责任对象也是我们理解职场中以结果为导向的重点之一。</p><p>（2）明确对象需求，对标需求展开工作</p><p>（3）结果是硬性标准，不是无限接近：领导和客户需要你的工作成果，晋升的评职选优的也需要看成果，在这过程中，无论你付出了多少，只要没有达到那条红线，哪怕是无限接近也是不合格，没有交付成果只有过程也不算是完成工作。</p><p><strong>毕竟团队里需要的角色不止一种，除了结果导向也需要目标和人际关系为导向，如果团队需要在短时间内完成一件棘手的工作，以结果为导向的成员当然是团队的主力军。可长期的团队建设也需要以关系为导向的成员存在。</strong></p><h1 id="如何看待年轻人一边熬夜一边养生的现象？"><a href="#如何看待年轻人一边熬夜一边养生的现象？" class="headerlink" title="如何看待年轻人一边熬夜一边养生的现象？"></a>如何看待年轻人一边熬夜一边养生的现象？</h1><p>这个现象很普遍，但却不值得提倡。如今的年轻人认为熬夜对身体不好，不熬夜又让心情不好，所以为了让自己的身体和心情同样美好，就选择了一边熬夜一边养生的方法。</p><p>因为年轻人一边控制不住自己去熬夜，但是又害怕熬夜带来非常大的伤害，所以又去养生。</p><p>其实很多时候白天都是需要做一些必须要做的事情，只有晚上才能做做自己喜欢的事情，所以就不得不边熬夜变养生了！</p><h1 id="入职一段时间发现氛围不符合预期怎么办？"><a href="#入职一段时间发现氛围不符合预期怎么办？" class="headerlink" title="入职一段时间发现氛围不符合预期怎么办？"></a>入职一段时间发现氛围不符合预期怎么办？</h1><p>首先想，是否是自己的问题，因为在职场上，不是每份工作都是各个方面都可以如愿的，要做的其实是认清楚自己想要的，具体点说就是你要给自己想从工作中得到的东西排好序号，可以用这段试用期好好地尝试这份工作，更重要的就是想好自己工作的考量因素，不然很容易去到任何的公司，都会有一样的问题。</p><p>如果真的觉得每天工作很压抑也有压力，焦虑，则可以选择离职，因为才刚刚入职，自己的身心健康最重要。</p><h1 id="当代青年人最宝贵和最欠缺的品质是什么？"><a href="#当代青年人最宝贵和最欠缺的品质是什么？" class="headerlink" title="当代青年人最宝贵和最欠缺的品质是什么？"></a>当代青年人最宝贵和最欠缺的品质是什么？</h1><h1 id="请讨论，五年之内人工智能能否取代柜员？正方：人工智能将取代柜员-反方：人工智能不能取代柜员"><a href="#请讨论，五年之内人工智能能否取代柜员？正方：人工智能将取代柜员-反方：人工智能不能取代柜员" class="headerlink" title="请讨论，五年之内人工智能能否取代柜员？正方：人工智能将取代柜员 反方：人工智能不能取代柜员"></a>请讨论，五年之内人工智能能否取代柜员？正方：人工智能将取代柜员 反方：人工智能不能取代柜员</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>银行</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>得物笔试</title>
    <link href="/2022/10/30/%E5%BE%97%E7%89%A9%E7%AC%94%E8%AF%95/"/>
    <url>/2022/10/30/%E5%BE%97%E7%89%A9%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法一（前序-中序输出后序）"><a href="#算法一（前序-中序输出后序）" class="headerlink" title="算法一（前序+中序输出后序）"></a>算法一（前序+中序输出后序）</h1><p><strong>根据树的前序和中序输出后序</strong></p><p>分析：</p><blockquote><p>首先前序遍历的第一个节点一定为根节点，</p><p>找到中序遍历中的根节点，则根节点两边的数字就是左右子树。</p><p>例如：前序：1 2 4 5 3 6 7 ，中序：4 2 5 1 6 3 7，则根节点为1，根节点的左子树：4 2 5 ，根节点的右子树为：6 3 7.</p><p>找到左右子树后，分别对左右子树进行同样的操作。因此递归可以实现。</p><p>通过遍历前序遍历的节点，找到中序遍历中出现的位置，则左右两边就是左右子树</p></blockquote><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        Scanner input = new Scanner(System.in);</span><br><span class="hljs-comment">//        int N = input.nextInt();</span><br><span class="hljs-comment">//        int[] preorder = new int[N];</span><br><span class="hljs-comment">//        int[] inorder = new int[N];</span><br><span class="hljs-comment">//        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="hljs-comment">//            preorder[i] = input.nextInt();</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="hljs-comment">//            inorder[i] = input.nextInt();</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-type">int</span> preorder[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">int</span> inorder[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>().buildTree(preorder, inorder);<br>    &#125;<br>    <span class="hljs-comment">//存储前序遍历的节点在中序遍历中的位置</span><br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] preorder;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.preorder = preorder;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>            map.put(inorder[i], i);<br>        &#125;<br>        build(<span class="hljs-number">0</span>, preorder.length-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">build</span><span class="hljs-params">(<span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span> &#123;<br>        <span class="hljs-keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">//前序遍历的节点值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preorder[preStart];<br>        <span class="hljs-comment">//获取该节点在中序遍历中的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> map.get(rootVal);<br>        <span class="hljs-comment">//计算左子树的数量，</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftNum</span> <span class="hljs-operator">=</span> rootIndex - inStart;<span class="hljs-comment">//当遍历右子树的左子树时有用。</span><br>        <span class="hljs-comment">//递归遍历</span><br>        build(preStart+<span class="hljs-number">1</span>, preStart+leftNum, inStart, rootIndex-<span class="hljs-number">1</span>);<br>        build(preStart+leftNum+<span class="hljs-number">1</span>, preEnd, rootIndex+<span class="hljs-number">1</span>, inEnd);<br>        System.out.print(rootVal + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="后序-中序输出前序"><a href="#后序-中序输出前序" class="headerlink" title="后序+中序输出前序"></a>后序+中序输出前序</h2><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> inorder[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> lastorder[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">static</span> Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;inorder.length;i++)&#123;<br>            map.put(inorder[i],i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> inorder.length;<br>        dfs(<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> inl,<span class="hljs-type">int</span> inr,<span class="hljs-type">int</span> lal,<span class="hljs-type">int</span> lar)</span>&#123;<br>        <span class="hljs-keyword">if</span> (lal&gt;lar) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> map.get(lastorder[lar]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftNum</span> <span class="hljs-operator">=</span> t-inl-<span class="hljs-number">1</span>;<span class="hljs-comment">//因为后序遍历的左子树部分，没有根节点，根节点在最后，所以要-1.</span><br>        System.out.print(lastorder[lar]+ <span class="hljs-string">&quot; &quot;</span>);<br>        dfs(inl,t-<span class="hljs-number">1</span>,lal,lal+leftNum);<br>        dfs(t+<span class="hljs-number">1</span>,inr,lal+leftNum+<span class="hljs-number">1</span>,lar-<span class="hljs-number">1</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法二（双栈排序）"><a href="#算法二（双栈排序）" class="headerlink" title="算法二（双栈排序）"></a>算法二（双栈排序）</h1><p><strong>给定一个乱序的栈，设计算法将其升序排列。</strong></p><p><strong>ps: 允许额外使用一个栈来辅助操作</strong></p><p>分析：</p><blockquote><p>通过一个辅助栈来给栈排序</p><p>也就是保持辅助栈中的元素是单调递增的。</p><p>如果遍历原栈的栈顶元素小于辅助栈的栈顶元素，则将辅助栈的元素出栈，加入到原栈中的尾部。</p><p>再将目前遍历到的元素加入到辅助栈的栈顶。始终保持辅助栈是单调的。</p><p>依次遍历，知道原栈所有的元素已经加入到辅助栈中排序完成。</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span>  <span class="hljs-operator">=</span> scanner.nextInt();<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            stack.addLast(scanner.nextInt());<br>        &#125;<br>        Deque&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>            System.out.println(stack.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> stack.pollLast();<br>            <span class="hljs-keyword">while</span> (!stack2.isEmpty() &amp;&amp; stack2.peekLast()&gt;t)&#123;<br>                stack.addLast(stack2.pollLast());<br>            &#125;<br>            stack2.addLast(t);<br>        &#125;<br>        System.out.println(stack2.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法三（最小操作数）"><a href="#算法三（最小操作数）" class="headerlink" title="算法三（最小操作数）"></a>算法三（最小操作数）</h1><p><strong>给定一个原串和目标串，能对源串进行如下操作：</strong><br><strong>1.在给定位置插入一个字符</strong><br><strong>2.替换任意字符</strong><br><strong>3.删除任意字符 要求完成一下函数，返回最少的操作数，使得源串进行这些操作后等于目标串。源串和目标串长度都小于200</strong>0。</p><p>分析：</p><blockquote><p>使用动态规划方法：</p><p>设置一个二维的dp数组，<code>dp[i][j]</code>表示原字符串前i个位置到目标字符串前j个位置所需要的最小操作数。</p><p>可以分为以下情况：</p><p>当原串和目标串都为空时：返回0</p><p>当原串为空，目标串不为空时，返回目标串的长度</p><p>当目标串为空，原串不为空时，返回原串的长度</p><p>如果都不为空：</p><p>​如果 i  和 j 的位置相等，则<code>Math.min(dp[i-1][j-1],dp[i-1][j]+1,dp[i][j-1]+1)</code>,否则<code>Math.min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1)</code></p></blockquote><p><img src="/2022/10/30/%E5%BE%97%E7%89%A9%E7%AC%94%E8%AF%95/20210606163146840.png" alt="在这里插入图片描述"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperationCount</span><span class="hljs-params">(String source, String target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> source.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> target.length();<br>        <span class="hljs-keyword">if</span> (m==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;<br>        <span class="hljs-type">int</span> dp[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;=m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i] = i;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> source.charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch2</span> <span class="hljs-operator">=</span> source.charAt(j);<br>                <span class="hljs-keyword">if</span> (ch==ch2)&#123;<br>                  f = <span class="hljs-number">0</span>;<br>                &#125;<span class="hljs-keyword">else</span> f = <span class="hljs-number">1</span>;<br>                dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+f,Math.min(dp[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>,dp[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>得物</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>58一面</title>
    <link href="/2022/10/28/58%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/10/28/58%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><h1 id="Http缓存用到了什么字段"><a href="#Http缓存用到了什么字段" class="headerlink" title="Http缓存用到了什么字段"></a>Http缓存用到了什么字段</h1><h1 id="Tcp三次握手交换了哪些数据"><a href="#Tcp三次握手交换了哪些数据" class="headerlink" title="Tcp三次握手交换了哪些数据"></a>Tcp三次握手交换了哪些数据</h1><h1 id="IP协议中的TTL是什么"><a href="#IP协议中的TTL是什么" class="headerlink" title="IP协议中的TTL是什么"></a>IP协议中的TTL是什么</h1><h1 id="操作系统的调度算法"><a href="#操作系统的调度算法" class="headerlink" title="操作系统的调度算法"></a>操作系统的调度算法</h1><h1 id="索引中的数据结构用的是什么，有什么区别"><a href="#索引中的数据结构用的是什么，有什么区别" class="headerlink" title="索引中的数据结构用的是什么，有什么区别"></a>索引中的数据结构用的是什么，有什么区别</h1><h1 id="redis中基本数据类型的zset底层是什么"><a href="#redis中基本数据类型的zset底层是什么" class="headerlink" title="redis中基本数据类型的zset底层是什么"></a>redis中基本数据类型的zset底层是什么</h1><h1 id="redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程"><a href="#redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程" class="headerlink" title="redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程"></a>redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>58同城</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高途一面</title>
    <link href="/2022/10/12/%E9%AB%98%E9%80%94%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/10/12/%E9%AB%98%E9%80%94%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h1 id="什么是GC"><a href="#什么是GC" class="headerlink" title="什么是GC"></a>什么是GC</h1><p><strong>释放那些不再使用的对象所占用的内存。GC首先要判断对象是否一个被收集，常用判断是否被收集的两种方法为</strong></p><ul><li>引用计数法：给对象添加引用计数器，每当有引用它的地方，就将计数器+1，当引用失效后，引用计数器-1，当计数器为0时，可以进行回收。</li><li>可达性分析法：扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到则可以进行回收。</li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><ul><li><strong>串行垃圾回收器（serial）：</strong>也就是<strong>单线程回收器</strong>，在进行垃圾回收工作的时候，要暂停其他线程，直到它收集结束。新生代采用复制算法，老年代采用标记-整理算法。<ul><li>缺点是：STP时间太长，用户体验不佳</li><li>优点是：简单高效，没有线程之间的开销</li></ul></li><li><strong>ParNew回收器（多线程回收器）：</strong>除了使用多线程进行垃圾回收外，其余的与单线程回收器一样。</li><li><strong>Parallel Scavenge（吞吐量优先回收器）：并行收集器，</strong>高效率的利用cpu，吞吐量就是CPU用于运行用户代码的时间与CPU总消耗的时间比值。垃圾回收器并行工作（多条收集线程并行工作，但用户线程仍然处于等待状态）。</li><li><strong>CMS收集器（响应时间优先）：并发收集器</strong>（指⽤户线程与垃圾收集线程同时执⾏（但不⼀定是并⾏，可能会交替执⾏），⽤户程序在继续运⾏，⽽垃圾收集器运⾏在另⼀个 CPU 上）以最短回收停顿时间为目标的收集器，注重用户体验，整个过程分为四步骤：<ul><li>初始标记：暂停其他线程，记录直与root相连的对象，速度很快。</li><li>并发标记：GC和用户线程同时执行，由于用户线程会不断的更新引用域，所以GC无法达到可行性分析的实时性，</li><li>重新标记：为了修正并发标记期间用户程序运行改变的标记，</li><li>并发清除：开启用户线程，同时GC线程开始对未标记的区域做清扫。</li></ul></li></ul><p>使用标记-清楚会产生大量的碎片，但并发标记，低停顿。</p><ul><li><strong>G1：</strong>同时注重吞吐量和低延迟，会将堆划分为多个大小相等的区域。</li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h1 id="OSI七层模式"><a href="#OSI七层模式" class="headerlink" title="OSI七层模式"></a>OSI七层模式</h1><ul><li>应用层：为计算机用户提供服务</li><li>表示层：数据处理（加密，解密，压缩的）</li><li>会话层：管理（建立，维护，重连）应用程序之间的会话</li><li>传输层：为两台主机之间的通信提供通用的数据传输服务</li><li>网络层：路由和寻址，决定数据在网络的游走路径</li><li>数据链路层：帧编码和误差纠错</li><li>物理层：比特流传输</li></ul><h1 id="hashmap底层"><a href="#hashmap底层" class="headerlink" title="hashmap底层"></a>hashmap底层</h1><h1 id="数据库的事务性"><a href="#数据库的事务性" class="headerlink" title="数据库的事务性"></a>数据库的事务性</h1><h1 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h1><p><strong>（1）继承Tread类,步骤：</strong></p><blockquote><p>（1）创建一个继承于Thread的子类<br>（2）重写Thread类的<code>run()</code>方法—-》将此线程执行的操作声明在<code>run()</code>方法中<br>（3）创建继承于Thread的子类的对象<br>（4）调用<code>start()</code>方法（该方法作用：①启动当前线程 ②调用当前线程的<code>run()</code>）</p></blockquote><p><strong>（2）实现Runnable接口，步骤：</strong></p><blockquote><p>（1）创建实现Runnable接口的类<br>（2）实现类去实现Runnable中的抽象方法：<code>run()</code><br>（3）创建实现类的对象<br>（4）将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象<br>（5）通过Thread类的对象调用<code>start()</code></p></blockquote><p><strong>（3）实现Callable接口，步骤：</strong></p><blockquote><p>（1）创建一个实现Callable接口的实现类。</p><p>（2）实现call方法，将此线程需要执行的操作声明在call中</p><p>（3）创建实现Callable接口的实现类的对象</p><p>（4）将该对象传递到FutureTask构造器中，创建FutureTask对象</p><p>（5）将FutureTask对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start方法。</p><p>（6）如果要获取call方法的返回值时，则使用futureTask.get();则不使用。</p></blockquote><p><strong>（4）线程池的方式创建线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) executorService;<br><span class="hljs-comment">// 要在ThreadPoolExecutor类中设置，因为ExecutorService是接口，ThreadPoolExecutor是实现类。</span><br><span class="hljs-comment">//        service.setCorePoolSize(15);</span><br>        executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumThread2</span>());<span class="hljs-comment">//适用于实现Runnable</span><br><span class="hljs-comment">//        executorService.submit(Callable callable)//适用于实现Callable</span><br>        executorService.shutdown(); <span class="hljs-comment">//关闭连接池</span><br></code></pre></td></tr></table></figure><p><strong>好处：</strong></p><blockquote><p>(1)提高响应速度(减少创建新线程的时间)<br>(2)降低资源的消耗(重复利用线程池中的线程,不需要每次都创建)<br>(3)便于线程管理:<br>corePoolSize:核心池的大小<br>maximumPoolSize:最大线程数<br>keepAliveTime:线程没有任务时最多保持多长时间会终止</p></blockquote><h1 id="线程池了解吗"><a href="#线程池了解吗" class="headerlink" title="线程池了解吗"></a>线程池了解吗</h1><h1 id="TCP的3次握手和4次挥手"><a href="#TCP的3次握手和4次挥手" class="headerlink" title="TCP的3次握手和4次挥手"></a>TCP的3次握手和4次挥手</h1><p><img src="/2022/10/12/%E9%AB%98%E9%80%94%E4%B8%80%E9%9D%A2/image-20221013162037305.png" alt="image-20221013162037305"></p><p><img src="/2022/10/12/%E9%AB%98%E9%80%94%E4%B8%80%E9%9D%A2/image-20221013162044295.png" alt="image-20221013162044295"></p><h1 id="SpringBoot比Spring好在哪里"><a href="#SpringBoot比Spring好在哪里" class="headerlink" title="SpringBoot比Spring好在哪里"></a>SpringBoot比Spring好在哪里</h1><p>（1）全部采用注解的方式，没有繁琐的xml配置文件</p><p>（2）快速整合第三方框架：</p><h1 id="说一下IOC和AOP"><a href="#说一下IOC和AOP" class="headerlink" title="说一下IOC和AOP"></a>说一下IOC和AOP</h1><h1 id="项目中用没用到过AOP"><a href="#项目中用没用到过AOP" class="headerlink" title="项目中用没用到过AOP"></a>项目中用没用到过AOP</h1><h1 id="项目中哪里用到了事务"><a href="#项目中哪里用到了事务" class="headerlink" title="项目中哪里用到了事务"></a>项目中哪里用到了事务</h1><p>操作两张表的时候，保证了事务的一致性，要么全成功，要么全失败，</p><p>例如：</p><p>（1）添加套餐这个操作，既要添加套餐这个表，也要添加套餐与菜品的关联表，因此要加入<code>@Transactional</code>注解，来保证要么加入两张表都成功，要么加入两张表都失败。</p><p>（2）提交订单时，要操作两个表，一个时订单表，和订单明细表，因此要使用事务。</p><h1 id="手写二分法"><a href="#手写二分法" class="headerlink" title="手写二分法"></a>手写二分法</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>高途</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PathVariable和RequestParam注解的区别</title>
    <link href="/2022/10/10/PathVariable%E5%92%8CRequestParam%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/10/10/PathVariable%E5%92%8CRequestParam%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="PathVariable-和-RequestParam的区别"><a href="#PathVariable-和-RequestParam的区别" class="headerlink" title="@PathVariable 和 @RequestParam的区别"></a>@PathVariable 和 @RequestParam的区别</h1><p><strong>@RequestParam：</strong>主要是获取<code>？</code>后面的值，</p><p>例如获取<code>http://localhost:8989/SSSP/emps?pageNo=2</code>地址中的pageNo的值“2”</p><p><strong>@PathVariable：</strong>主要是获取路径上的参数，也就是<code>/</code>后面的。</p><p>例如获取<code>http://localhost:8989/SSSP/emp/7</code>地址中，emp&#x2F;7 中的 ‘7 ’</p><h3 id="二、详细讲解"><a href="#二、详细讲解" class="headerlink" title="二、详细讲解"></a>二、详细讲解</h3><p><strong>RequestParam</strong>  汉语意思就是： <strong>请求参数</strong>。顾名思义 就是获取参数的 </p><p><strong>PathVariable</strong> 汉语意思是：<strong>路径变量</strong>。顾名思义，就是要获取一个url 地址中的一部分值，那一部分呢？</p><p>RequestMapping 上说明了@RequestMapping(value&#x3D;”&#x2F;emp&#x2F;<strong>{id}</strong>“），我就是想获取你URL地址 &#x2F;emp&#x2F; 的后面的那个 {id｝的</p><p><strong>@PathVariable是用来获得请求url中的动态参数的</strong></p><p>因此，就看‘？’ 若是想获取 ‘？’ 后面的pageNo 的值 ‘2’， 就使用RequestParam 。若想获取的是url 地址的一部分 ‘7’ 就使用PathVariable</p><p><strong>使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">sale</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;status&quot;)</span> <span class="hljs-type">int</span> status,<span class="hljs-meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/10/PathVariable%E5%92%8CRequestParam%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB/image-20221010114044314.png" alt="image-20221010114044314"></p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试题-redis</title>
    <link href="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/"/>
    <url>/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/</url>
    
    <content type="html"><![CDATA[<h1 id="redis底层数据结构"><a href="#redis底层数据结构" class="headerlink" title="redis底层数据结构"></a>redis底层数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>因为redis是使用C语言开发的，自然没有java的哪些字符串类库，在redis中自定义了一种字符串，叫做<strong>SDS（简单动态字符串）</strong>（Simple Dynamic String）</p><p>sds的底层是使用一个结构体实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">struct sdshdr &#123;<br><span class="hljs-comment">// 记录 buf 数组中已使用字节的数量，它等于 SDS 所保存字符串的长度</span><br><span class="hljs-type">int</span> len;<br><span class="hljs-comment">// 记录 buf 数组中未使用字节的数量</span><br><span class="hljs-type">int</span> free;<br><span class="hljs-comment">// 字节数组，用于保存字符串</span><br><span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323123918257.png" alt="image-20230323123918257"></p><ul><li>free 属性的值为0， 表示这个SDS没有分配任何未使用空间</li><li>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</li><li>buf属性是一个char类型的数组，数组的前五个字节分别保存了’R’、‘e’、‘d’、‘i’、‘s’五个字符，而最后一个字节则保存了空字符’\0’。</li></ul><blockquote><p>SDS 遵循C字符串以空字符串结尾的惯例，保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面，并且为空字符分配额外的 1 字节空间</p></blockquote><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323123958954.png" alt="image-20230323123958954"></p><p>这个SDS和之前展示的SDS一样,都保存了字符串值”Redis”。这个SDS和之前展示的SDS的区别在于，这个SDS为buf数组分配了五字节未使用空间，所以它的free属性的值为5(图中使用五个空格来表示五字节的未使用空间)</p><p><strong>SDS与C字符串的区别：</strong></p><p>（1）<strong>常数复杂度获取字符串长度</strong>：直接访问len就可以了。</p><p>（2）<strong>杜绝缓冲区溢出，</strong>当对SDS进行修改时，会先检查空间是否满足修改所需要的要求，如果不满足，进行空间扩展，再修改。C如果不进行内存重新分配的话就会发生溢出。</p><p>（3）<strong>减少内存重新分配次数</strong>：当增加和缩短字符串的时候，C每次都需要一次内存分配，扩展内存空间或者释放内存空间。由于内存分配涉及复杂的算法，需要系统调用，很耗时，而SDS通过空间预分配和惰性空间两种优化策略。</p><p><strong>空间预分配：</strong></p><ul><li><p>对SDS修改之后，SDSlen属性的值小于1MB,  那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。例，SDS 的len将变成13字节，那么程序也会分配13字节的未使用空间，实际长度将变成 <strong>13+13+1&#x3D;27</strong> 字节</p></li><li><p>对SDS修改之后，SDS 的长度大于等于1MB，那么程序会分配1MB 的未使用空间。如果进行修改之后，SDS的len将变成30MB，SDS的buf数组的实际长度为 <strong>30 MB + 1 MB + 1bytes</strong></p></li></ul><p><strong>惰性空间释放</strong></p><p>优化SDS的字符串缩短操作:缩短字符串时，程序并不立即回收缩短多出来的字节，而是使用free属性记录起来，并等待将来使用。</p><p>（4）<strong>二进制安全：通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。</strong></p><p><strong>举个例子：</strong> 存入 “Redis Cluster” 这种格式就不能用C字符串来保存，因为C字符串所用的函数只会识别出其中的 “Redis” 而忽略之后的 “Cluster”。为了确保 Redis 可以使用不同的场景，SDS 的 API 都是二进制安全的，所有SDS API 都会以处理二进制的方式来处理 SDS 里的数据，数据在被写入时是什么样的，它被读取时就是什么样的。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p><strong>存储在连续内存上的特殊双向链表</strong></p><p>其中各部分代表的含义如下：</p><ul><li>zlbytes：4个字节（32bits），表示ziplist占用的总字节数</li><li>zltail：4个字节（32bits），表示ziplist中最后一个节点在ziplist中的偏移字节数</li><li>entries：2个字节（16bits），表示ziplist中的元素数</li><li>entry：长度不定，表示ziplist中的数据</li><li>zlend：1个字节（8bits），表示结束标记，这个值固定为ff（255）</li></ul><p><strong>特点：</strong></p><ol><li><p>ziplist 为了节省内存，采用了紧凑的连续存储。所以在修改操作下并不能像一般的链表那么容易，需要从新分配新的内存，然后复制到新的空间。</p></li><li><p>ziplist类似一个封装的数组，通过zltail可以方便地进行追加和删除尾部数据、使用entries可以方便地计算长度</p></li><li><p>新增或更新元素可能会出现连锁更新现象。</p></li><li><p>不能保存过多的元素，否则查询效率就会降低。</p><p><strong>通过以上的3、4点就引出了quicklist。</strong></p></li></ol><p><strong>连锁更新现象：</strong></p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323133702901.png" alt="image-20230323133702901"></p><h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>由于ziplist不能保存过多的元素，否则查询性能大大降低，并且会发生连锁更新的情况。因此提出quicklist。</p><p><strong>结合了原先 linkedlist 与 ziplist 各自的优势，本质还是一个链表，只不过链表的每个节点是一个 ziplist。</strong></p><p>quicklist 是综合考虑了时间效率与空间效率引入的新型数据结构。<strong>结合了原先 linkedlist 与 ziplist 各自的优势，本质还是一个链表，只不过链表的每个节点是一个 ziplist。</strong></p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323135547951.png" alt="image-20230323135547951"></p><p>可毕竟还是使用了 ziplist，本质上无法避免连锁更新的问题，于是乎在 5.0 版本设计出另一个内存紧凑型数据结构 listpack，于 7.0 版本替换掉 ziplist。</p><h3 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h3><p><strong>listpack 也是一种紧凑型数据结构，用一块连续的内存空间来保存数据，并且使用多种编码方式来表示不同长度的数据来节省内存空间。</strong></p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323135617155.png" alt="image-20230323135617155"></p><ul><li>tot-bytes，也就是 total bytes，占用 4 字节，记录 listpack 占用的总字节数。</li><li>num-elements，占用 2 字节，记录 listpack elements 元素个数。</li><li>elements，listpack 元素，保存数据的部分。、</li><li>listpack-end-byte，结束标志，占用 1 字节，值固定为 255。</li></ul><p>element <strong>不再像 ziplist 的 entry 保存前一项的长度</strong>。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323135630954.png" alt="image-20230323135630954"></p><h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p><p>整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存int16_t、int32_t、int64_t的整数值，且保证集合中不出现重复元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct intset&#123;<br>    <span class="hljs-comment">//编码方式</span><br>    uint32_t encoding;<br>    <span class="hljs-comment">//集合包含的元素数量</span><br>    uint32_t length;<br>    <span class="hljs-comment">//保存元素的数组</span><br>    int8_t contents[];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="整数集合的升级"><a href="#整数集合的升级" class="headerlink" title="整数集合的升级"></a>整数集合的升级</h4><p>当我们向一个已经存在的整数集合中添加元素时，如果加入的元素的数据类型比contents[]数组元素的数据类型长，则整数集合需要进行升级，举个例子，我要在<strong>上面那个大小5的16位整数集合</strong>中插入一个类型为int32_t的整数65535：</p><ol><li>升级首先要做的是，根据新元素的长度，扩大空间，目前有5个元素，加入一个后有6个，且int16_t的元素要升级为int32_t类型（需要6 * 32 &#x3D; 192位的空间），因此需要先动态分配内存空间如下：</li></ol><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1754362-20210516161648249-356996541.png" alt="img"></p><ol><li>移动元素的位置，将14632往后移动到新的位置，末尾留下一个位置存放32位的65535</li></ol><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1754362-20210516161655382-2073870704.png" alt="img"></p><ol><li>同理移动233、18、-5、-6370，并最后将末尾的空间中存入65535</li></ol><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1754362-20210516161703961-1686295837.png" alt="img"></p><h4 id="整数集合不支持降级"><a href="#整数集合不支持降级" class="headerlink" title="整数集合不支持降级"></a>整数集合不支持降级</h4><p>如果因为插入一个32位的整数使得原本16位的contents[]数组转变为32位，后面又删去了这个32位的整数，这个整数集合将不会降级成16位的contents[]数组</p><h1 id="redis常用的基本类型"><a href="#redis常用的基本类型" class="headerlink" title="redis常用的基本类型"></a>redis常用的基本类型</h1><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>（1）<code>keys *</code> ：查看当前库中所有的key</p><p><a href="https://zlw00.github.io/2022/06/07/redis/image-20220607134236942.png"><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20220607134236942.png" alt="image-20220607134236942"></a></p><p>（2）<code>exists key</code> ：判断某个 key 是否存在</p><p>（3）<code>type key</code>：查看你的 key 是什么类型</p><p>（4）<code>del key</code> ：删除指定的 key 数据 &#x2F; unlink key 根据 value 选择非阻塞删除</p><p>（5）<code>expire key 10</code> ：10 秒钟：为给定的 key 设置过期时间</p><p>（6）<code>ttl key</code> ：查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</p><p>（7）<code>select</code> ：命令切换数据库</p><p>（8）<code>dbsize</code> ：查看当前数据库的 key 的数量</p><p>（9） <code>flushdb</code> ：清空当前库 &#x2F; <code>flushall</code> ：通杀全部库</p><h2 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h2><p>底层数据结构：<strong>动态字符串</strong>，是可以修改的字符串，内部结构上类似于java的ArrayList。</p><p><strong>常用命令</strong></p><p>（1）<code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对(内容能用字符串表示的)如果设置相同的key，则前面的value被覆盖</p><p>（2）<code>get &lt;key&gt;</code>：查询对应键值</p><p>（3）<code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 追加到原值的末尾</p><p>（4）<code>strlen &lt;key&gt;</code>：获得值的长度</p><p>（5）<code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 key 不存在时 设置 key 的值</p><p>（6）<code>incr &lt;key&gt;</code> ：将 key 中储存的数字值增 1 （只能对数字操作）</p><p>（7）<code>decr &lt;key&gt;</code> ：将 key 中储存的数字值减 1 （只能对数字操作）</p><p>（8） <code>incrby / decrby &lt;key&gt;&lt;步长&gt;</code>：将 key 中储存的数字值增减。自定义步长。</p><ul><li>是原子性的：<strong>所谓原子操作是指不会被线程调度机制打断的操作；</strong></li><li>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li><li>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li><li>Redis 单命令的原子性主要得益于 Redis 的单线程。</li></ul><p>（9）<code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code>同时设置一个或多个 key-value 对</p><p>（10）<code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....</code>同时获取一个或多个 value</p><p>（11）<code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code> ：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</p><p>（12）<code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>： 获得值的范围</p><p>（13）<code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code> ：用 覆写所储存的字符串值，从&lt;起始位置&gt;开始(索引从 0 开始)。</p><p>（14）<code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒</p><p>（15）<code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>当数据量比较少的时候，使用的是ziplist</strong>，因为普通的链表需要的附加指针空间太大，会比较浪费空间。</p><p><strong>当数据量比较大的时候，使用的是quickList</strong>（也就是将多个ziplist使用双指针串起来使用），既满足快速插入，又不会出现太大的冗余。</p><p><strong>单键多值 按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</strong> <strong>它的底层实际是个双向链表，</strong></p><p><strong>常用命令</strong></p><p>（1）<code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边&#x2F;右边插入一个或多个值。<br>（2）<code>lpop/rpop &lt;key&gt;</code>从左边&#x2F;右边吐出一个值。值在键在，值光键亡。<br>（3）<code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>从列表右边吐出一个值，插到列表左边。<br>（4）<code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>按照索引下标获得元素(从左到右)<br>（5）<code>lrange mylist 0 -1 0</code> 左边第一个，-1 右边第一个，（0-1 表示获取所有）<br>（6）<code>lindex &lt;key&gt;&lt;index&gt;</code>按照索引下标获得元素(从左到右)<br>（7）<code>llen &lt;key&gt;</code>获得列表长度<br>（8）<code>linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;</code>在的后面插入插入值<br>（9）<code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>从左边删除 n 个 value(从左到右)<br>（10）<code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>将列表 key 下标为 index 的值替换成 value</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 数据结构是 dict 字典，<strong>字典是用哈希表实现的</strong>。</p><p>特殊之处在于 <strong>set 是可以自动排重的</strong></p><p><strong>常用命令</strong></p><p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略<br><code>smembers &lt;key&gt;</code>取出该集合的所有值。<br><code>sismember &lt;key&gt;&lt;value&gt;</code>判断集合是否为含有该值，有 1，没有 0<br><code>scard&lt;key&gt;</code>返回该集合的元素个数。</p><p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code> 删除集合中的某个元素。<br><code>spop &lt;key&gt;</code>随机从该集合中吐出一个值。<br><code>srandmember &lt;key&gt;&lt;n&gt;</code>随机从该集合中取出 n 个值。不会从集合中删除 。<br><code>smove &lt;source&gt;&lt;destination&gt;value</code> 把集合中一个值从一个集合移动到另一个集合<br><code>sinter &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的交集元素。<br><code>sunion &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的并集元素。<br><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的差集元素(key1 中的，不包含 key2 中的)</p><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p><strong>zset 底层使用了两个数据结构</strong><br><strong>（1）hash</strong>，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。<br><strong>（2）跳跃表，</strong>跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230322124156151.png" alt="image-20230322124156151"></p><p>Redis 有序集合 zset 与普通集合 set 非常相似，是一个<strong>没有重复元素</strong>的字符串集合。<br>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复了 。</strong></p><p><strong>常用命令</strong></p><p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code> [WITHSCORES]返回有序集 key 中，下标在之间的元素带 WITHSCORES，可以让分数一起和值返回到结果集。<br><code>zrangebyscore key minmax [withscores] [limit offset count]</code>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br><code>zrevrangebyscore key maxmin [withscores] [limit offset count]</code>同上，改为从大到小排列。</p><p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code> 为元素的 score 加上增量<br><code>zrem &lt;key&gt;&lt;value&gt;</code>删除该集合下，指定值的元素<br><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>统计该集合，分数区间内的元素个数<br><code>zrank &lt;key&gt;&lt;value&gt;</code>返回该值在集合中的排名，从 0 开始。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash 类型对应的数据结构是两种： <strong>ziplist（压缩列表）， hashtable（哈希表）</strong>。 当field-value 长度较短且个数较少时， 使用 ziplist， 否则使用 hashtable。</p><p><strong>常用命令</strong></p><p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给集合中的 键赋值<br><code>hget &lt;key1&gt;&lt;field&gt;</code>：从集合取出 value<br><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code> ：批量设置 hash 的值<br><code>hexists&lt;key1&gt;&lt;field&gt;</code>：查看哈希表 key 中， 给定域 field 是否存在。<br><code>hkeys &lt;key&gt;</code>：列出该 hash 集合的所有 field<br><code>hvals &lt;key&gt;：</code>列出该 hash 集合的所有 value<br><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;：</code>为哈希表 key 中的域 field 的值加上增量 1 -1<br><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;：</code>将哈希表 key 中的域 field 的值设置为 value ， 当且仅当域field 不存在</p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是<strong>指当缓存中有大量的key在同一时刻过期，或者Redis直接宕机了</strong>，导致大量的查询请求全部到达数据库，造成数据库查询压力骤增，甚至直接挂掉。</p><p><strong>解决</strong>：只需要将每个key的过期时间打散即可，使它们的失效点尽可能均匀分布。</p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿是<strong>指当缓存中某个热点数据过期了</strong>，在该热点数据重新载入缓存之前，有大量的查询请求穿过缓存，直接查询数据库。<br><strong>解决：</strong>设置key永不过期</p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指<strong>查询一个缓存中和数据库中都不存在的数据</strong>，导致每次查询这条数据都会透过缓存，直接查库，最后返回空。</p><p><strong>解决：</strong>布隆过滤器</p><h1 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h1><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p><strong>AOF重写的执行流程：</strong></p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221007091501846.png" alt="image-20221007091501846"></p><ul><li>触发重写，执行bgrewriteaof命令</li><li>父进程fork子进程进行重写，fork子进程的同时，父进程阻塞，fork完毕父进程继续接受指令。</li><li>子进程在创建新的aof的同时，子进程根据内存快照，按照命令合并规则写入到新的AOF文件。父进程继续接受指令， 存储到<code>aof_buf</code>和<code>aof_rewirte_buf</code>缓存中，所以父进程继续往旧的aof文件中备份，同时也要往新的aof文件中备份。</li><li>新的aof备份完成</li><li>父进程备份新的文件创建完成</li><li>将<code>aof_rewrite_buf</code>缓存中的备份到新的aof文件中</li><li>新的文件替换旧的aof文件。</li></ul><h1 id="说一下redis和Memcached的区别和共同点"><a href="#说一下redis和Memcached的区别和共同点" class="headerlink" title="说一下redis和Memcached的区别和共同点"></a>说一下redis和Memcached的区别和共同点</h1><p><strong>共同点：</strong></p><ul><li>都基于内存数据库，一般都用来当作缓存使用</li><li>都有过期策略</li><li>两者的性能都非常高</li></ul><p><strong>区别：</strong></p><ul><li>redis支持更丰富的数据类型，（list，set，zset，hash）</li><li>redis支持持久化操作</li><li>redis有灾难恢复机制，因为有持久化功能</li><li>redis在服务器内存使用完之后，将不用的数据放到磁盘上，而Memcached在服务器中内存使用后，直接报异常</li><li>memcached是多线程，非阻塞IO复用模型，redis是单线程，多路IO复用模型</li><li>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li></ul><h1 id="redis如何使用事务"><a href="#redis如何使用事务" class="headerlink" title="redis如何使用事务"></a>redis如何使用事务</h1><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p><p><a href="https://redis.io/commands/multi"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<code>exec</code> 命令后，再执行所有的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br>&gt; GET PROJECT<br>QUEUED<br>&gt; EXEC<br>1) OK<br>2) <span class="hljs-string">&quot;JavaGuide&quot;</span><br></code></pre></td></tr></table></figure><p><code>DISCARD：</code>取消一个事务，它会清空事务队列中保存的所有命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br>&gt; GET PROJECT<br>QUEUED<br>&gt; DISCARD<br>OK<br></code></pre></td></tr></table></figure><p>你可以通过[<code>WATCH</code>命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端&#x2F;Session</strong> 修改的话，整个事务都不会被执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 客户端 1</span><br>&gt; SET PROJECT <span class="hljs-string">&quot;RustGuide&quot;</span><br>OK<br>&gt; WATCH PROJECT<br>OK<br>&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br><br><span class="hljs-comment"># 客户端 2</span><br><span class="hljs-comment"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span><br>&gt; SET PROJECT <span class="hljs-string">&quot;GoGuide&quot;</span><br><br><span class="hljs-comment"># 客户端 1</span><br><span class="hljs-comment"># 修改失败，因为 PROJECT 的值被客户端2修改了</span><br>&gt; EXEC<br>(nil)<br>&gt; GET PROJECT<br><span class="hljs-string">&quot;GoGuide&quot;</span><br></code></pre></td></tr></table></figure><h1 id="redis不支持原子性"><a href="#redis不支持原子性" class="headerlink" title="redis不支持原子性"></a>redis不支持原子性</h1><p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p><p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><h1 id="Redis单线程为什么这么快？"><a href="#Redis单线程为什么这么快？" class="headerlink" title="Redis单线程为什么这么快？"></a>Redis单线程为什么这么快？</h1><p>1.redis是基于内存的，内存的读写速度非常快；</p><p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p><p>3.采用IO多路复用机制</p><h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p><a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html#autoid-h2-5-0-0">https://www.cnblogs.com/crazymakercircle/p/10225159.html#autoid-h2-5-0-0</a></p><p><strong>IO多路复用的基本原理就是，单个线程不断的轮询select&#x2F;epoll系统调用所负责的成百上千的scoket连接，当某个或者某些连接有数据到达的时候，就返回这些可读写的连接，因此好处就是通过一次select&#x2F;epoll的系统调用，就可以读写一个甚至成百上千的连接。</strong></p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20190105163846560.jpg" alt="在这里插入图片描述"></p><p><strong>发起一个多路复用IO的的read读操作系统调用，流程是这个样子：</strong></p><p>（1）不断的进行select&#x2F;epoll系统调度，查询可以读的连接，只要有连接数据到达，就返回该连接（当用户线程调用select时，整个线程被block）</p><p>（2）建立连接后，发起read系统调用，将内核缓冲区的数据复制到用户缓冲区，然后返回结果。</p><p>（3）用户线程读取了数据。接触block。</p><p>IO多路复用，用到两个系统调用，一个是select&#x2F;epoll调用，另一个是IO读取调用。</p><p><strong>优点：</strong>使用select&#x2F;epoll就可以同属处理成千上万的连接，与一条线程维护一条连接相比，系统不必创建线程，不必维护线程，减少了系统的开销。</p><p><strong>缺点：</strong>读写过程是阻塞的。</p><h1 id="redis中基本数据类型的zset底层是什么"><a href="#redis中基本数据类型的zset底层是什么" class="headerlink" title="redis中基本数据类型的zset底层是什么"></a>redis中基本数据类型的zset底层是什么</h1><p>（1）hash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</p><p>（2）跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221028180718550.png" alt="image-20221028180718550"></p><h1 id="redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程"><a href="#redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程" class="headerlink" title="redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程"></a>redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程</h1><p><strong>单线程，可以设置为多线程，。</strong></p><p><strong>在redis6.0之后引入的多线程，。</strong></p><p><strong>为什么之前不使用多线程？</strong></p><p>（1）单线程编程容易并且更容易维护；</p><p>（2）多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</p><p><strong>如果需要开启多线程，则需要修改redis的配置文件：</strong></p><p><code>io-threads-do-reads yes</code></p><p><strong>redis的文件处理器通过IO多路复用来监听大量的客户端连接。</strong></p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221028183529128.png" alt="image-20221028183529128"></p><h1 id="为什么redis6-0之后使用多线程"><a href="#为什么redis6-0之后使用多线程" class="headerlink" title="为什么redis6.0之后使用多线程"></a>为什么redis6.0之后使用多线程</h1><p>因为对redis有更高的要求。</p><p>redis对于小数据包来说，对于80%的公司已经足够使用了。</p><p>但随着越来越复杂的业务场景，有些公司达到上亿的交易量，因此需要更大的查询效率。</p><p>为了提升查询效率，很多公司的做法是部署Redis集群，尽可能的提升redis机器数，但这种做法的资源消耗是巨大的。</p><p>经过分析限制redis的性能主要瓶颈出现在网络IO处理上，虽然采用了IO多路复用技术，但在处理网络请求时，调用select的过程时阻塞的，也就是这个过程会阻塞线程，如果并发量很高，就会成为瓶颈。</p><p><strong>如果能采用多线程，使得网路处理的请求并发进行，就可以大大提升性能。还可以充分利用CPU的多核优势</strong></p><p><strong>因此采用多个IO线程处理网络的请求，网络的请求和解析由其他线程完成，主线程进行内存的读写。</strong></p><p><strong>注意：只是网络的请求使用多IO线程，对于读写命令，redis仍然采用单线程来处理</strong></p><h1 id="redis怎么更新缓存"><a href="#redis怎么更新缓存" class="headerlink" title="redis怎么更新缓存"></a>redis怎么更新缓存</h1><p><strong>为什么要更新缓存？</strong></p><blockquote><p> 使用缓存后，数据要同时保存到数据库和缓存中，如果数据库中的数据发生变化，而缓存中的数据没有改变，会导致数据不一致的问题，因此要更新缓存。</p></blockquote><p><strong>常见的更新缓存的策略：</strong></p><p><strong>（1）内存淘汰：</strong></p><p>redis自带内存淘汰机制，当内存不足时自动淘汰部分数据。</p><p>redis提供了6种淘汰策略：</p><ul><li><strong>volatile-lru（least recently used）</strong>：从已经设置时间的数据集种挑选最近最少使用的数据进行淘汰。</li><li><strong>volatile-ttl：</strong>从已设置过期时间的数据集，中挑选将要过期的数据淘汰</li><li><strong>allkeys-lru：</strong>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key</li><li><strong>allkeys-random：</strong>从数据集中任意选择数据淘汰</li></ul><p>4.0版本后增加了以下两种：</p><ul><li><strong>volatile-lfu：</strong>从已设置过期时间的数据集，中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu（least frequently used）：</strong>当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ul><p><strong>（2）超时剔除</strong></p><p>手动给缓存的数据添加ttl，到期后自动删除。</p><p><strong>（3）主动更新</strong></p><p>编写业务逻辑，更新数据库数据后同步更新缓存</p><p><strong>三种实现方法：</strong></p><ul><li>由缓存的调用者，在更新数据库时同时更新缓存</li><li>将缓存与数据库整合为一个服务，由服务来维护一致性，调用者无需关心缓存一致性。</li><li>crud在缓存中进行，由其他线程异步的将缓存数据持久化到数据库，</li></ul><p><strong>这三种方法最好的就是：第一个（由缓存的调用者，在更新数据库时同时更新缓存）</strong></p><p><strong>总结以上缓存更新策略的最佳方案方法：</strong></p><p>（1）低一致性需求：使用redis自带的内存淘汰机制（就是数据不会长久发生变化的情况下，例如：查询店铺类型缓存）</p><p>（2）高一致性需求：主动更新，并以超时剔除作为兜底方案（查询店铺详情）</p><ul><li><p>读操作：</p><ul><li>缓存命中则直接返回</li><li>缓存未命中，则查询数据库，并写入缓存，设定超时时间</li></ul></li><li><p>写操作：</p><ul><li>先写数据库，然后再删除缓存</li><li>确保数据库与缓存操作的原子性</li></ul></li></ul><h1 id="redis单线程模型"><a href="#redis单线程模型" class="headerlink" title="redis单线程模型"></a>redis单线程模型</h1><h1 id="redis的过期策略"><a href="#redis的过期策略" class="headerlink" title="redis的过期策略"></a>redis的过期策略</h1><p><strong>redis 过期策略是：定期删除+惰性删除。</strong></p><p>所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p><p>假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 redis 是每隔 100ms 随机抽取一些key 来检查和删除的。</p><p>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p><p>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p><p>答案是：走内存淘汰机制。</p><h1 id="如何保证缓存与数据库的双写一致性？"><a href="#如何保证缓存与数据库的双写一致性？" class="headerlink" title="如何保证缓存与数据库的双写一致性？"></a>如何保证缓存与数据库的双写一致性？</h1><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。- 更新的时候，先更新数据库，然后再删除缓存。</p><p><strong>为什么是删除缓存，而不是更新缓存？</strong></p><p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存</p><p><strong>明确了是删除缓存后，目前存在两种选择:</strong></p><ul><li>先更新数据库，再删除缓存</li><li>先删除缓存，再更新数据库</li></ul><p><strong>（1）先更新数据库，再删除缓存</strong></p><p><strong>问题：</strong>更新数据库成功，线程出现问题，缓存删除失败，缓存中的是旧数据，数据不一致，有两种解决方式；<strong>失败重试</strong>和<strong>异步更新</strong></p><p><strong>失败重试：</strong>把删除的key放入到消息队中，从消息队列中进行删除，（有个缺点，首先会对业务代码造成入侵，其次引入了消息队列，增加了系统的不确定性。）</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20224285758787.png" alt="MySQL和Redis的数据一致性问题_一致性问题_04"></p><p><strong>异步更新：</strong>因为更新数据库时会往 <code>binlog </code>中写入日志，所以我们可以启动一个监听 binlog变化的服务（比如使用阿里的 canal开源组件），然后在客户端完成删除 key 的操作。如果删除失败的话，再发送到消息队列。</p><p><strong>（2）先删除缓存，再更新数据库</strong></p><p><strong>问题：</strong>如果先删除Redis缓存数据，然而还没有来得及写入MySQL，另一个线程就来读取。这个时候发现缓存为空，则去Mysql数据库中读取旧数据写入缓存，此时缓存中为脏数据。出现了数据不一致的问题。可以采用<strong>延时双删</strong>的策略解决。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20224285758788.png" alt="MySQL和Redis的数据一致性问题_缓存_05"> </p><p><strong>延时双删</strong>：就是更新数据库之后，再删除一次缓存。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20224285758789.png" alt="MySQL和Redis的数据一致性问题_缓存_06"></p><h1 id="redis-的并发竞争问题是什么？如何解决这个问题？了解redis-事务的-CAS-方案吗？"><a href="#redis-的并发竞争问题是什么？如何解决这个问题？了解redis-事务的-CAS-方案吗？" class="headerlink" title="redis 的并发竞争问题是什么？如何解决这个问题？了解redis 事务的 CAS 方案吗？"></a>redis 的并发竞争问题是什么？如何解决这个问题？了解redis 事务的 CAS 方案吗？</h1><h2 id="乐观锁介绍："><a href="#乐观锁介绍：" class="headerlink" title="乐观锁介绍："></a>乐观锁介绍：</h2><p>watch指令在redis事物中提供了CAS的行为。为了检测被watch的keys在是否有多个clients同时改变引起冲突，这些keys将会被监控。如果至少有一个被监控的key在执行exec命令前被修改，整个事物将会回滚，不执行任何动作，从而保证原子性操作，并且执行exec会得到null的回复。</p><h2 id="乐观锁工作机制："><a href="#乐观锁工作机制：" class="headerlink" title="乐观锁工作机制："></a>乐观锁工作机制：</h2><p>watch 命令会监视给定的每一个key，当exec时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。注意watch的key是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。当然exec，discard，unwatch命令，及客户端连接关闭都会清除连接中的所有监视。还有，如果watch一个不稳定(有生命周期)的key并且此key自然过期，exec仍然会执行事务队列的指令。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20210421172417360.png" alt="在这里插入图片描述"></p><h2 id="redis的Watch机制是什么？"><a href="#redis的Watch机制是什么？" class="headerlink" title="redis的Watch机制是什么？"></a>redis的Watch机制是什么？</h2><blockquote><p>Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。注意使用multi 开始事务，exec 提交事务。</p></blockquote><h1 id="缓存雪崩-1"><a href="#缓存雪崩-1" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p><strong>缓存雪崩是指缓存同一时间大面积的失效（由于对缓存数据设置了相同的过期时间），所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</strong></p><p>解决方案：</p><ol><li><p><strong>构建多级缓存架构：</strong>nginx缓存+redis缓存+其他缓存（ehcache等）</p></li><li><p><strong>使用锁或队列：</strong>使用锁或在队列的方式来保证不会有大量的线程对数据库进行读写，从而避免失效时大量的并发请求到底层存储系统上，不适用高并发情况</p></li><li><p><strong>将缓存失效时间分散开：</strong>设置缓存过期时间时加上一个随机值，避免缓存在同一时间过期</p></li><li><p><strong>限流</strong></p></li></ol><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/e3d4e1cbd03b5326eb8b3f15a7fc73bc.png" alt="redis-caching-avalanche-solution"></p><p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空值</p><p><strong>好处：</strong></p><ul><li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li><li>只要数据库不死，就是说，对用户来说，2&#x2F;5 的请求都是可以被处理的。</li><li>只要有 2&#x2F;5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来了。</li></ul><h1 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p><strong>缓存穿透是指查询一个根本不存在的数据，缓存层和持久层都不会命中，请求都会压到数据库，从而压垮数据库。</strong></p><p>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“<strong>绕过缓存</strong>”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/834fcb5588972d9be273189239bf0aba.png" alt="redis-caching-penetration"></p><p>解决方式很简单：</p><p><strong>每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去</strong>，比如 <code>set -999 UNKNOWN</code> 。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><p>这种方式虽然是简单，在某些场景（如数据量大的博客）下不优雅，还可能会缓存过多的空值，更加优雅的方式就是：<strong>使用 bitmap 布隆过滤（将数据库中所有的查询条件，放入布隆过滤器中，当一个查询请求过来时，先经过布隆过滤器进行查，如果判断请求查询值存在，则继续查；如果判断请求查询不存在，直接丢弃。）</strong></p><h1 id="缓存击穿-1"><a href="#缓存击穿-1" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p><strong>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力（有点像一把尖刀瞬间击穿到数据库）</strong></p><p><strong>不同场景下的解决方式可如下：</strong></p><ul><li>若缓存的数据是基本不会发生更新的，<strong>则可尝试将该热点数据设置为永不过期</strong>。</li><li>若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。</li><li><strong>预先设置热门数据</strong>：在redis高峰访问前，把一些热门数据提前存入redis中，加大这些热门数据key的时长实时调整 现场监控哪些数据是热门数据，实时调整key的过期时长</li></ul><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>是由一个很长的二进制(0或1)向量和一系列随机映射函数组成。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它可以告诉你某种东西<strong>一定不存在</strong>或者<strong>可能存在</strong>。当布隆过滤器说，某种东西存在时，这种东西可能不存在；当布隆过滤器说，某种东西不存在时，那么这种东西一定不存在。</p><p>布隆过滤器 优点：A. 空间效率高，占用空间少 B. 查询时间短</p><p>　　　　　　　 缺点：A. 有一定的误判率 B. 元素不能删除</p><p><strong>原理</strong> </p><p>　当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点（使用多个哈希函数对<strong>元素key (bloom中不存value)</strong> 进行哈希，算出一个整数索引值，然后对位数组长度进行取模运算得到一个位置，每个无偏哈希函数都会得到一个不同的位置），把它们置为1。</p><p>　检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：① 如果这些点有任何一个为0（如下图的e），则被检元素一定不在；如果都是1（如下图的d），并不能完全说明这个元素就一定存在其中，有可能这些位置为1是因为其他元素的存在，这就是布隆过滤器会出现误判的原因。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1031302-20201106204833000-564795432.png" alt="img"></p><p><strong>使用布隆过滤器的场景：</strong></p><p><strong>黑名单校验</strong></p><p>　识别垃圾邮件，只要发送者在黑名单中的，就识别为垃圾邮件。假设黑名单的数量是数以亿计的，存放起来就是非常耗费存储空间的，布隆过滤器则是一个较好的解决方案。把所有黑名单都放在布隆过滤器中，再收到邮件时，判断邮件地址是否在布隆过滤器中即可。</p><p><strong>原本有10亿个号码，现在又来了10万个号码，要快速准确判断这10万个号码是否在10亿个号码库中？</strong></p><p>解决办法一：将10亿个号码存入数据库中，进行数据库查询，准确性有了，但是速度会比较慢。</p><p>解决办法二：将10亿号码放入内存中，比如Redis缓存中，这里我们算一下占用内存大小：10亿*8字节&#x3D;8GB，通过内存查询，准确性和速度都有了，但是大约8gb的内存空间，挺浪费内存空间的。</p><p>那么对于类似这种，大数据量集合，如何准确快速的判断某个数据是否在大数据量集合中，并且不占用内存，<strong>布隆过滤器</strong>应运而生了。</p><h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p><a href="https://blog.csdn.net/qq_34412579/article/details/101731935">https://blog.csdn.net/qq_34412579/article/details/101731935</a></p><h2 id="什么是跳表"><a href="#什么是跳表" class="headerlink" title="什么是跳表"></a><strong>什么是跳表</strong></h2><p>​跳表是可以实现二分查找的有序单链表。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193316929.png" alt="image-20221126193316929"></p><h2 id="跳表查找的时间复杂度为O-logn"><a href="#跳表查找的时间复杂度为O-logn" class="headerlink" title="跳表查找的时间复杂度为O(logn)"></a><strong>跳表查找的时间复杂度为O(logn)</strong></h2><p>​时间复杂度 &#x3D; 索引的高度 * 每层索引遍历元素的个数。</p><p>​<strong>先来求跳表的索引高度。</strong>如下图所示，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n&#x2F;2 个元素、二级索引有 n&#x2F;4 个元素、k级索引就有 n&#x2F;2k个元素。最高级索引一般有2个元素，即：最高级索引 h 满足 2 &#x3D; n&#x2F;2h，即 h &#x3D; log2n - 1，最高级索引 h 为索引层的高度加上原始数据一层，跳表的总高度 h &#x3D; log2n。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193402245.png" alt="image-20221126193402245"></p><p>​图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。</p><p>跳表的索引高度 <code>h = log2n</code>，<strong>且每层索引最多遍历 3 个元素</strong>。所以跳表中查找一个元素的时间复杂度为 <code>O(3*logn)</code>，省略常数即：**O(logn)**。</p><h2 id="跳表的空间复杂度O-n"><a href="#跳表的空间复杂度O-n" class="headerlink" title="跳表的空间复杂度O(n)"></a>跳表的空间复杂度<strong>O(n)</strong></h2><p>跳表是典型的”空间换时间“的思想</p><p>假如原始链表包含 n 个元素，则一级索引元素个数为 <code>n/2</code>、二级索引元素个数为 <code>n/4</code>、三级索引元素个数为 <code>n/8</code> 以此类推。所以，索引节点的总和是：n<code>/2+n/4+n/8 … 8+4+2 = n-2</code>，**空间复杂度是 O(n)**。</p><h2 id="跳表的插入数据"><a href="#跳表的插入数据" class="headerlink" title="跳表的插入数据"></a>跳表的插入数据</h2><p> 通过<code>randomLevel()</code>方法返回当前元素要插入的层级</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193921939.png" alt="image-20221126193921939"></p><p>整个插入过程的路径与查找元素路径类似， 每层索引中插入元素的时间复杂度 <code>O(1)</code>，所以整个插入的时间复杂度是 **O(logn)**。</p><h2 id="跳表的删除数据"><a href="#跳表的删除数据" class="headerlink" title="跳表的删除数据"></a>跳表的删除数据</h2><p>​跳表删除数据时，要把索引中对应节点也要删掉。如下图所示，如果要删除元素 9，需要把原始链表中的 9 和第一级索引的 9 都删除掉。</p><p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193957439.png" alt="image-20221126193957439"></p><p>​删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 <code>x</code>，则执行删除操作。跳表中，每一层索引其实都是一个有序的单链表，单链表删除元素的时间复杂度为 <code>O(1)</code>，索引层数为 <code>logn</code> 表示最多需要删除 <code>logn</code> 个元素，所以删除元素的总时间包含 查找元素的时间 加 删除 logn个元素的时间 为 <code>O(logn)+O(logn) = 2 O(logn)</code>，忽略常数部分，**删除元素的时间复杂度为 O(logn)**。</p>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试题-集合</title>
    <link href="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/"/>
    <url>/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Collection接口下有哪些实现？"><a href="#Collection接口下有哪些实现？" class="headerlink" title="Collection接口下有哪些实现？"></a>Collection接口下有哪些实现？</h1><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/image-20221102111525959.png" alt="image-20221102111525959"></p><h1 id="为什么set是无序的，list是有序的"><a href="#为什么set是无序的，list是有序的" class="headerlink" title="为什么set是无序的，list是有序的"></a>为什么set是无序的，list是有序的</h1><p>这里的无序和有序，是根据添加到集合中元素的顺序，而不是对数据进行排序。</p><p>因为set在添加元素的时候，计算元素的hash值，进行存储。所以set集合中的元素不能有重复，也不能保证内部存储是按元素添加的顺序而存储的。</p><p>list是按照添加的顺序进行输出的，所以为有序。</p><h1 id="ArrayList-与-LinkedList-区别"><a href="#ArrayList-与-LinkedList-区别" class="headerlink" title="ArrayList 与 LinkedList 区别?"></a>ArrayList 与 LinkedList 区别?</h1><ul><li><p><strong>是否保证线程安全：</strong>都不是线程安全的</p></li><li><p><strong>底层数据结构：</strong><code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</p></li><li><p><strong>插入和删除是否受元素位置的影响：</strong></p><ul><li><code>ArrayList</code>：采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响，<code>add(E e)</code>方法，将指定的元素追加到此列表的末尾，时间复杂度就是 O(1)。要是在指定元素位置插入和删除时，时间复杂度为O(n-i)，因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li><li><code>LinkedList</code>：采用链表存储，如果是在头尾插入或者删除元素，时间复杂度为 O(1)。如果要在指定位置删除和插入时，时间复杂度都为O(n) ，因为需要先移动到指定位置再插入。</li></ul></li><li><p><strong>是否支持快速随机访问</strong>：<code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p></li><li><p><strong>内存空间占用：</strong><code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><p><strong>使用场景</strong></p><p>（1）如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象；、</p><p>（2）如果应用程序有更多的插入或者删除操作，较少的随机访问，LinkedList对象要优于ArrayList对象；</p><p>（3）不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快。</p><p><strong>总结：</strong></p><p><strong>我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code>LinkedList</code></strong></p><h1 id="HashSet和TreeSet"><a href="#HashSet和TreeSet" class="headerlink" title="HashSet和TreeSet"></a>HashSet和TreeSet</h1><p>（1）TreeSet的底层是使用TreeMap实现的。HashSet的底层是使用HashMap实现的。</p><p>（2）TreeSet判断两个对象不相等的方式是两个对象通过<a href="https://so.csdn.net/so/search?q=equals&spm=1001.2101.3001.7020">equals</a>方法返回false，或者通过CompareTo方法比较没有返回0.HashSet是使用hashCode判断的。</p><p>（3）TreeSet 是二叉树实现的，<strong>Treeset中的数据是自动排好序的，不允许放入null值</strong>。HashSet 是哈希表实现的,<strong>HashSet中的数据是无序的，可以放入null，但只能放入一个null</strong>，两者中的值都不能重复，就如数据库中唯一约束。</p><h1 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h1><p><strong>ArrayList扩容的核心方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>        <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>        <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span><br>        <span class="hljs-comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span><br>        <span class="hljs-comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span><br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br>    <span class="hljs-comment">//比较minCapacity和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>            Integer.MAX_VALUE :<br>            MAX_ARRAY_SIZE;<br>    &#125;<br></code></pre></td></tr></table></figure><p>ArrayList的底层是通过数组实现的，底层创建了长度为10的数组，当容量不够时，则扩容为原来的1.5倍。jdk1.7和1.8中的区别主要是在什么时候初始化，jdk1.7：new时就初始化长度为10的数组，1.8：当在add时才进行初始化，分配长度为10的数组。</p><p><strong>在jdk1.8的时候，先创建 一个长度为0的数组，当进行add操作的时候，才进行分配长度为10的数组.看下面的代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>   <span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal方法</span><br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//得到最小扩容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>              <span class="hljs-comment">// 获取默认的容量和传入参数的较大值,(默认的容量为10)</span><br>            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>        &#125;<br><br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断是否需要扩容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        modCount++;<br><br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-comment">//判断容量是否超出10,因为第一次初始化的时候elementData.length已经为10</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>            grow(minCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>上述三段代码描述了这样的事情:</strong></p><ul><li>首先,当我们进行add第一个元素的时候,elementData.length 为 0 （因为还是一个空的 list）,因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。进入该方法时,旧容量为0,右移一位扩容后,也为0,因此第一个if条件成立,所以新容量就为10,此时elementData.length(容量扩容成 10 了。</li></ul><ul><li>当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。旧容量为10,新容量为15,第一个if和第二个if都不成立,因此新容量为15.</li></ul><p><strong>其中<code>hugeCapacity()</code> 方法</strong>:如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><p><strong>System.arraycopy()<code>和</code>Arrays.copyOf()&#96;方法</strong></p><p><strong>联系：</strong></p><p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h1 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h1><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p><strong>定制排序的用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定制排序的用法</span><br>        Collections.sort(arrayList, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o2.compareTo(o1);<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p><strong>重写 compareTo 方法实现按年龄来排序,并且类中要实现Comparable<Person></Person></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * T重写compareTo方法实现按年龄来排序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.age &gt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.age &lt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="hashmap和hashtable的区别"><a href="#hashmap和hashtable的区别" class="headerlink" title="hashmap和hashtable的区别"></a>hashmap和hashtable的区别</h1><ul><li>hashmap不是线程安全的,hashtable是线程安全的</li><li>hashmao的效率比hashtable高</li><li>hashmap的初始容量为16,扩容为原来的2倍,hashtable初始容量为11,扩容为原来的2n+1</li><li>hashmap允许键值为空，但hashtable不允许</li><li>hashmap继承的是AbstratMap类，但hashtable继承的是Dictionary</li></ul><h1 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复?"></a>HashSet 如何检查重复?</h1><blockquote><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p></blockquote><p>在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns: true if this set did not already contain the specified element</span><br><span class="hljs-comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns : previous value, or null if none</span><br><span class="hljs-comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>也就是说，在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</strong></p><h1 id="hashmap底层实现"><a href="#hashmap底层实现" class="headerlink" title="hashmap底层实现"></a>hashmap底层实现</h1><p>hashmap线程不安全，效率高，可以存储null的key和value。</p><p><strong>HashMap的底层：</strong> 数组+链表 （jdk7及之前） 数组+链表+红黑树 （jdk 8）</p><p><strong>底层实现：</strong></p><p>​jdk 1.7:在实例化之后，底层创建了长度为16的一维数组Node[]。</p><p>​<strong>jdk1.8时，实例化时初始容量为0，当执行put操作时，才扩容到16的一维数组Entry[] table</strong></p><p>​<strong>对于hashmap的put操作：首先对key1计算hash值，此hash值表示在entry中的位置，如果此位置上的数据为空，则直接添加成功。</strong></p><p>​<strong>如果此位置上的数据不为空，说明该位置上存在一个链表，里面包含一个或多个数据，比较key1与他们的hash值</strong></p><p>​<strong>如果key1的hash值与该链表中所有元素的值都不相等，则直接添加成功</strong></p><p>​<strong>如果key1的hash值与链表中已经存在的某一个key2数据的hash值相等，则使用equals方法继续进行比较</strong></p><p>​<strong>如果key1.equas(key2)返回false，则添加成功</strong></p><p>​<strong>否则如果返回true，则将value2替换为value1</strong></p><p>在上述添加的过程中，会出现容量不够，扩容问题，</p><p><strong>扩容问题：</strong></p><p>​当超出临界值（<strong>初始容量×填充因子</strong>&#x3D;16×0.75&#x3D;12）时，进行扩容，扩容为原来的2倍，并将原有的数据复制过来。</p><p><strong>jdk8 相较于jdk7在底层实现方面的不同：</strong></p><ol><li><code>new HashMap()</code>:底层没有创建一个长度为16的数组</li><li>jdk 8底层的数组是：<code>Node[]</code>,而非<code>Entry[]</code></li><li>首次调用&#96;&#96;put()&#96;方法时，底层创建长度为16的数组</li><li>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。<br>4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）<br>4.2 <strong>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</strong></li></ol><h2 id="为什么jdk8从头插法改变为尾插法"><a href="#为什么jdk8从头插法改变为尾插法" class="headerlink" title="为什么jdk8从头插法改变为尾插法"></a>为什么jdk8从头插法改变为尾插法</h2><p>当HashMap达到扩容的条件时候，会把HashMap中的每个元素，重新进行运算Hash值，jdk7通过头插法打入到扩容后的数组中。</p><p><strong>解决了头插法在rehash时导致死循环的问题。</strong></p><p>扩容时transfer代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-type">boolean</span> rehash)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123;<br>            Entry&lt;K,V&gt; next = e.next;<span class="hljs-comment">//这里记做第一步</span><br>            <span class="hljs-keyword">if</span> (rehash) &#123;<br>                e.hash = <span class="hljs-literal">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity);<br>            e.next = newTable[i];<span class="hljs-comment">//这里记做第二步</span><br>            newTable[i] = e;<span class="hljs-comment">//这里记做第三步</span><br>            e = next;<span class="hljs-comment">//这里记做第四部</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下所示的hashmap, 有两个元素, 它们的key分别是1和3, 假设再增加一个元素时会触发扩容操作</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/image-20221125193320705.png" alt="image-20221125193320705"></p><p>假设线程1扩容时, 执行完transfer()中的<code>Entry&lt;K,V&gt; next = e.next;</code>被挂起, 此时e指向1, next指向3, 如下图所示</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/image-20221125193328814.png" alt="image-20221125193328814"></p><p>假设1和3在新的数组中仍然发生哈希碰撞, 假设线程2完成了扩容, 那么此时哈希表的样子如下图所示<br>可以发现, 由于使用了头插法, 所以3变成了头结点</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/image-20221125193346957.png" alt="image-20221125193346957"></p><p>回到线程1, e指向的是1, next指向的是3, 继续向下执行<br>当执行完<code>e.next = newTable[i];</code>便出现了循环链表, 其中,<code>newTable[i]</code>是3</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/image-20221125193404444.png" alt="image-20221125193404444"></p><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h2><ol><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)</li></ol><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/image-20221005200241560.png" alt="image-20221005200241560"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 判断table[i]中的元素是否与插入的key一样，若相同那就直接使用插入的值p替换掉旧的值e。</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>        <span class="hljs-comment">// 判断插入的是否是红黑树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">// 不是红黑树节点则说明为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br>                    <span class="hljs-comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br>                    <span class="hljs-comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>首先查找是否与数组的元素相等,如果相等则返回.</p></li><li><p>如果不相等,并且数组中的某个位置不止一个节点,则判断是否是树,如果是树,则调用方法在树中get.</p></li><li><p>如果不是树,则在链表中get.</p></li></ul><h2 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h2><p>进行的是扩容操作,会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><h1 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h1><ul><li><p><strong>迭代器EntrySet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建并赋值 HashMap</span><br>        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>        map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;JDK&quot;</span>);<br>        map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Spring Framework&quot;</span>);<br>        map.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;MyBatis framework&quot;</span>);<br>        map.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;Java中文社群&quot;</span>);<br>        <span class="hljs-comment">// 遍历</span><br>        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            Map.Entry&lt;Integer, String&gt; entry = iterator.next();<br>            System.out.println(entry.getKey());<br>            System.out.println(entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>迭代器KeySet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建并赋值 HashMap</span><br>        Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>        map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;JDK&quot;</span>);<br>        map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Spring Framework&quot;</span>);<br>        map.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;MyBatis framework&quot;</span>);<br>        map.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;Java中文社群&quot;</span>);<br>        <span class="hljs-comment">// 遍历</span><br>        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>            System.out.println(key);<br>            System.out.println(map.get(key));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>ForEach EntrySet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;<br>            System.out.println(entry.getKey());<br>            System.out.println(entry.getValue());<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>ForEach KeySet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Integer key : map.keySet()) &#123;<br>            System.out.println(key);<br>            System.out.println(map.get(key));<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Lambda</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历</span><br>        map.forEach((key, value) -&gt; &#123;<br>            System.out.println(key);<br>            System.out.println(value);<br>        &#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>Stream API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历</span><br>        map.entrySet().stream().forEach((entry) -&gt; &#123;<br>            System.out.println(entry.getKey());<br>            System.out.println(entry.getValue());<br>        &#125;);<br></code></pre></td></tr></table></figure></li></ul><p><strong>总结:</strong></p><p><strong><code>entrySet</code> 的性能比 <code>keySet</code> 的性能高出了一倍之多，因此我们应该尽量使用 <code>entrySet</code> 来实现 Map 集合的遍历</strong>。</p><h1 id="HashMap初始化时，构造方法传值为10000会发生扩容么"><a href="#HashMap初始化时，构造方法传值为10000会发生扩容么" class="headerlink" title="HashMap初始化时，构造方法传值为10000会发生扩容么"></a>HashMap初始化时，构造方法传值为10000会发生扩容么</h1><p><strong>向 HashMap 中存 10000 条数据，初始化时，构造方法传值 10000，会触发扩容吗?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure><p><strong>分析源码</strong></p><p>在 HashMap 中，提供了一个指定初始容量的<a href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">构造方法</a> HashMap(int initialCapacity)，这个方法再通过 DEFAULT_LOAD_FACTOR 调用 HashMap 另一个构造方法，初始化 loadFactor 为 0.75。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>  ......<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity); <span class="hljs-comment">//用来触发扩容的阈值的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​构造方法初始化了两个成员变量 <code>threshold</code> 和 <code>loadFactor</code>，<strong>其中 <code>threshold</code> 就是用来存储触发 <code>HashMap</code> 扩容的阈值，也就是说，当 <code>HashMap</code> 存储的数据量达到 <code>threshold</code> 时，就会触发扩容。</strong><br>  从改造方法中可以看出，<code>threshold</code> 并没有直接使用传入的 <code>initialCapacity</code> 作为扩容阈值，而是通过 <code>tableSizeFor</code> 方法处理后再赋值给 <code>threshold</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tableSizeFor</span><span class="hljs-params">(<span class="hljs-type">int</span> cap)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>tableSizeFor 的作用就是寻找大于 cap 的 2 的整数次方</strong>，例如如果传入 10，经过 tableSizeFor 处理后返回 16。</p><p>还有一个问题，一直在说 threshold 是触发扩容的阈值，即 (<code>initialCapacity * loadFactor</code>)，但是我们再构造方法中使用 <code>tableSizeFor</code> 初始化 <code>threshold</code>，并没有用到 <code>loadFactor</code>，其实这一步被移交给 <code>resize</code> 方法实现了，因为我们并没有在构造方法中初始化哈希表数组，<strong>扩容阈值 threshold &#x3D; initialCapacity * loadFactor，这一步在 resize 中完成。</strong></p><p><strong>因此此题的结果是：</strong></p><p>  <strong>如果我们从外部传递进来 10000 初始化 <code>initialCapacity</code> ，实际上经过 <code>tableSizeFor</code> 方法处理之后，最终 <code>threshold</code> 就会变成 2 的 14 次幂 16384，再在 <code>resize</code> 方法中乘上负载因子 0.75，实际在不触发扩容的前提下，可存储的数据容量是 <code>12288=(16384 * 0.75)</code>，用来存放 10000 条数据，绰绰有余，所以并不会触发扩容。</strong></p><h1 id="CurrentHashMap的实现原理"><a href="#CurrentHashMap的实现原理" class="headerlink" title="CurrentHashMap的实现原理"></a>CurrentHashMap的实现原理</h1><p>CurrentHashMap主要是由于HashMap并发下不安全所诞生的，不支持key和value为空值。</p><p>大量的使用了，volatile，final，CAS来减少锁竞争对于性能的影响。</p><p><strong>（1）在jdk1.7中的底层实现：</strong></p><p>ConcurrentHashMap采用了数组+Segment+分段锁的方式实现。而每一个 <code>Segment</code> 是一个类似于 <code>HashMap</code> 的结构，所以每一个 <code>HashMap</code> 的内部可以进行扩容。但是 <code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认 <code>Segment</code> 的个数是 16 个，你也可以认为 <code>ConcurrentHashMap</code> 默认支持最多 16 个线程并发。</p><p><strong>内部结构：</strong></p><p>分段锁技术：将数据分成一段一段的存储，然后给每一段数据分配一把锁，这样，当一个线程访问其中一段数据的时候，其他段的数据可以同时被其他线程访问，能够实现真正的并发访问，内部图为：</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/image-20220716222839369.png" alt="image-20220716222839369"></p><p>通过观察上图，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。（第一次定位到在哪个segment，第二次定位到元素在哪个链表。）</p><p><strong>优缺点：</strong></p><ul><li><p>缺点：hash操作的过程比普通hashmap要长</p></li><li><p>优点：对于写操作时只对所在元素的segment加锁，不影响其他segment。因此可以同时支持segment大小数量的写操作，大大的提高了并发能力</p></li></ul><p><strong>（2）在jdk1.8中的底层实现：</strong></p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构"></p><p>参考了jdk1.8中的hashMap的实现，采用了 数组+链表+红黑树的实现方式来设计。内部采用了大量的CAS操作。</p><p>介绍CAS：</p><blockquote><p>CAS是compare and swap的缩写，就是我们所说的比较和交换，cas是一种基于锁的操作，而且是乐观锁，在java中分为乐观锁和悲观锁，其中悲观锁是将资源锁住，等获得锁的线程释放锁之后，下一个线程才能访问，而乐观锁采取一种宽泛的态度，不加锁的方式进行处理，比如：给记录加version来获取数据，性能较悲观锁有很大的提升。</p><p>每次进行compareAndSwap方法时，需要cas有3个参数</p><p>内存地址<code>V</code>，<br>旧的预期值<code>E</code>，<br>要修改的新值<code>N</code></p><ul><li>当 <code>E == V</code> 时，修改 <code>V</code> 值为 <code>N</code>，返回true</li><li>当 <code>E != V</code> 时，修改失败，返回false</li></ul></blockquote><p>JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。</p><p>画图介绍CAS的操作：</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/image-20220716231720069.png" alt="image-20220716231720069"></p><p><strong>Node：保存key，value及key的hash值的数据结构。其中value和next都用volatile修饰，保证并发的可见性。</strong></p><blockquote><p>volatile：使用volatile修饰的变量，就具有可见性，直接修改内存，也就是，一个线程修改的结果，其他线程立刻就能看见，volatile只能让被他修饰内容具有可见性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; next;<br>    <span class="hljs-comment">//... 省略部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>查找性能为O（logN）</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/image-20220716224443050.png" alt="image-20220716224443050"></p><h2 id="源码分析-JDK1-8"><a href="#源码分析-JDK1-8" class="headerlink" title="源码分析(JDK1.8)"></a>源码分析(JDK1.8)</h2><ul><li><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initializes table, using the size recorded in sizeCtl.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 让出 CPU 使用权</span><br>            Thread.yield(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码中可以发现 <code>ConcurrentHashMap</code> 的初始化是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p><ol><li>-1 说明正在初始化</li><li>-N 说明有N-1个线程正在进行扩容</li><li>表示 table 初始化大小，如果 table 没有初始化</li><li>表示 table 容量，如果 table　已经初始化。</li></ol></li><li><p><strong>put:</strong></p><ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要执行树化方法，在 <code>treeifyBin</code> 中会首先判断当前数组长度≥64时才会将链表转换为红黑树</li></ol></li><li><p><strong>get:</strong></p><ol><li>根据 hash 值计算位置。</li><li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li><li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li><li>如果是链表，遍历查找之</li></ol></li></ul><h1 id="ConcurrentHashMap中的size方法"><a href="#ConcurrentHashMap中的size方法" class="headerlink" title="ConcurrentHashMap中的size方法"></a>ConcurrentHashMap中的size方法</h1><p><strong>在jdk7中</strong>有两种方案计算size，第一种方案他会使用不加锁的模式去尝试多次计算 ConcurrentHashMap 的 size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。 第二种方案是如果第一种方案不符合，他就会给每个 Segment 加上锁，然后计算 ConcurrentHashMap 的 size 返回。</p><p><strong>在jdk1.8中：</strong></p><p>最大值是 Integer 类型的最大值，但是 Map 的 size 可能超过 MAX_VALUE， 所以还有一个方法 <code>mappingCount()</code>，JDK 的建议使用 <code>mappingCount()</code> 而不是 <code>size()</code>。<code>mappingCount()</code> 的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mappingCount</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sumCount();<br>     <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : n; <span class="hljs-comment">// ignore transient negative values</span><br> &#125;<br></code></pre></td></tr></table></figure><p>无论是 <code>size()</code> 还是 <code>mappingCount()</code>, 计算大小的核心方法都是 <code>sumCount()</code></p><p>JDK1.8 ConCurrentHashMap的大小 <code>size</code> 通过<code>baseCount</code> 和<code>counterCells</code> 两个变量维护：</p><p>（1）在没有并发的情况下，使用一个<code>volatile</code>修饰的<code>baseCount</code> 变量即可；</p><p>（2）当有并发时，<code>CAS</code>修改 <code>baseCount</code> 失败后，会使用 <code>CounterCell</code> 类，即 创建一个<code>CounterCell</code>对象，设置其<code>volatile</code>修饰的<code>value</code> 属性为 1，并将其放在<code>ConterCells</code>数组的随机位置；</p><p>最终在<code>sumCount()</code>方法中通过累加 <code>baseCount</code>和<code>CounterCells</code>数组里每个<code>CounterCell</code>的值 得出<code>Map</code>的总大小<code>Size</code>。</p><h1 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h1><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong><ul><li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul></li></ul><h1 id="HashMap为什么线程不安全"><a href="#HashMap为什么线程不安全" class="headerlink" title="HashMap为什么线程不安全"></a>HashMap为什么线程不安全</h1><ul><li><p><strong>死循环</strong></p><p>因为扩容的时候采用的是头插法，头插法会将链表的顺序翻转。这就是引起死循环的原因。线程1和线程2同时进行扩容时。例如说线程1和线程2指向了3节点，线程1开始操作，使用头插法将节点7插入到了3节点的前面，也就是<code>3.next=7</code>。线程2为7.next&#x3D;3。造成了死循环。</p></li><li><p><strong>数据丢失</strong></p></li><li><p><strong>数据覆盖</strong></p><p>A、B两个线程put时，假设计算出的<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>值并对数组取余后是同一个位置，那么就会出现这种情况：A发现这个位置可以插入，但在插入前被挂起了，而B也发现可以插入，并且成功了，那么A继续执行后，由于刚刚已经判断过了是可以插入的，因此会直接把B的值给覆盖掉。</p></li></ul><h1 id="ArrayList为什么是线程不安全的"><a href="#ArrayList为什么是线程不安全的" class="headerlink" title="ArrayList为什么是线程不安全的"></a>ArrayList为什么是线程不安全的</h1><ul><li><p><strong>add元素之后，会出现有些位置的值为null的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e, Object[] elementData, <span class="hljs-type">int</span> s)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s == elementData.length)  <span class="hljs-comment">// 先不看</span><br>        elementData = grow();<br>    elementData[s] = e;<br>    size = s + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设有两个线程A和B都执行了add方法，并假设此时size为3，A添加完元素后(即执行完 <strong>elementData[s] &#x3D; e;</strong>)被挂起了，B也添加元素，注意，此时size还是3，这会导致两个问题：A写的被覆盖，size为5，但5的位置为null。</p></li><li><p><strong>数组下标越界</strong></p><p>还是假设A、B两个线程，并设此时数组长度为10，而s为9，那么A和B同时进到if判断都不会扩容，现在A在上面代码标注位置挂起了，而B接着执行添加操作，所以size &#x3D; 10，A继续执行，此时就出现了数组下标越界错误。</p></li><li><p><strong>size大小不是预期的值</strong></p><p>s+1不是原子操作，举个例子，假设现在s &#x3D; 4，A、B两个线程都去进行s + 1操作，在Java中每个线程是有自己的工作内存的，因此A和B各自都有一份s &#x3D; 4，然后分别执行s + 1，最后再写会主存。理想情况是A计算s + 1 &#x3D; 5之后写回主存，然后B再读取，将6写回主存。但事实却是A和B可能同时执行s + 1 &#x3D; 5然后写会主存，这就导致了size不是我们预期的结果。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试题-并发编程</title>
    <link href="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>系统进行资源分配和调度的基本单位</strong>，进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。进程是一个实体。<strong>每一个进程都有它自己的地址空间</strong>，，进程是一个“执行中的程序”。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程是进程的一个实体,是CPU调度和分派的基本单位</strong>,它是比进程更小的能独立运行的基本单位.<strong>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)</strong>,</p><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><p><strong>共同点</strong></p><p>都能提高程序的并发度，提高程序的运行效率和响应时间，使用上各自都有优缺点，线程的开销较小，但不利于资源的的管理和保护，而进程相反。</p><p><strong>不同点</strong></p><p>多进程中每个进程有自己的地址空间，线程则共享地址空间。以下的不同点，都是通过这个产生的</p><ul><li>进程是资源分配的最小单位，线程是CPU调度的最小单位</li><li>同一进程中的多个线程共享进程的同一资源</li><li>进程间是相互独立的，同一进程的线程间共享。</li></ul><h2 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h2><ul><li><strong>新建状态：</strong>构造方法，new一个新线程时，该线程是新建状态</li><li><strong>就绪状态：</strong>新建线程后，调用start方法启动线程，线程进入就绪状态，由于还没有分配CPU ，线程进入线程队列中。一旦获取到CPU则进入执行状态，调用自己的run方法。</li><li><strong>运行状态：</strong>执行run方法，直到调用其他方法或发生阻塞时停止。</li><li><strong>阻塞状态：</strong>某些特殊的情况下，线程可以被挂起，则线程进入阻塞状态，当执行 sleep()、suspend()、wait()方法时，线程进入阻塞状态。当引起阻塞状态的原因消失时，线程转为就绪状态，当再次分配CPU时，则从之前停止的地方继续执行。</li><li><strong>死亡状态：</strong>线程调用stop()、destory()或run()方法执行结束后，线程处于死亡状态，处于死亡状态的线程不再具有继续运行的能力。</li></ul><h2 id="线程的调度方法"><a href="#线程的调度方法" class="headerlink" title="线程的调度方法"></a>线程的调度方法</h2><p>（1）<strong>wait（）</strong>：当线程调用了这个方法时，线程被阻塞挂起，。直到调用了<code>notify</code>方法或<code>notifyAll</code>唤醒方法。</p><p>（2）<strong>notify（）：</strong>当调用<code>notify</code>方法后，会唤醒一个在这个锁资源上调用<code>wait</code>方法后被挂起的线程，</p><p>（3）<strong>notifyAll（）：</strong>notify（）是唤醒一个在等待的线程，而notifyAll（）方法则会唤醒所有在该锁资源上由于调用wait（）方法而被挂起的线程。<br>（4）<strong>sleep（）</strong>：当调用这个方法后，线程暂时让出指定时间的CPU执行权，但是锁还是持有的状态，当到了sleep的指定时间后，接着获取资源执行。</p><p>（5）<strong>interrupt（）</strong>：中断线程的方法，线程会时不时的检测这个中断标志位为true，以判断线程是否应该被中断。</p><p>（6）<strong>join（）</strong>：在当前线程执行另一个线程，当前线程会阻塞，等待插入的线程执行完毕之后，才会从阻塞状态变为就绪状态。（类似于插队）</p><p>（7）<strong>yield（）：</strong>可以让当前正在运行的线程暂停，不会让当前的线程阻塞，而是进入到就绪状态，让同优先级或者更高的优先级获取CPU。</p><h2 id="线程池的原理和创建"><a href="#线程池的原理和创建" class="headerlink" title="线程池的原理和创建"></a>线程池的原理和创建</h2><p><strong>线程池的好处：</strong></p><ul><li><strong>降低资源消耗：</strong>重复利用已经创建的线程，降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度：</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性：</strong>线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ul><p>线程是一种很宝贵的资源，创建和销毁线程需要付出很多代价，而使用线程池则避免了频繁的创建和销毁，因此我们有必要对线程池的原理进行了解。</p><p>线程池工作原理主要有三个方面<strong>：线程状态，线程池的重要属性和线程池的工作流程</strong>。</p><p><strong>线程池的状态：</strong></p><ul><li><strong>运行状态（running）：</strong>此状态下，线程可以接受新的任务，也可以处理阻塞队列中的任务，执行shutdown则进入待关闭状态，执行shutdownNow()方法可进入停止状态。</li><li><strong>待关闭状态（shutdown）：</strong>此状态下，线程池不再接受新的任务，继续处理阻塞队列中的任务，当阻塞队列中的任务执行完成后，进入整理状态。</li><li><strong>停止状态（stop）：</strong>此状态下，线程池不接受新的任务，也不处理阻塞队列中的任务，反而会尝试结束执行中的任务，当工作线程数为0时，进入整理状态。</li><li><strong>整理状态（tidying）：</strong>此状态下，所有的工作都执行完毕，且没有工作线程，执行terminated方法进入终止状态。</li><li><strong>终止状态（terminated）：</strong>此状态下，线程池完全终止，完成了所有资源的释放。</li></ul><p><strong>创建线程池：</strong></p><h2 id="线程池有几种"><a href="#线程池有几种" class="headerlink" title="线程池有几种"></a>线程池有几种</h2><p>六种：</p><p><strong>（1）FixedThreadPool：</strong>由于它的核心线程数和最大线程数是一样的，所以被称为<strong>固定线程数的线程池</strong>，就算是任务数超过了线程数，则线程池也不会再创建更多的线程来处理任务，而是把超出线程数的任务加入到任务队列中</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/modb_20211015_9ae0e750-2da4-11ec-9312-fa163eb4f6be.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.创建可固定长度的线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">newExecutorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">//创建了10个线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> i;<br>            newExecutorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;threadName;&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;,i&quot;</span>+temp);<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）CachedThreadPool</strong>：被称作为<strong>可缓存线程池</strong>，它的特点在于线程数可以无限增加，当提交一个任务，没有空闲线程，则新建线程去执行任务。并且对闲置的线程还可以进行线程的垃圾回收。当然它也有一个任务队列，（SynchronousQueue）队列的容量为0，不存储任何任务，只负责中转和传递，因此效率很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.创建可缓存的线程池，可重复利用</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">newExecutorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        <span class="hljs-comment">//创建了10个线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> i;<br>            newExecutorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;threadName;&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;,i&quot;</span>+temp);<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）ScheduledThreadPool</strong>：定期或周期性的执行任务，实现这种功能主要有三种方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);<br><br>service.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(), <span class="hljs-number">10</span>, TimeUnit.SECONDS);<span class="hljs-comment">//10秒后执行一次任务后就结束</span><br><br>service.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(), <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<span class="hljs-comment">//10秒后执行第一个任务，再距离10秒后执行下一个任务</span><br><br>service.scheduleWithFixedDelay(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(), <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<span class="hljs-comment">//10秒后执行第一个任务，任务结束后，间隔10秒执行下一个任务</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            <span class="hljs-comment">// 创建线程池</span><br>            <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br>            <span class="hljs-comment">// 添加定时执行任务(1s 后执行)</span><br>            System.out.println(<span class="hljs-string">&quot;添加任务,时间:&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            threadPool.schedule(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;任务被执行,时间:&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            &#125;, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）SingleThreadExecutor</strong>：使用唯一的线程去执行任务，和FixedThreadPool原理一样，只不过它只有一个线程，<strong>这种最适用于所有任务都需要按照被提交的顺序依次执行的场景，前面几种线程池，都不能保证执行的顺序，因为是多线程并发执行的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.创建单线程</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">newSingleThreadExecutor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i;<br>            newSingleThreadExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;index:&quot;</span> + index);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">200</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        newSingleThreadExecutor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）SingleThreadScheduledExecutor</strong>：与SchedulesTreadPool线程池非常相似，只不过它只有一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建线程池</span><br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newSingleThreadScheduledExecutor();<br>        <span class="hljs-comment">// 添加定时执行任务(2s 后执行)</span><br>        System.out.println(<span class="hljs-string">&quot;添加任务,时间:&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        threadPool.schedule(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;任务被执行,时间:&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（6）ForkJoinPool</strong>：JDK7新加入的线程池，主要用法和之前的线程池是相同的，也是把任务交给线程池去执行，线程池中也有任务队列来存放任务。但是 ForkJoinPool 线程池和之前的线程池有两点非常大的不同之处。（<strong>ForkJoinPool 非常适合用于递归的场景，例如树的遍历、最优路径搜索等场景。</strong>）</p><ul><li><p><strong>适合执行产生子任务的任务</strong>：有一个 Task，这个 Task 可以产生三个子任务，三个子任务并行执行完毕后将结果汇总给 Result，这样就可以利用 CPU 的多核优势，并行计算。</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/modb_20211015_9b43b204-2da4-11ec-9312-fa163eb4f6be.png" alt="img"></p></li><li><p><strong>第二点不同之处在于内部结构，</strong>之前的线程池所有的线程共用一个队列，但 ForkJoinPool 线程池中每个线程都有自己独立的任务队列。这时一旦线程中的任务被 Fork 分裂了，分裂出来的子任务放入线程自己的 deque 里，而不是放入公共的任务队列中。</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/modb_20211015_9c9f3718-2da4-11ec-9312-fa163eb4f6be.png" alt="img"></p></li></ul><h2 id="线程池参数，每个参数的意义是什么？"><a href="#线程池参数，每个参数的意义是什么？" class="headerlink" title="线程池参数，每个参数的意义是什么？"></a>线程池参数，每个参数的意义是什么？</h2><table><thead><tr><th align="left">参数名</th><th align="left">参数含义</th></tr></thead><tbody><tr><td align="left">corePoolSize</td><td align="left">核心线程数</td></tr><tr><td align="left">maxinumPoolSize</td><td align="left">最大线程数</td></tr><tr><td align="left">keepAliveTime</td><td align="left">空闲线程存活时间</td></tr><tr><td align="left">unit</td><td align="left">存活时间的单位</td></tr><tr><td align="left">workQueue</td><td align="left">存放线程任务队列</td></tr><tr><td align="left">threadFactory</td><td align="left">线程工厂，创建新线程</td></tr><tr><td align="left">handler</td><td align="left">线程池拒绝处理后的任务</td></tr></tbody></table><p>（1）corePoolSize：创建工作的线程数，这些线程创建后不会消失，是一种常驻线程。</p><p>（2）maxinumPoolSize：表示最大允许被创建的线程数，当核心线程全部用完时，还无法达到要求，此时会创建新的线程，但线程池内线程总数不会超过最大线程数。</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4d8d08f1c1e869149b27342e3bd3bf82.png" alt="img"></p><p>（3）keepAliveTime：超出核心线程之外的空闲线程存活时间，也就是核心线程不会消除，可以通过 <code>setKeepAliveTime</code> 来设置空闲时间</p><p>（4） workQueue：用来存放待执行的任务，如果核心线程全部用完后，，还有任务进来则加入到任务队列中，如果任务队列放满，还有任务队列加入，，则创建新的线程。</p><p>（5）threadFactory：用来生产临时线程执行任务。</p><p>（6）handler：任务拒绝策略，第一种：当线程池关闭时，再继续提交任务会遭到拒绝。第二种：达到最大的线程数时，没有能力继续处理新提交的任务，则拒绝。（RejectedExecutionHandler类型的变量）</p><p><strong>用户可以自行指定拒绝的策略，ThreadPoolExecutor提供了四种策略：</strong></p><ol><li><strong>ThreadPoolExecutor.AbortPolicy（默认的）：</strong>丢弃任务，抛出异常。</li><li><strong>ThreadPoolExecutor.DiscardPolicy：</strong>直接丢弃该任务，不抛出异常</li><li><strong>ThreadPoolExecutor.CallerRunsPolicy：</strong>使用调用者线程执行该任务</li><li><strong>ThreadPoolExecutor.DiscardOldestPolicy：</strong>丢弃任务队列中的最老的一个任务，然后提交该任务</li></ol><p><strong>整个流程如下：</strong></p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/0f82def62911d6f0f264300de96b6431.png" alt="img"></p><p><strong>阻塞队列</strong></p><ul><li><strong>有界队列：</strong>当阻塞队列中装满了等待执行的任务，这时再有新任务提交时，线程池就需要创建新的临时线程来处理，相当于增派人手来处理任务。</li><li><strong>无界队列：</strong>当核心线程都在忙时，所有新提交的任务都会被存放在该无界队列中，这时最大线程数将变得没有意义，因为阻塞队列不会存在被装满的情况。</li></ul><p><strong>获取任务并执行</strong></p><p>获取任务的过程则需要考虑当前工作线程的个数：</p><p>1.如果工作线程数大于核心线程数，那么就需要通过poll(keepAliveTime, timeUnit)来获取，因为这时需要对闲置线程进行超时回收。</p><p>2.如果工作线程数小于等于核心线程数，那么就可以通过take()来获取了。因为这时所有的线程都是核心线程，不需要进行回收，前提是没有设置allowCoreThreadTimeOut（允许核心线程超时回收）为true。#</p><h2 id="进程和线程之间的通信方式"><a href="#进程和线程之间的通信方式" class="headerlink" title="进程和线程之间的通信方式"></a>进程和线程之间的通信方式</h2><p>实际上只有进程间需要通信,同一进程的线程共享地址空间,没有通信的必要，但要做好同步&#x2F;互斥,保护共享的全局变量。而进程间通信无论是信号，管道pipe还是共享内存都是由操作系统保证的，是系统调用。</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul><li><p><strong>管道</strong></p><p>管道传输的数据是单向的，而且只能在父子进程关系中使用</p></li><li><p><strong>有名管道</strong></p><p>数据的传输也是单向的，但是它允许非父子进程之间的通信</p></li><li><p><strong>消息队列</strong></p><p>​A进程给B进程发送消息，A进程把数据放在对应的消息队列后就可以正常的返回，B进程需要的时候再进行读取数据。消息队列是保存在内存中的消息链表，在发送数据的时候，会分成一个独立的数据单元，即就是数据块</p><p>​<strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p></li><li><p><strong>共享内存</strong></p><p>​消息队列中的读取和写入的过程，都会有用户态和内核态之间的消息拷贝过程。共享内存的机制就是拿出一块虚拟化的地址空间来，映射到相同的物理内存中。这样这个进程写入东西，另外一个进程就可以看到了，大大提高了进程间通信的速度。</p></li><li><p><strong>信号量</strong></p><p>​如果用了共享内存的通信方式，会产生新的问题，就是多个线程同时修改同一个共享内存，<strong>为了防止多个进程访问资源造成数据错乱，需要共享资源在任意时刻只能被一个线程访问</strong>，因此信号量实现了这一保护机制。</p></li><li><p><strong>信号</strong></p><p>​用于通知接收进程某个事件已经发生</p><p>​任何时候给某一进程发送信息，一旦信号产生，就会有这几种的方式：</p><p>​1、执行默认的操作<br>​2、扑捉信号<br>​3、忽略信号</p></li><li><p><strong>套接字</strong></p><p>​管道、消息队列、共享内存、信号量和信号是在同一台主机上进行通信的，若想跨网络与不同的主机之间上的进程之间通信，需要用socket套接字啦</p></li></ul><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>​线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p><ul><li><p><strong>等待通知机制</strong></p><p>两个线程通过对同一对象调用等待 wait() 和通知 notify() 方法来进行通讯。</p><p><strong>wait：是指目前已经获得锁的线程，让出同步锁，让其他线程获取，也就是释放了锁。</strong></p><p><strong>notify：获取到锁的线程唤醒刚才调用wait的线程可以去参与竞争锁了，但当前的线程不会释放锁</strong></p></li><li><p><strong>join()方法</strong></p><p>在 join 线程完成后会调用 notifyAll() 方法，是在 JVM 实现中调用，所以这里看不出来。</p></li><li><p><strong>volatile共享内存</strong></p><p>多个线程同时<a href="https://so.csdn.net/so/search?q=%E7%9B%91%E5%90%AC&spm=1001.2101.3001.7020">监听</a>一个变量，当该变量发生变化的时候，线程能够感知并执行相应的业务。</p></li><li><p><strong>管道通信</strong></p></li><li><p><strong>并发工具</strong></p><ol><li>CountDownLatch 并发工具</li></ol><p> <a href="https://blog.csdn.net/ChineseSoftware/article/details/122997748">jdk1.5</a>之后在<a href="https://blog.csdn.net/ChineseSoftware/article/details/118390629">java.util.concurrent</a>包下提供了很多并发编程相关的工具类，简化了并发编程代码的书写，CountDownLatch 基于<a href="https://blog.csdn.net/ChineseSoftware/article/details/118356623">AQS</a>框架，相当于也是维护了一个线程间共享变量 state。</p><ol start="2"><li>CyclicBarrier 并发工具</li></ol></li><li><p><strong>基本 LockSupport 实现线程间的阻塞和唤醒</strong>：<code>LockSupport.park();``LockSupport.unpark(threadB);</code></p></li></ul><h2 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h2><ul><li><p><strong>原子性</strong></p><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p></li><li><p><strong>可见性</strong></p><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></li><li><p><strong>有序性</strong></p><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p></li></ul><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>​JVM在真正执行代码的时候，不一定按照代码从上到下的真正顺序去执行，一般来说，<strong>处理器为了提高程序运行效率，可能会对输入代码进行优化</strong>，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会<strong>保证程序最终执行结果和代码顺序执行的结果是一致的。</strong></p><h2 id="线程实现和创建方式"><a href="#线程实现和创建方式" class="headerlink" title="线程实现和创建方式"></a>线程实现和创建方式</h2><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>();<br>        <span class="hljs-type">MyThread2</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>();<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">my</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(my);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(my);<br>        t1.setName(<span class="hljs-string">&quot;窗口1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;窗口2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现Callable"><a href="#实现Callable" class="headerlink" title="实现Callable"></a>实现Callable</h3><p>（1）call()可以有返回值<br>（2）call()可以抛出异常，被外面捕获，获取异常信息<br>（3）Callable是支持泛型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadCallable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//3.创建实现Callable接口实现类的对象</span><br>        <span class="hljs-type">NumThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumThread</span>();<br>        <span class="hljs-comment">//4.将此实现Callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask对象</span><br>        <span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(thread);<br>        <span class="hljs-comment">//5.将FutureTask对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start方法。</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask).start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//6.如果要获取返回值时，获取call方法的返回值，否则，返回空，不使用下面代码</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;总和为:&quot;</span>+sum);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//1.创建一个实现Callable接口的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sum;<br>    <span class="hljs-comment">//2.实现call方法，将此线程需要执行的操作声明在call中</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<br>                System.out.println(i);<br>                sum = sum + i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于线程池的方式"><a href="#基于线程池的方式" class="headerlink" title="基于线程池的方式"></a>基于线程池的方式</h3><p>(1)提高响应速度(减少创建新线程的时间)<br>(2)降低资源的消耗(重复利用线程池中的线程,不需要每次都创建)<br>(3)便于线程管理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//提供指定线程数量的连接池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) executorService;<br>        <span class="hljs-comment">//设置属性</span><br>        <span class="hljs-comment">// 要在ThreadPoolExecutor类中设置，因为ExecutorService是接口，ThreadPoolExecutor是实现类。</span><br><span class="hljs-comment">//        service.setCorePoolSize(15);</span><br>        executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumThread2</span>());<span class="hljs-comment">//适用于实现Runnable</span><br><span class="hljs-comment">//        executorService.submit(Callable callable)//适用于实现Callable</span><br>        executorService.shutdown(); <span class="hljs-comment">//关闭连接池</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>建议创建线程池的方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span>  <span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maximumPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">keepAliveTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">TimeUnit</span> <span class="hljs-variable">unit</span> <span class="hljs-operator">=</span> TimeUnit.SECONDS;<br>        <span class="hljs-type">BlockingDeque</span> <span class="hljs-variable">workQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> Executors.defaultThreadFactory();<br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">policy</span> <span class="hljs-operator">=</span><br>                <span class="hljs-comment">// 当触发拒绝策略所满足条件时会抛出异常：java.util.concurrent.RejectedExecutionException</span><br>                <span class="hljs-comment">// new ThreadPoolExecutor.AbortPolicy();</span><br><br>                <span class="hljs-comment">// 当触发拒绝策略所满足条件时会将任务转回调用者（main线程）执行</span><br>                <span class="hljs-comment">// new ThreadPoolExecutor.CallerRunsPolicy();</span><br><br>                <span class="hljs-comment">// 当触发拒绝策略所满足条件时会放弃等待时间最长的那个任务</span><br>                <span class="hljs-comment">// new ThreadPoolExecutor.DiscardOldestPolicy();</span><br><br>                <span class="hljs-comment">// 当触发拒绝策略所满足条件时会静默丢弃新的任务</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy();<br>        <span class="hljs-comment">//创建线程池对象</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, policy);<br>        <span class="hljs-comment">//使用自己创建的线程池</span><br>        threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;正在工作&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Sleep和wait的区别"><a href="#Sleep和wait的区别" class="headerlink" title="Sleep和wait的区别"></a>Sleep和wait的区别</h2><ul><li>相同点：一旦执行方法，都可以使得当前线程进入阻塞状态。</li><li>不同点：<ul><li>声明位置不同：Thread类中声明<code>sleep()</code>,Object类中声明<code>wait()</code>。</li><li>调用的方法不同：<code>sleep()</code>可以在任何需要的场景下调用，而<code>wait()</code>必须在同步代码块或同步方法中调用。</li><li>关于释放同步监视器，：两个方法都使用在同步代码块或同步方法中，<code>sleep()</code>不会释放锁，<code>wait()</code>会释放锁</li><li><code>wait()通常用于线程交互/通信，</code>sleep()<code>通常用于暂停执行</code></li><li><code>wait()方法调用后，线程不会自动苏醒，需要别的线程调⽤同⼀个对象上的 </code>notify()<code>或者</code>notifyAll()<code> ⽅法。</code> sleep()<code>⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤</code>wait(longtimeout)&#96; 超时后线程会⾃动苏醒</li></ul></li></ul><h2 id="说⼀说⾃⼰对于-synchronized-关键字的了解"><a href="#说⼀说⾃⼰对于-synchronized-关键字的了解" class="headerlink" title="说⼀说⾃⼰对于 synchronized 关键字的了解"></a>说⼀说⾃⼰对于 synchronized 关键字的了解</h2><p>synchronized解决了多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>在Java的早期版本中，synchronized属于重量级锁，效率很低。因为监视器锁依赖底层操作系统的Mutex Lock实现，<strong>Java的线程映射到操作系统的原生线程上</strong>。<strong>所以挂起和唤醒一个线程都需要操作系统帮忙完成</strong>，时间成本很高。在Java6以后从JVM层面对synchronized有了较大的优化。</p><h2 id="synchronized-关键字的使用"><a href="#synchronized-关键字的使用" class="headerlink" title="synchronized 关键字的使用"></a>synchronized 关键字的使用</h2><p><strong>1.修饰实例⽅法</strong>: 作⽤于当前对象实例加锁，进⼊同步代码前要获得 当前对象实例的锁  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.修饰静态⽅法</strong>: 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得 当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。所以，如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象， 因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> staic <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p><strong>修饰代码块</strong> ：指定加锁对象，对给定对象&#x2F;类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。 synchronized(.class) 表示进⼊同步代码前要获得 当前 class 的锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>总结：</strong></p><ul><li>synchronized 关键字加到 static 静态⽅法和 synchronized(class) 代码块上都是是给 Class<br>类上锁。</li><li>synchronized 关键字加到实例⽅法上是给对象实例上锁。</li><li>尽量不要使⽤ synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能！</li></ul><h2 id="synchronized-关键字的底层原理"><a href="#synchronized-关键字的底层原理" class="headerlink" title="synchronized 关键字的底层原理"></a>synchronized 关键字的底层原理</h2><h3 id="sychronized修饰代码块时的底层原理"><a href="#sychronized修饰代码块时的底层原理" class="headerlink" title="sychronized修饰代码块时的底层原理"></a>sychronized修饰代码块时的底层原理</h3><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有</p><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/synchronized-get-lock-code-block.png" alt="执行 monitorenter 获取锁"></p><p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/synchronized-release-lock-block.png" alt="执行 monitorexit 释放锁"></p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h3 id="sychronized修饰方法时的底层原理"><a href="#sychronized修饰方法时的底层原理" class="headerlink" title="sychronized修饰方法时的底层原理"></a>sychronized修饰方法时的底层原理</h3><p><code>synchronized</code> 修饰的方法使用 <code>ACC_SYNCHRONIZED</code> 标识，表示该方法是同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h2 id="JDK1-6-之后的-synchronized-关键字底层做了哪些优化？"><a href="#JDK1-6-之后的-synchronized-关键字底层做了哪些优化？" class="headerlink" title="JDK1.6 之后的 synchronized 关键字底层做了哪些优化？"></a>JDK1.6 之后的 synchronized 关键字底层做了哪些优化？</h2><p>为了<strong>减少获得锁和释放锁带来的性能消耗</strong>而引入的<strong>偏向锁</strong>和<strong>轻量级锁</strong>，以及锁的存储结构和过程。</p><p>（1）偏向锁：偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，适合一个线程对一个锁的多次获取的情况</p><p>（2）轻量级锁：适合锁执行体比较简单(即减少锁粒度或时间), 自旋一会儿就可以成功获取锁的情况</p><h2 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h2><p>不同的线程占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，会产生死锁。</p><p><strong>死锁的四个必要条件：</strong></p><ul><li><strong>互斥条件：</strong>该资源任意时刻只由一个线程占用</li><li><strong>请求与保持条件：</strong>一个进程因请求资源而阻塞时，对已经获得的资源保持不放。</li><li><strong>不剥夺条件：</strong>已经获得的资源在没有使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件：</strong>若干个进程之间，形成一种头尾相接的循环等待资源。</li></ul><p><strong>如何避免死锁的发生：</strong>（破坏四个条件）</p><ul><li>破坏互斥条件：这个条件没法破坏，因为锁本身就是让资源互斥的。</li><li><strong>破坏请求与保持条件：</strong>一次性申请所有资源，这样它在整个运行过程中便不会再提出资源请求，从而破坏了“请求”条件。</li><li><strong>破坏不剥夺条件：</strong>线程进一步申请资源时，如果申请不到，可以主动释放它占有的资源</li><li><strong>破坏循环等待条件：</strong>按某一顺序申请资源 ，破坏循环等待条件，。（ 每个进程只能按递增顺序申请资源，因此每个时刻总有一个进程占据了较高序号的资源，那么它后面继续申请的资源一定是空闲的，这就保证了进程是可以一直向前推进的，）<ul><li>每个进程只能按递增顺序申请资源，即进程申请了序号为 8 的资源后，下次只能申请序号为 9 或以上资源</li><li>如果进程需要同一资源类型的多个实例（也就是序号相同的资源），则必须对它们一起进行申请</li><li>如果进程后面又想申请序号低的资源（比如5），那就必须把现在拥有的序号为5及其以上的资源全部释放</li></ul></li></ul><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103130304845.png" alt="image-20221103130304845"></p><h2 id="产生死锁的代码"><a href="#产生死锁的代码" class="headerlink" title="产生死锁的代码"></a>产生死锁的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Thread.sleep;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (s1)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        sleep(<span class="hljs-number">100</span>);<br>                    &#125;<span class="hljs-keyword">catch</span> (InterruptedException e)&#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">synchronized</span> (s2)&#123;<br>                        System.out.println(s1);<br>                        System.out.println(s2);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (s2)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">synchronized</span> (s1)&#123;<br>                        System.out.println(s1);<br>                        System.out.println(s2);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="synchoronized和Reentrantlock的区别"><a href="#synchoronized和Reentrantlock的区别" class="headerlink" title="synchoronized和Reentrantlock的区别"></a>synchoronized和Reentrantlock的区别</h1><p><strong>两者都是可重入锁</strong></p><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><p>（1）synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p><p>（2）ReentrantLock 比 synchronized 增加了一些高级功能</p><ul><li><strong>等待可中断</strong> :也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> :<code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li></ul><h1 id="synchoronized和volatile的区别"><a href="#synchoronized和volatile的区别" class="headerlink" title="synchoronized和volatile的区别"></a>synchoronized和volatile的区别</h1><p>（1）、volatile只能作用于变量，使用范围较小。synchronized可以用在变量、方法、类、同步代码块等，使用范围比较广。<br>（2）、volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以包证。<br>（3）、volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。<br>（4）、在性能方面synchronized关键字是防止多个线程同时执行一段代码，就会影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p><strong>AQS是抽象队列同步器，通过维护一个共享资源的状态，和一个先进先出的线程等待队列来实现一个多线程访问共享资源的框架。</strong></p><p> <strong>AQS只是一个框架 ，只定义了一个接口，具体资源的获取、释放都 由自定义同步器去实现。不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需实现共享资源state的获取与释放方式即可</strong></p><h2 id="AQS的原理："><a href="#AQS的原理：" class="headerlink" title="AQS的原理："></a><strong>AQS的原理：</strong></h2><p>AQS为每个共享资源都设置一个共享资源的锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度，</p><p><strong>state：状态</strong></p><p>​Abstract Queued Synchronizer 维护了 volatile int 类型的变量，用于表示当前的同步状态。volatile虽然不能保证操作的原子性，但是能保证当前变量state的可见性。<br>​        state的访问方式有三种： getState()、setState()和 compareAndSetState()，均是原子操作，其中，compareAndSetState的实现依赖于 Unsafe的compareAndSwaplnt() 具体的。JDK 码实现如下：</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230324121627389.png" alt="image-20230324121627389"></p><h2 id="AQS共享资源的方式：独占式和共享式"><a href="#AQS共享资源的方式：独占式和共享式" class="headerlink" title="AQS共享资源的方式：独占式和共享式"></a><strong>AQS共享资源的方式：独占式和共享式</strong></h2><ul><li>独占式：只有一个线程能执行，具体的 Java 实现有 ReentrantLock。</li><li>共享式：多个线程可同时执行，具体的 Java 实现有 Semaphore和CountDownLatch</li></ul><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230324121821849.png" alt="image-20230324121821849"></p><p> <strong>ReentrantLock对AQS的独占方式实现为：</strong>ReentrantLock中的state初始值为0表示无锁状态。在线程执行 tryAcquire()获取该锁后ReentrantLock中的state+1，这时该线程独占ReentrantLock锁，其他线程在通过tryAcquire() 获取锁时均会失败，直到该线程释放锁后state再次为0，其他线程才有机会获取该锁。该线程在释放锁之前可以重复获取此锁，每获取一次便会执行一次state+1, 因此ReentrantLock也属于可重入锁。 但获取多少次锁就要释放多少次锁，这样才能保证state最终为0。如果获取锁的次数多于释放锁的次数，则会出现该线程一直持有该锁的情况；如果获取锁的次数少于释放锁的次数，则运行中的程序会报锁异常。</p><p> <strong>CountDownLatch对AQS的共享方式实现为：</strong>CountDownLatch 将任务分为N个子线程去执行，将 state 初始化为 N, N与线程的个数一致，N个子线程是井行执行的，每个子线程都在执行完成后 countDown()1次， state 执行 CAS 操作并减1。在所有子线程都执行完成( state&#x3D;O)时会unpark()主线程，然后主线程会从 await()返回，继续执行后续的动作。</p><h1 id="CountDownLatck"><a href="#CountDownLatck" class="headerlink" title="CountDownLatck"></a>CountDownLatck</h1><blockquote><p><strong>CountDownLatch的作用很简单，就是一个或者一组线程在开始执行操作之前，必须要等到其他线程执行完才可以。</strong>我们举一个例子来说明，在考试的时候，老师必须要等到所有人交了试卷才可以走。此时老师就相当于等待线程，而学生就好比是执行的线程。</p><p>注意：java中还有一个同步工具类叫做CyclicBarrier，他的作用和CountDownLatch类似。同样是等待其他线程都完成了，才可以进行下一步操作，我们再举一个例子，在打王者的时候，在开局前所有人都必须要加载到100%才可以进入。否则所有玩家都相互等待。</p><p>我们看一下区别：</p><p>CountDownLatch: 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。 CyclicBarrier : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。关键点其实就在于那N个线程（1）CountDownLatch里面N个线程就是学生，学生做完了试卷就可以走了，不用等待其他的学生是否完成（2）CyclicBarrier 里面N个线程就是所有的游戏玩家，一个游戏玩家加载到100%还不可以，必须要等到其他的游戏玩家都加载到100%才可以开局</p></blockquote><p><strong>CountDownLatch主要使用countDown方法进行减1操作，使用await方法进行等到操作。</strong></p><h2 id="countDown原理"><a href="#countDown原理" class="headerlink" title="countDown原理"></a><strong>countDown原理</strong></h2><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230324122229084.png" alt="image-20230324122229084"></p><p>CountDownLatch里面保存了一个count值，通过减1操作，直到为0时候，等待线程才可以执行。而且通过源码也可以看到这个countDown方法其实是通过sync调用releaseShared(1)来完成的。<br><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230324122345007.png" alt="image-20230324122345007"></p><p>在这里我们发现继承了AbstractQueuedSynchronizer（AQS）。AQS的其中一个作用就是维护线程状态和获取释放锁。在这里也就是说CountDownLatch使用AQS机制维护锁状态。而releaseShared(1)方法就是释放了一个共享锁。</p><h2 id="await原理"><a href="#await原理" class="headerlink" title="await原理"></a><strong>await原理</strong></h2><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230324122422278.png" alt="image-20230324122422278"></p><p>await()底层主要是<code>acquireSharedInterruptibly</code>方法实现的，继续跟进去看看。</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230324122518351.png" alt="image-20230324122518351"></p><h1 id="虚拟内存、驻留内存、共享内存"><a href="#虚拟内存、驻留内存、共享内存" class="headerlink" title="虚拟内存、驻留内存、共享内存"></a>虚拟内存、驻留内存、共享内存</h1><ul><li><p><strong>虚拟内存：</strong></p><p>程序运行的过程中使用的内存都是虚拟的内存。每个进程都会在内存中有自己独立的page table用来，将虚拟内存地址映射到物理内存地址。</p></li><li><p><strong>共享内存</strong></p><p>多个进程可能会使用的共同内容，因此不同进程的page table中映射到相同的物理地址，这些公用的物理地址为共享内存。</p></li><li><p><strong>驻留内存</strong></p><p>虚拟内存中并不是全部映射到物理内存地址，已映射到物理内存的大小为驻留内存。</p></li></ul><p>因此描述一个进程占用资源情况建议使用 <em><strong>驻留内存 - 共享内存</strong></em></p><h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><p><strong>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</strong></p><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ul><h2 id="保证了程序的可见性的底层原理"><a href="#保证了程序的可见性的底层原理" class="headerlink" title="保证了程序的可见性的底层原理"></a>保证了程序的可见性的底层原理</h2><p>Volatile是通过<strong>MESI缓存一致性</strong>协议来保证<strong>可见性</strong>的</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/49fb7f81968f424badb3cc6f02fe8b2a.png" alt="在这里插入图片描述"></p><p>volatile关键字会<strong>开启总线</strong>得<strong>mesi缓存一致性协议</strong>。</p><blockquote><p>**mesi缓存一致性协议:**当多个CPU从主内存读取同一个数据到各自的高速缓存，当其中的某个CPU修改缓存中的数据时，该数据会马上同步回主内存，其他CPU通过总线嗅探机制可以感知数据的变化从而将自己缓存里的数据失效。</p></blockquote><p><strong>MESI协议如何保证可见性？</strong><br>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用MESI协议保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？就是为了触发cpu的嗅探机制，及时失效其他线程变量副本。</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/942d074cd8ca4898a049d58a83803e35.png" alt="在这里插入图片描述"></p><p>1.线程2修改值，以后会经过总线，然后写回主内存。<br>2.volatile开启总线mesi缓存一致性协议，每个cpu 都会监听总线<br>3.当知道其他cpu修改了变量值，立刻会失效自己工作内存中得值。<br>4.重新去主内存取值。</p><p>但是第四步，重新去主内存取值，<strong>怎么保障读取是最新得值呢</strong>（因为在store时可能已经经过总线，但此时还有write进主线程，总线却出发了嗅探机制，其他线程的变量已经失效，当其他线程去读取主内存的数据时，新数据还未write进来，产生脏数据！）。</p><p><strong>加锁：</strong></p><p>在store之前加锁（lock），锁住主内存的值，这时其他线程不能获取到主内存的值，等主内存的值更新之后锁就释放，等锁释放后线程获取的值才是最新的值。</p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/0cedfcf5182f4652be5aeb1651dc3d67.png" alt="在这里插入图片描述"></p><h2 id="禁止指令重排，保证程序的有序性底层原理"><a href="#禁止指令重排，保证程序的有序性底层原理" class="headerlink" title="禁止指令重排，保证程序的有序性底层原理"></a>禁止指令重排，保证程序的有序性底层原理</h2><p>volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p><p>​1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执</p><p>通过对Volatile修饰的变量<strong>增加内存屏障来完成</strong>的！</p><ul><li><strong>写屏障【给Volatile变量赋值】</strong>：确保指令重排序时，不会将写屏障之前的代码排在写屏障之后。</li><li><strong>读屏障【读取Volatile变量的值】</strong>：不会将读屏障之后的代码排在读屏障之前</li></ul><h2 id="不保证程序的原子性"><a href="#不保证程序的原子性" class="headerlink" title="不保证程序的原子性"></a>不保证程序的原子性</h2><p>volatile只有在写操作时，才保证了原子性，因为数据操作完成后，会立即刷新主内存，但是volatile修饰的变量，可能被多个线程读取。</p><p>A线程读 i &#x3D; 1同时B线程也读了i &#x3D; 1，然后自增完成刷新入主内存。i的值是2。</p><p>所以如果该变量是volatile修饰的，那可以完全保证此时取到的是最新信息。但在入栈和自增计算执行过程中，该变量有可能正在被其他线程修改，最后计算出来的结果照样存在问题，</p><h1 id="ThreadLocal是干嘛的？实现原理"><a href="#ThreadLocal是干嘛的？实现原理" class="headerlink" title="ThreadLocal是干嘛的？实现原理"></a>ThreadLocal是干嘛的？实现原理</h1><p><strong>ThreadLocal 表示线程的“本地变量”，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的，这样就可以避免共享资源的竞争</strong>。</p><p>事实上，这就是一种“<strong>空间换时间</strong>”的方案，每个线程都拥有自己的“共享资源”无疑会让内存占用大很多，但是由于不需要同步也就减少了线程可能存在的阻塞等待，从而提高时间效率。</p><h2 id="ThreadLocal的set方法"><a href="#ThreadLocal的set方法" class="headerlink" title="ThreadLocal的set方法"></a>ThreadLocal的set方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>  <span class="hljs-comment">//1. 获取当前线程实例对象</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><br>  <span class="hljs-comment">//2. 通过当前线程实例获取到ThreadLocalMap对象</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//3. 如果Map不为null,则以当前ThreadLocal实例为key,值为value进行存入</span><br>    map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br><span class="hljs-comment">//4.map为null,则新建ThreadLocalMap并存入value</span><br>      createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>是通过<code>getMap</code>来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.ThreadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>ThreadLocals</code>为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">ThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>的引用是作为<code>Thread</code>的一个成员变量的。根据上面的代码，当map为null的时候使用createMap方法new一个<code>ThreadLocalMap</code>实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.ThreadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>set()</code>总结：</strong></p><p><strong>通过当前线程获取所维护的ThreadLocalMap，如果ThreadLocalMap不为空，则以ThreadLocal实例为key，值为value的键值对存入ThreadLocalMap，若ThreadLocalMap为空，就新创建一个ThreadLocalMap，然后以ThreadLocal为键，value为值</strong></p><h2 id="Thread的get方法"><a href="#Thread的get方法" class="headerlink" title="Thread的get方法"></a>Thread的get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程的实例对象</span><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><br><span class="hljs-comment">//2. 获取当前线程的ThreadLocalMap</span><br>  <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>  <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//3. 获取map中当前ThreadLocal实例为key的值的entry</span><br>    ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-comment">//4. 当前entitiy不为null的话，就返回相应的值value</span><br>      <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">//5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value</span><br>  <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过当前线程 thread 实例获取到它所维护的 ThreadLocalMap，然后以当前 ThreadLocal 实例为 key 获取该 map 中的键值对（Entry），如果 Entry 不为 null 则返回 Entry 的 value。如果获取 ThreadLocalMap 为 null 或者 Entry 为 null 的话，就以当前 ThreadLocal 为 Key，value 为 null 存入 map 后，并返回 null。</strong></p><h2 id="Thread的remove方法"><a href="#Thread的remove方法" class="headerlink" title="Thread的remove方法"></a>Thread的remove方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//1. 获取当前线程的ThreadLocalMap</span><br><span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getMap(Thread.currentThread());<br> <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//2. 从map中删除以当前ThreadLocal实例为key的键值对</span><br>m.remove(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>先获取与当前线程相关联的 ThreadLocalMap，然后从 map 中删除该 ThreadLocal 实例为 key 的键值对即可</strong></p><h2 id="ThreadLocalMap详解"><a href="#ThreadLocalMap详解" class="headerlink" title="ThreadLocalMap详解"></a>ThreadLocalMap详解</h2><p>从<code>ThreadLocal</code>中的<code>set</code>、<code>get</code>和<code>remove</code>方法中可以知道，数据其实都放在了 <code>ThreadLocalMap</code> 中，<code>ThreadLocal</code> 的 <code>get</code>、<code>set</code> 和 <code>remove</code> 方法实际上都是通过 <code>ThreadLocalMap</code> 的 <code>getEntry</code>、<code>set</code> 和 <code>remove</code> 方法实现的。如果想真正全方位的弄懂 <code>ThreadLocal</code>，势必得再对 <code>ThreadLocalMap</code> 做一番理解。</p><h2 id="ThreadLocalMap中的Entry数据结构"><a href="#ThreadLocalMap中的Entry数据结构" class="headerlink" title="ThreadLocalMap中的Entry数据结构"></a>ThreadLocalMap中的Entry数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry[] table;  <span class="hljs-comment">//长度为2的幂次方</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;  <span class="hljs-comment">//继承了WeakReference（弱引用）</span><br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<span class="hljs-comment">//将k也就是key包装成了弱引用</span><br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>弱引用</strong>：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li></ul><p><strong>Entry 是一个以 ThreadLocal 为 key，Object 为 value 的键值对，另外需要注意的是这里的ThreadLocal 是弱引用，因为 Entry 继承了 WeakReference，在 Entry 的构造方法中，调用了 super(k)方法，会将 ThreadLocal 实例包装成一个 WeakReferenece。</strong></p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>可以用一个图来理解下 Thread、ThreadLocal、ThreadLocalMap、Entry 之间的关系：</strong></p><p><img src="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/970541b7c5bc4a899eb4a0a421f23e6f.JPG" alt="在这里插入图片描述"></p><p>​上图中虚线是弱引用，实线是强引用，如果ThreadLocal中的外部强引用变为null，。则当GC操作的时候ThreadLocal就会被回收，则key为null。这样一来，ThreadLocalMap中就会出现key为null的Entry，没办法访问这些key为null的value。如果当前线程不结束的话，一直回存在一条强的引用连，无法回收，造成内存泄漏。</p><h2 id="怎么解决内存泄漏"><a href="#怎么解决内存泄漏" class="headerlink" title="怎么解决内存泄漏"></a>怎么解决内存泄漏</h2><p>（1）每次使用完<code>ThreadLocal</code>后，调用<code>remove()</code>方法进行清除数据</p><p>（2）将<code>ThreadLocal</code>变量定义为<code>private static</code>，这样就一直存在<code>ThreadLocal</code>的强引用了，也能保证任何时候都能通过<code>ThreadLocal</code>的弱引用访问到<code>Entry</code>的<code>value</code>值，进而清除掉。</p><h2 id="ThreadLocalMap中的set方法"><a href="#ThreadLocalMap中的set方法" class="headerlink" title="ThreadLocalMap中的set方法"></a>ThreadLocalMap中的set方法</h2><p>与 ConcurrentHashMap、HashMap 等容器一样，ThreadLocalMap 也是采用散列表进行实现的。</p><p>只不过ThreadLocalMap是使用开放地址法来解决哈希冲突的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br><br>    <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>    <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>    <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>    <span class="hljs-comment">// path would fail more often than not.</span><br><br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><span class="hljs-comment">//根据ThreadLocal的hashCode确定Entry应该存放的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.ThreadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);  <span class="hljs-comment">//private final int ThreadLocalHashCode = nextHashCode();</span><br><br><span class="hljs-comment">//采用开放地址法，hash冲突的时候使用线性探测</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><span class="hljs-comment">//覆盖旧Entry</span><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">//当key为null时，说明ThreadLocal强引用已经被释放掉，那么就无法</span><br><span class="hljs-comment">//再通过这个key获取ThreadLocalMap中对应的entry，这里就存在内存泄漏的可能性</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//用当前插入的值替换掉这个key为null的“脏”entry</span><br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//新建entry并插入table中i处</span><br>    tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br><span class="hljs-comment">//插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容</span><br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>  &#125;<br></code></pre></td></tr></table></figure><p> <code>nextHashCode()</code> ：该方法实际上是用一个 <code>AtomicInteger</code> 加上 <code>0x61c88647</code> 来实现的。</p><p><code>0x61c88647</code> 这个数是有特殊意义的，它能够保证 hash 表的每个散列桶能够均匀的分布，这是<code>Fibonacci Hashing</code></p><p><strong>怎样确定新值插入到哈希表中的位置？</strong></p><p><code>key.ThreadLocalHashCode &amp; (len-1)</code>：利用当前 key(即 ThreadLocal 实例)的 hashcode 与哈希表大小相与（因为哈希表大小总是为 2 的幂次方，所以相与等同于一个取模的过程）</p><p><strong>怎样解决 hash 冲突？</strong></p><p>源码中通过<code>nextIndex(i, len)</code>方法解决 hash 冲突的问题，该方法中的<code>((i + 1 &lt; len) ? i + 1 : 0);</code>，也就是不断往后线性探测，当到哈希表末尾的时候再从 0 开始，成环形。</p><p><strong>怎样解决“脏”Entry？</strong></p><p>在 set 方法的 for 循环中寻找和当前 Key 相同的可覆盖 entry 的过程中通过<strong>replaceStaleEntry</strong>方法解决脏 entry 的问题。</p><p>如果当前<code>table[i]</code>为 null 的话，直接插入新 entry 后也会通过<strong>cleanSomeSlots</strong>来解决脏 entry 的问题，</p><p><strong>如何进行扩容？</strong></p><p>这里<strong>ThreadLocalMap 初始大小为 16</strong>，<strong>加载因子为 2&#x2F;3</strong>，所以哈希表可用大小为：16*2&#x2F;3&#x3D;10，即哈希表可用容量为 10。</p><p>resize方法代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Double the capacity of the table.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">()</span> &#123;<br>    Entry[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> oldTab.length;<br><span class="hljs-comment">//新数组为原数组的2倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen * <span class="hljs-number">2</span>;<br>    Entry[] newTab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newLen];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldLen; ++j) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> oldTab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocal&lt;?&gt; k = e.get();<br><span class="hljs-comment">//遍历过程中如果遇到脏entry的话直接另value为null,有助于value能够被回收</span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help the GC</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//重新确定entry在新数组的位置，然后进行插入</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> k.ThreadLocalHashCode &amp; (newLen - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (newTab[h] != <span class="hljs-literal">null</span>)<br>                    h = nextIndex(h, newLen);<br>                newTab[h] = e;<br>                count++;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//设置新哈希表的threshHold和size属性</span><br>    setThreshold(newLen);<br>    size = count;<br>    table = newTab;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建一个大小为原来数组长度的两倍的数组，然后遍历旧数组中的 entry 并将其插入到新的 hash 数组中，需要注意的是，<strong>在扩容的过程中针对脏 entry 的话会把 value 设为 null，以便能够被垃圾回收器回收，解决隐藏的内存泄漏的问题</strong>。</p><h2 id="ThreadLocalMap中getEntry方法"><a href="#ThreadLocalMap中getEntry方法" class="headerlink" title="ThreadLocalMap中getEntry方法"></a>ThreadLocalMap中getEntry方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br><span class="hljs-comment">//1. 确定在散列数组中的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.ThreadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//2. 根据索引i获取entry</span><br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br><span class="hljs-comment">//3. 满足条件则返回该entry</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br><span class="hljs-comment">//4. 未查找到满足条件的entry，额外在做的处理</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(key, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前定位的 entry 的 key 和查找的 key 相同的话就直接返回这个 entry，否则的话就是在 set 的时候判断是否存在 hash 冲突，需要通过 getEntryAfterMiss 做进一步处理。getEntryAfterMiss 方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntryAfterMiss</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, <span class="hljs-type">int</span> i, Entry e)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br>        <span class="hljs-keyword">if</span> (k == key)<br><span class="hljs-comment">//找到和查询的key相同的entry则返回</span><br>            <span class="hljs-keyword">return</span> e;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//解决脏entry的问题</span><br>            expungeStaleEntry(i);<br>        <span class="hljs-keyword">else</span><br><span class="hljs-comment">//继续向后环形查找</span><br>            i = nextIndex(i, len);<br>        e = tab[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocalMap中的remove方法"><a href="#ThreadLocalMap中的remove方法" class="headerlink" title="ThreadLocalMap中的remove方法"></a>ThreadLocalMap中的remove方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Remove the entry for key.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>    Entry[] tab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.ThreadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>         e != <span class="hljs-literal">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        <span class="hljs-keyword">if</span> (e.get() == key) &#123;<br><span class="hljs-comment">//将entry的key置为null</span><br>            e.clear();<br><span class="hljs-comment">//将该entry的value也置为null</span><br>            expungeStaleEntry(i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法逻辑很简单，通过往后环形查找到与指定 key 相同的 entry 后，先通过 clear 方法将 key 置为 null 后，使其转换为一个脏 entry，然后调用 expungeStaleEntry 方法将其 value 置为 null，以便垃圾回收时能够清理，同时将 table[i]置为 null。</p><h1 id="多线程的顺序执行"><a href="#多线程的顺序执行" class="headerlink" title="多线程的顺序执行"></a>多线程的顺序执行</h1><h2 id="join方式"><a href="#join方式" class="headerlink" title="join方式"></a>join方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t1.join();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t2.join();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;c&quot;</span>);<br>            &#125;<br>        &#125;);<br>        t3.start();<br>        t2.start();<br>        t1.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CountDownLatch实现"><a href="#CountDownLatch实现" class="headerlink" title="CountDownLatch实现"></a>CountDownLatch实现</h2><p>CountDownLatch通过计数器提供了更灵活的控制，只要检测到计数器为0当前线程就可以往下执行而不用管相应的thread是否执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;c&quot;</span>);<br>                countDownLatch1.countDown();<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    countDownLatch1.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>                countDownLatch2.countDown();<br>            &#125;<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    countDownLatch2.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;d&quot;</span>);<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建单线程池实现"><a href="#创建单线程池实现" class="headerlink" title="创建单线程池实现"></a>创建单线程池实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建单线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;c&quot;</span>);<br>            &#125;<br>        &#125;);<br>        executorService.submit(t1);<br>        executorService.submit(t2);<br>        executorService.submit(t3);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p><strong>设计模式分为三大类</strong></p><p><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p><strong>结构型模式</strong>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂模式（不属于设计模式）"><a href="#简单工厂模式（不属于设计模式）" class="headerlink" title="简单工厂模式（不属于设计模式）"></a>简单工厂模式（不属于设计模式）</h2><blockquote><p> 适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较复杂。  </p></blockquote><p><strong>举例：</strong></p><p><strong>工厂类的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 创建一个抽象类：抽象子类的共有方法</span><br><span class="hljs-comment">* 创建子类实现父类的抽象方法</span><br><span class="hljs-comment">* 在工厂方法中根据类型创建不同的具体对象</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCoffeeFactory</span> &#123;<br><span class="hljs-comment">// 根据type判断类型，实例化并返回对应对象</span><br>    <span class="hljs-keyword">public</span> Coffee <span class="hljs-title function_">createCoffee</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-type">Coffee</span> <span class="hljs-variable">coffee</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;americano&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmericanoCoffee</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;latte&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LatteCoffee</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> coffee;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote><p>定义了一个创建对象的抽象方法，由子类决定要实例化的类</p></blockquote><p><strong>举例：</strong></p><p>（我们依然举pizza工厂的例子，不过这个例子中，pizza产地有两个：伦敦和纽约）。添加了一个新的产地，如果用简单工厂模式的的话，我们要去修改工厂代码，并且会增加一堆的if else语句。而工厂方法模式克服了简单工厂要修改代码的缺点，它会直接创建两个工厂，纽约工厂和伦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 抽象工厂</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CoffeeFactory</span> &#123;<br>    Coffee <span class="hljs-title function_">createCoffee</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 具体工厂</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 抽象产品为coffee，具体产品为LatteCoffee和AmericanCoffee</span><br><span class="hljs-comment">* 这种工厂模式可以通过不同的具体工厂创建出不同的具体产品</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LatteCoffeeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CoffeeFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Coffee <span class="hljs-title function_">createCoffee</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LatteCoffee</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AmericanCoffeeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CoffeeFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Coffee <span class="hljs-title function_">createCoffee</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmericanCoffee</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解决了简单工厂模式的问题，如果新增一个产地，则只需要增加一个类就可以了。</p><blockquote><p> 工厂方法存在的问题与解决方法：客户端需要创建类的具体的实例。简单来说就是用户要订纽约工厂的披萨，他必须去纽约工厂，想订伦敦工厂的披萨，必须去伦敦工厂。 当伦敦工厂和纽约工厂发生变化了，用户也要跟着变化，这无疑就增加了用户的操作复杂性。为了解决这一问题，我们可以把工厂类抽象为接口，用户只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的工厂，方便用户操作。这也就是我们接下来要说的抽象工厂模式。</p></blockquote><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。</p></blockquote><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 抽象工厂</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DessertFactory</span> &#123;<br>    Coffee <span class="hljs-title function_">createCoffee</span><span class="hljs-params">()</span>;<br>    Dessert <span class="hljs-title function_">createDessert</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 具体工厂</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AmericanDessertFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DessertFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Coffee <span class="hljs-title function_">createCoffee</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmericanCoffee</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> Dessert <span class="hljs-title function_">createDessert</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MatchaMousse</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItalyDessertFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DessertFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Coffee <span class="hljs-title function_">createCoffee</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LatteCoffee</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> Dessert <span class="hljs-title function_">createDessert</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiramisu</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>⼀个单例类在任何情况下都只存在⼀个实例，构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀个静态公有⽅法获取实例。  </p></blockquote><h2 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h2><p>顾名思义，类⼀加载就创建对象，这种⽅式⽐较常⽤，但容易产⽣垃圾对象，浪费内存空间  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：没有加锁，执行效率会提高。</p><p>优点：类加载时就初始化，浪费内存。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>线程安全的写法：（双重锁）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;  <br>            <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <br>                singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> singleton;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么要使用两次校验：</strong></p><p>（1）第一次校验</p><p>因为单例模式只需要创建一次实例，如果后面再调用getInstance方法时直接返回之前创建的实例，。因此不需要执行同步方法块里面的代码，大大提高了性能，如果不加，每次都要竞争锁。</p><p>（2）第二次校验</p><p>如果线程1 执行第一次校验后，判断对象为null，这时线程2获取了CPU，也执行了第一次校验，判断对象为null，此时线程2创建对象，这时线程1又获得了CPU，由于之前已经校验过为null了，不会再次判断，所以接着也创建了一个对象，结果就会导致创建了多个实例。</p><p><strong>为什么要加上volatile关键字</strong></p><p>当执行<code>singleton = new Singleton();</code>这段代码时，其实是分三步进行执行的：</p><p>（1）为<code>singleton</code> 分配内存空间</p><p>（2）初始化<code>singleton</code> </p><p>（3）将<code>singleton</code> 指向分配的内存空间。</p><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p><strong>为什么不使用静态内部类</strong></p><p>静态内部类实现单例模式代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//声明为 private 避免调用默认构造方法创建对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>   <span class="hljs-comment">// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><em>Java 加载外部类的时候，不会创建内部类的实例，只有在外部类使用到内部类的时候才会创建内部类实例</em>。</li></ul><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote><p>在我们的应⽤程序中我们可能需要将两个不同接⼝的类来进⾏通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。<strong>所谓适配器模式就是将⼀个类的接⼝，转换成客户期望的另⼀个接⼝。它可以让原本两个不兼容的接⼝能够⽆缝完成对接。</strong>  </p></blockquote><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><blockquote><p>通过类继承来实现适配。</p></blockquote><p>适配器通过<strong>继承源实现目标</strong>来实现适配器</p><p><strong>举例：</strong></p><p><strong>源(Adapee)角色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫猫:喵喵喵。。。。。。。。。。。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>目标(Target)角色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OurFriend</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>适配器(Adapter)角色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatFriend</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OurFriend</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.makeSound();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakTo</span><span class="hljs-params">(OurFriend friend)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;人：你在干嘛？&quot;</span>);<br>        friend.speak();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person person=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        OurFriend friend=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CatFriend</span>();<br>        person.speakTo(friend);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果再来个别的动物，则再增加一个别的动物的适配器，有没有一种办法，可以时各种动物的适配器，则看对象适配器。</p><h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><blockquote><p>通过类对象组合来实现适配</p></blockquote><p>我们希望可以有一个可以和各种动物做朋友的办法，而不是每次有了新的动物朋友都需要增加一个适配器。</p><p><strong>举例：</strong></p><p><strong>让源(Adapee)角色的猫和狗实现动物接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAnimal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;狗：汪汪汪汪。。。。。。。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAnimal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;猫猫:喵喵喵。。。。。。。。。。。。。&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>万物拟人适配器(Adaper)角色</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalFriendAdaper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OurFriend</span>&#123;<br>    <span class="hljs-keyword">private</span> IAnimal animal;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AnimalFriendAdaper</span><span class="hljs-params">(IAnimal animal)</span>&#123;<br>        <span class="hljs-built_in">this</span>.animal=animal;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span> &#123;<br>        animal.makeSound();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speakTo</span><span class="hljs-params">(OurFriend friend)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;人：你在干嘛？&quot;</span>);<br>        friend.speak();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 一个人</span><br>        <span class="hljs-type">Person</span>  <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 一只狗</span><br>        <span class="hljs-type">IAnimal</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-comment">// 一只猫</span><br>        <span class="hljs-type">IAnimal</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-comment">// 万物拟人</span><br>        person.speakTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnimalFriendAdaper</span>(dog));<br>        person.speakTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnimalFriendAdaper</span>(cat));<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote><p>代理模式的本质是⼀个中间件，主要⽬的是解耦合服务提供者和使⽤者。使⽤者通过代理间接的访问服务提供者，便于后者的封装和控制。  </p></blockquote><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>举例：</strong></p><p>以租房为例，租客找房东租房，然后中间经过房屋中介，以此为背景，</p><p>静态代理的前提，那就是真实类和代理类要实现同一个接口，在代理类中实现真实类的方法同时可以进行真实类方法的增强处理，在一个代理类中就可以完成对多个真实对象的注入工作。</p><p><strong>租房：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRentHouse</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rentHouse</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>房东类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RentHouse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRentHouse</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rentHouse</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;实现租房&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>代理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntermediaryProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRentHouse</span> &#123;<br>    <span class="hljs-keyword">private</span> IRentHouse iRent;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IntermediaryProxy</span><span class="hljs-params">(IRentHouse iRentHouse)</span> &#123;<br>        iRent=iRentHouse;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rentHouse</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;交中介费&quot;</span>);<br>        iRent.rentHouse();<br>        System.out.println(<span class="hljs-string">&quot;中介负责维修管理&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>可以看出房东类（RentHouse）和代理类（IntermediaryProxy）都实现了租房接口，这就是一个静态代理的前提</strong></p><p><strong><code>从静态代理的代码中可以发现，静态代理的缺点显而易见，那就是当真实类的方法越来越多的时候，这样构建的代理类的代码量是非常大的，所以就引进动态代理.</code></strong></p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><a href="https://blog.csdn.net/weixin_43953283/article/details/125783249">https://blog.csdn.net/weixin_43953283/article/details/125783249</a></p><h3 id="JDk动态代理"><a href="#JDk动态代理" class="headerlink" title="JDk动态代理"></a>JDk动态代理</h3><p><strong>想要实现动态代理，要解决以下两个问题：</strong></p><ul><li>根据加载到内存中的被代理类，动态的创建一个代理类的对象</li><li>通过代理类对象调用方法a时，如何动态的去调用被代理类中的同名方法a</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 动态代理的举例</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2019 上午 10:18</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Human</span>&#123;<br><br>    String <span class="hljs-title function_">getBelief</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span>;<br><br>&#125;<br><span class="hljs-comment">//被代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Human</span>&#123;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBelief</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I believe I can fly!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我喜欢吃&quot;</span> + food);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">要想实现动态代理，需要解决的问题？</span><br><span class="hljs-comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。</span><br><span class="hljs-comment">问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//同于生成代理类对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span>&#123;<br>    <span class="hljs-comment">//调用此方法，返回一个代理类的对象。解决问题一</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">(Object obj)</span>&#123;<span class="hljs-comment">//obj:被代理类的对象</span><br>        <br>        <span class="hljs-type">MyInvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocationHandler</span>();<br>        <br>        <span class="hljs-comment">//为了在MyInvocationHandler类中实例化被代理类对象</span><br>        handler.bind(obj);<br>        <br>        <span class="hljs-comment">//生成一个代理类的对象</span><br>        <span class="hljs-comment">//obj.getClass().getClassLoader()：被代理类的类加载器</span><br>        <span class="hljs-comment">//obj.getClass().getInterfaces()：被代理类实现的接口（代理类也要实现）</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);<br>    &#125;<br><br>&#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span>&#123;<br><br>    <span class="hljs-keyword">private</span> Object obj;<span class="hljs-comment">//需要使用被代理类的对象进行赋值</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Object obj)</span>&#123;<br>        <span class="hljs-built_in">this</span>.obj = obj;<br>    &#125;<br><br>    <span class="hljs-comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span><br>    <span class="hljs-comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <br>        <span class="hljs-comment">//method:就是代理类所调用的方法，</span><br>        <span class="hljs-comment">//args：代理类所调用方法的参数</span><br>        <span class="hljs-comment">//这个方法就是将代理类调用的方法，被代理类去调用同名的方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> method.invoke(obj,args);<span class="hljs-comment">//相当于：被代理类.代理类调用的方法(args)=Obj.method(args);</span><br><br>        <span class="hljs-comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span><br>        <span class="hljs-keyword">return</span> returnValue;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SuperMan</span> <span class="hljs-variable">superMan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMan</span>();<br>        <span class="hljs-comment">//proxyInstance:代理类的对象</span><br>        <span class="hljs-type">Human</span> <span class="hljs-variable">proxyInstance</span> <span class="hljs-operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);<br>        <span class="hljs-comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span><br>        <span class="hljs-comment">//当执行到下面的方法时，将跳到上面invoke方法，再动态的调用被代理类中同名的方法。，</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">belief</span> <span class="hljs-operator">=</span> proxyInstance.getBelief();<br>        System.out.println(belief);<br>        proxyInstance.eat(<span class="hljs-string">&quot;四川麻辣烫&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;*****************************&quot;</span>);<br><br>        <span class="hljs-type">NikeClothFactory</span> <span class="hljs-variable">nikeClothFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NikeClothFactory</span>();<br><br>        <span class="hljs-type">ClothFactory</span> <span class="hljs-variable">proxyClothFactory</span> <span class="hljs-operator">=</span> (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);<br><br>        proxyClothFactory.produceCloth();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h3 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h3><ol><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;cglib&lt;/groupId&gt;<br>  &lt;artifactId&gt;cglib&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">3.3</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliSmsService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义MethodInterceptor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o           代理对象（增强的对象）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method      被拦截的方法（需要增强的方法）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args        方法入参</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy 用于调用原始方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugMethodInterceptor</span>());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态代理和动态代理的区别："><a href="#静态代理和动态代理的区别：" class="headerlink" title="静态代理和动态代理的区别："></a><strong>静态代理和动态代理的区别：</strong></h2><ol><li><p><strong>灵活性 ：</strong>动态代理更加灵活，不需要必须实现接⼝，可以直接代理实现类，<strong>并且可以不需要针对每个⽬标类都创建⼀个代理类</strong>。另外，<strong>静态</strong><br><strong>代理中，接⼝⼀旦新增加⽅法，⽬标对象和代理对象都要进⾏修改，这是⾮常麻烦的！</strong>  </p></li><li><p><strong>JVM 层⾯</strong> ：静态代理在编译时就将接⼝、实现类、代理类这些都变成了⼀个个实际的 class ⽂件。⽽动态代理是在运⾏时动态⽣成类字节<br>码，并加载到 JVM 中的。</p></li></ol><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><strong>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</strong></p><p><img src="/2022/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/640" alt="图片"></p><p>观察者模式UML图</p><p>看不懂图的人端着小板凳到这里来，给你举个栗子：假设有三个人，小美（女，22），小王和小李。小美很漂亮，小王和小李是两个程序猿，时刻关注着小美的一举一动。有一天，小美说了一句：“谁来陪我打游戏啊？”这句话被小王和小李听到了，结果乐坏了，蹭蹭蹭，没一会儿，小王就冲到小美家门口了，在这里，小美是被观察者，小王和小李是观察者，被观察者发出一条信息，然后观察者们进行相应的处理，看代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Person</span> &#123;<br>   <span class="hljs-comment">//小王和小李通过这个接口可以接收到小美发过来的消息</span><br>   <span class="hljs-built_in">void</span> getMessage(String s);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口相当于小王和小李的电话号码，小美发送通知的时候就会拨打getMessage这个电话，拨打电话就是调用接口，看不懂没关系，先往下看</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wang</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;小王&quot;</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">Wang</span>() &#123;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">getMessage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) &#123;<br>       <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(name + <span class="hljs-string">&quot;接到了小美打过来的电话，电话内容是：&quot;</span> + s);<br>   &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Li</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> name = <span class="hljs-string">&quot;小李&quot;</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">LaoLi</span>() &#123;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">getMessage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) &#123;<br>       <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(name + <span class="hljs-string">&quot;接到了小美打过来的电话，电话内容是：-&gt;&quot;</span> + s);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，我们再看看小美的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">XiaoMei</span> &#123;<br>   List&lt;Person&gt; personList = <span class="hljs-keyword">new</span> ArrayList&lt;Person&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">XiaoMei</span>()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPerson</span>(<span class="hljs-params">Person person</span>)</span>&#123;<br>        personList.<span class="hljs-keyword">add</span>(person);<br>    &#125;<br><br>    <span class="hljs-comment">//遍历list，把自己的通知发送给所有暗恋自己的人</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyPerson</span>()</span> &#123;<br>        <span class="hljs-keyword">for</span>(Person person:personList)&#123;<br>            person.getMessage(<span class="hljs-string">&quot;你们过来吧，谁先过来谁就能陪我一起玩儿游戏!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们写一个测试类来看一下结果对不对</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br><br>       XiaoMei xiao_mei = <span class="hljs-keyword">new</span> <span class="hljs-type">XiaoMei</span>();<br>       Wang wang = <span class="hljs-keyword">new</span> <span class="hljs-type">Wang</span>();<br>       Li li = <span class="hljs-keyword">new</span> <span class="hljs-type">LaoLi</span>();<br><br>       <span class="hljs-comment">//小王和小李在小美那里都注册了一下</span><br>       xiao_mei.addPerson(wang);<br>       xiao_mei.addPerson(li);<br><br>       <span class="hljs-comment">//小美向小王和小李发送通知</span><br>       xiao_mei.notifyPerson();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><blockquote><p>从代码层面而言，是对类的一个扩展或者是修饰，从传统方法而言，我们可以使用继承来对某一个类进行扩展，但是往往会导致会出现非常多的子类，如果我们要想避免这种情况，那么我们就可以使用<a href="https://so.csdn.net/so/search?q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020">设计模式</a>中的——装饰器模式。</p></blockquote><p>装饰器模式是在不改变现有对象结构的情况下，动态地给该对象增加一些职责，即增加其额外功能。</p><p>对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，最后再用两片面包夹一下，很丰盛的一顿午饭，营养又健康。那我们应该怎么来写代码呢？</p><p>首先，我们需要写一个Food类，让其他所有食物都来继承这个类，看代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Food</span> &#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> food_name;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Food</span><span class="hljs-params">()</span> </span>&#123;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Food</span><span class="hljs-params">(<span class="hljs-type">String</span> food_name)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.food_name = food_name;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">make</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> food_name;<br>   &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，我就不解释了，然后我们写几个子类继承它：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//面包类</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">Food</span> basic_food;<br><br>   public <span class="hljs-type">Bread</span>(<span class="hljs-type">Food</span> basic_food) &#123;<br>       <span class="hljs-keyword">this</span>.basic_food = basic_food;<br>   &#125;<br><br>   public <span class="hljs-type">String</span> make() &#123;<br>       <span class="hljs-keyword">return</span> basic_food.make()+<span class="hljs-string">&quot;+面包&quot;</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//奶油类</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">Food</span> basic_food;<br><br>   public <span class="hljs-type">Cream</span>(<span class="hljs-type">Food</span> basic_food) &#123;<br>       <span class="hljs-keyword">this</span>.basic_food = basic_food;<br>   &#125;<br><br>   public <span class="hljs-type">String</span> make() &#123;<br>       <span class="hljs-keyword">return</span> basic_food.make()+<span class="hljs-string">&quot;+奶油&quot;</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//蔬菜类</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vegetable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Food</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-type">Food</span> basic_food;<br><br>   public <span class="hljs-type">Vegetable</span>(<span class="hljs-type">Food</span> basic_food) &#123;<br>       <span class="hljs-keyword">this</span>.basic_food = basic_food;<br>   &#125;<br><br>   public <span class="hljs-type">String</span> make() &#123;<br>       <span class="hljs-keyword">return</span> basic_food.make()+<span class="hljs-string">&quot;+蔬菜&quot;</span>;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑，如果你还是看不懂为什么这么写，不急，你看看我的Test类是怎么写的，一看你就明白了：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>       Food food = <span class="hljs-keyword">new</span> <span class="hljs-type">Bread</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Vegetable</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Cream</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Food</span>(<span class="hljs-string">&quot;香肠&quot;</span>))));<br>       System.out.println(food.make());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到没有，一层一层封装，我们从里往外看：最里面我new了一个香肠，在香肠的外面我包裹了一层奶油，在奶油的外面我又加了一层蔬菜，最外面我放的是面包，是不是很形象，哈哈~ 这个设计模式简直跟现实生活中一摸一样，看懂了吗？我们看看运行结果吧：</p><p><img src="/2022/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/640" alt="图片"></p><p>运行结果</p><p>一个三明治就做好了～</p><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SHEIN笔试</title>
    <link href="/2022/09/30/SHEIN%E7%AC%94%E8%AF%95/"/>
    <url>/2022/09/30/SHEIN%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h1><p>给定一个含有n个字符的数组和一个单词作为target。</p><p>找出数组中第一个包含了指定单词所有自读（保持单词中原有的顺序）的子数组，并返回其子数组的其实索引位和结束索引位。如果不存在符合条件的子数组，返回空数组。</p><p><strong>示例1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：target=abc,nums[c,a,c,b,c,c]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：target=dd,nums[a,d,c,d,d]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>代码为:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-type">char</span> ch[] = &#123;<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>        <span class="hljs-type">int</span>[] match = match(target, ch);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;match.length;i++)&#123;<br>            System.out.print(match[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] match(String target,<span class="hljs-type">char</span> ch[])&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ch.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> target.length();<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//结果数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//记录搜索到字符串的什么位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (target.charAt(pos)==ch[i])&#123;  <span class="hljs-comment">//如果找到一个</span><br>                <span class="hljs-keyword">if</span> (pos==<span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//如果市首位，则结果数组记录下来</span><br>                    res[<span class="hljs-number">0</span>] = i;<br>                &#125;<br>                pos++;  <span class="hljs-comment">//则字符串中的位置向后移动一位</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (pos==m)&#123;  <span class="hljs-comment">//如果是最后一位，则结果数组记录下来</span><br>                res[<span class="hljs-number">1</span>] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res[<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">0</span>];<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h1><p>answer_tb中表的内容为：</p><p><img src="/2022/09/30/SHEIN%E7%AC%94%E8%AF%95/image-20220930155955602.png" alt="image-20220930155955602"></p><p>要查询的内容为：</p><p><img src="/2022/09/30/SHEIN%E7%AC%94%E8%AF%95/image-20220930160019309.png" alt="image-20220930160019309"></p><p>其中per_num：回答问题的数量&#x2F;答题人数</p><p><strong>分析</strong></p><ul><li><p>通过输出的结果可以看出，是通过日期分组，通过日期的时间进行从低到高的排序。</p></li><li><p>计算per_num时里面的答题人数要去重。</p></li><li><p>并且结果保留两位有效数字。</p></li></ul><p><strong>代码为：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT answer_date,FORMAT((count(*)/ count(DISTINCT author_id)),2) per_num FROM answer_tb where answer_date BETWEEN &quot;2021-11-01&quot; and &quot;2021-11-05&quot; GROUP BY answer_date order by answer_date asc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>SHEIN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用友笔试</title>
    <link href="/2022/09/25/%E7%94%A8%E5%8F%8B%E7%AC%94%E8%AF%95/"/>
    <url>/2022/09/25/%E7%94%A8%E5%8F%8B%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h1><p>题目：一些数字 1-n，n的范围很小（1~52），先找到1，把1去掉，随后 找下一个除4余2的， 除4余3的， 除4余0的，除4余1的，直到最后一个</p><h2 id="解法（自己）"><a href="#解法（自己）" class="headerlink" title="解法（自己）"></a>解法（自己）</h2><p>暴力解法，感觉我自己写的这个太暴力了，哈哈~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> circle[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> shrinkCircle(circle);<br>        System.out.println(i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shrinkCircle</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] circle)</span> &#123;<br>            <span class="hljs-comment">// write code here</span><br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; circle.length; i++) &#123;<br>                list.add(circle[i]);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> circle.length;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (list.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> list.size();<br>                    <span class="hljs-keyword">if</span> (j == list.size() ) j = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j; i &lt; list.size(); i++) &#123;<br>                        <span class="hljs-keyword">if</span> (list.get(i) == <span class="hljs-number">1</span>) &#123;<br>                            list.remove(i);<br>                            j = i;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (l==list.size())&#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>                            <span class="hljs-keyword">if</span> (list.get(i) == <span class="hljs-number">1</span>) &#123;<br>                                list.remove(i);<br>                                j = i;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res = list.get(<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (list.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> list.size();<br>                    <span class="hljs-keyword">if</span> (j == list.size() ) j = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j; i &lt; list.size(); i++) &#123;<br>                        <span class="hljs-keyword">if</span> (list.get(i) % <span class="hljs-number">4</span> == <span class="hljs-number">2</span>) &#123;<br>                            list.remove(i);<br>                            j = i;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (l==list.size())&#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>                            <span class="hljs-keyword">if</span> (list.get(i) % <span class="hljs-number">4</span> == <span class="hljs-number">2</span>) &#123;<br>                                list.remove(i);<br>                                j = i;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res = list.get(<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (list.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (j == list.size()) j = <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> list.size();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j; i &lt; list.size(); i++) &#123;<br>                        <span class="hljs-keyword">if</span> (list.get(i) % <span class="hljs-number">4</span> == <span class="hljs-number">3</span>) &#123;<br>                            list.remove(i);<br>                            j = i;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (l==list.size())&#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>                            <span class="hljs-keyword">if</span> (list.get(i) % <span class="hljs-number">4</span> == <span class="hljs-number">3</span>) &#123;<br>                                list.remove(i);<br>                                j = i;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res = list.get(<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (list.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> list.size();<br>                    <span class="hljs-keyword">if</span> (j == list.size() ) j = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j; i &lt; list.size(); i++) &#123;<br>                        <span class="hljs-keyword">if</span> (list.get(i) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &#123;<br>                            list.remove(i);<br>                            j = i;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (l==list.size())&#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>                            <span class="hljs-keyword">if</span> (list.get(i) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &#123;<br>                                list.remove(i);<br>                                j = i;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res = list.get(<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (list.size()&gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> list.size();<br>                    <span class="hljs-keyword">if</span> (j == list.size() ) j = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j; i &lt; list.size(); i++) &#123;<br>                        <span class="hljs-keyword">if</span> (list.get(i) % <span class="hljs-number">4</span> == <span class="hljs-number">1</span>) &#123;<br>                            list.remove(i);<br>                            j = i;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (l==list.size())&#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>                            <span class="hljs-keyword">if</span> (list.get(i) % <span class="hljs-number">4</span> == <span class="hljs-number">1</span>) &#123;<br>                                list.remove(i);<br>                                j = i;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res = list.get(<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考大佬的：</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>对暴力解法进行优化，先对数组中的数进行%4运算，用数组info存储。再使用数组valied进行判断数组中的数是否被访问过。如果选择，以后就不要选择了。</p><p><strong>代码1为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> circle[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> shrinkCircle(circle);<br>        System.out.println(i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shrinkCircle</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] circle)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> circle.length;<br>        <span class="hljs-type">int</span> info[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>        <span class="hljs-type">boolean</span> valied[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len];  <span class="hljs-comment">//记录数是否被访问</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            info[i] = circle[i]%<span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (circle[index]!=<span class="hljs-number">1</span>)&#123;<br>            index++;     <span class="hljs-comment">//找到第一个出现 1 的位置</span><br>        &#125;<br>        valied[index] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">//记录已经删除数字的个数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (num!=len-<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//找数组中的数，直到数组中的数只剩下一个，也就是nun==len-1</span><br>            <span class="hljs-keyword">if</span> (!valied[index] &amp;&amp; info[index]==c)&#123;<br>                num++;<br>                c = c==<span class="hljs-number">3</span>?<span class="hljs-number">0</span>:c+<span class="hljs-number">1</span>;  <span class="hljs-comment">//如果现阶段寻找的是余3的数，则下一阶段寻找的就是可以被4整除的，也就是%4的结果为0的</span><br>                valied[index] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            index = index==len-<span class="hljs-number">1</span>?<span class="hljs-number">0</span>:index+<span class="hljs-number">1</span>;  <span class="hljs-comment">//如果已经找到数组的最后，则下一个要从头开始，就是下标从0开始</span><br>        &#125;<br>        <span class="hljs-comment">//数组已经处理完毕，剩下一个没有被访问的就是答案</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span> (!valied[i])&#123;<br>                <span class="hljs-keyword">return</span> circle[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p><strong>代码2为：</strong></p><p>手动实现环形链表，将不满足的数据加到链表的后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        int circle[] = &#123;2,4,1,3&#125;;</span><br>        <span class="hljs-type">int</span> circle[] = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> shrinkCircle(circle);<br>        System.out.println(i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shrinkCircle</span> <span class="hljs-params">(<span class="hljs-type">int</span>[] circle)</span> &#123;<br>        <span class="hljs-comment">// write code here</span><br>        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> circle.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            list.add(circle[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span> (circle[i]==<span class="hljs-number">1</span>)&#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        list.remove(index);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (list.size()&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> list.removeFirst();<br>            <span class="hljs-keyword">if</span> (t%<span class="hljs-number">4</span>==p)&#123;<br>                p = p==<span class="hljs-number">3</span>?<span class="hljs-number">0</span>:p+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            list.addLast(t);  <span class="hljs-comment">//如果不满足条件则将该再数加入到链表的最后，形成环形链表的结构</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h1><p><strong>题目：</strong></p><p>在一个三维直角坐标系中，有一只蚂蚁从原点 (0, 0, 0) 开始，向目标点 (l, m, n) 前进，蚂蚁的前进规则如下：</p><p>1、l, m, n &gt;&#x3D; 0，且 l + m + n &gt; 0；  </p><p>2、蚂蚁每次只能沿X&#x2F;Y&#x2F;Z轴的方向前进一个单位，比如，当前蚂蚁在点(x0, y0, z0)，下一步只能前进到下面三个点中的任意一个：(x0 + 1, y0, z0)，或(x0, y0 + 1, z0)，或(x0, y0, z0 + 1)。   </p><p>返回所有可以从原点 (0, 0, 0) 到目标点 (l, m, n) 的可行路径数量。</p><ul><li><strong>@param</strong> x int整型 目标点的X坐标  * <strong>@param</strong> y int整型 目标点的Y坐标  * <strong>@param</strong> z int整型 目标点的Z坐标  * <strong>@return</strong> long长整型  *&#x2F;</li></ul><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p><strong>通过数学的方法</strong></p><p>高中数学题，我们可以认为，有三个商品abc，每一个又有多个，问你有多少种组合方式。相当于 </p><p>  1、在所有的 a+b+c 中，先选出a个位置 放a，个数为C(a+b+c, a) [不太会打上下的格式，就是排列组合中的 C，不是A] </p><p>  2、在剩下的b+c个中，选出b个放b </p><p>  3、c的话剩余的位置，只有1种 </p><p>  答案就是 第一步结果 * 第二部结果 * 1</p><p>注意说返回的long，应该很大，我再计算过程中用的Big Integer。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(countPaths(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countPaths</span> <span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x+y+z;<br>        <span class="hljs-type">BigInteger</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> process(sum,x);<br>        <span class="hljs-type">BigInteger</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> process(sum-x,y);<br>        <span class="hljs-keyword">return</span> b1.multiply(b2).longValue();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BigInteger <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-type">BigInteger</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> BigInteger.valueOf(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">BigInteger</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> BigInteger.valueOf(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;a;i++)&#123;<br>            top=top.multiply(BigInteger.valueOf(sum--));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=a;i++)&#123;<br>            down = down.multiply(BigInteger.valueOf(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> top.divide(down);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h1><p>最长递增子序列</p>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>用友</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>商用软件部面试</title>
    <link href="/2022/09/24/%E5%95%86%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%83%A8%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/09/24/%E5%95%86%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%83%A8%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="在卫星的太空里面，一个程序要执行40个小时，每天只能执行8小时，怎么执行才能尽快完成（计算机组成原理的知识）"><a href="#在卫星的太空里面，一个程序要执行40个小时，每天只能执行8小时，怎么执行才能尽快完成（计算机组成原理的知识）" class="headerlink" title="在卫星的太空里面，一个程序要执行40个小时，每天只能执行8小时，怎么执行才能尽快完成（计算机组成原理的知识）"></a>在卫星的太空里面，一个程序要执行40个小时，每天只能执行8小时，怎么执行才能尽快完成（计算机组成原理的知识）</h1><h1 id="使用什么数据结构能实现，我查询香蕉给我返回水果，查询苹果给我返回水果，输入白菜给我返回蔬菜"><a href="#使用什么数据结构能实现，我查询香蕉给我返回水果，查询苹果给我返回水果，输入白菜给我返回蔬菜" class="headerlink" title="使用什么数据结构能实现，我查询香蕉给我返回水果，查询苹果给我返回水果，输入白菜给我返回蔬菜"></a>使用什么数据结构能实现，我查询香蕉给我返回水果，查询苹果给我返回水果，输入白菜给我返回蔬菜</h1><h1 id="方法的参数有100个，需要怎么解决"><a href="#方法的参数有100个，需要怎么解决" class="headerlink" title="方法的参数有100个，需要怎么解决"></a>方法的参数有100个，需要怎么解决</h1><h1 id="java中的-除了对数字的加操作，还能运用在什么地方"><a href="#java中的-除了对数字的加操作，还能运用在什么地方" class="headerlink" title="java中的+除了对数字的加操作，还能运用在什么地方"></a>java中的+除了对数字的加操作，还能运用在什么地方</h1><h1 id="说一下SpringBoot中的starters"><a href="#说一下SpringBoot中的starters" class="headerlink" title="说一下SpringBoot中的starters"></a>说一下SpringBoot中的starters</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>东软</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>政府事业部部门面试</title>
    <link href="/2022/09/24/%E6%94%BF%E5%BA%9C%E4%BA%8B%E4%B8%9A%E9%83%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/09/24/%E6%94%BF%E5%BA%9C%E4%BA%8B%E4%B8%9A%E9%83%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="jdk和jre的区别"><a href="#jdk和jre的区别" class="headerlink" title="jdk和jre的区别"></a>jdk和jre的区别</h1><p>JDK包含JRE，JRE又包含JVM。</p><ul><li>JDK：JAVA标准开发工具包，他提供了编译，运行JAVA所需要的各种工具和资源，包含JAVA编译器，JAVA运行环境（JRE），以及常用的Java基础类库等，是整个JAVA的核心。</li><li>JRE：是JAVA语言编写程序所必不可少的运行环境，用于执行java字节码文件，不是开发环境，没有包含任何开发工具，知识针对使用java程序用户。</li></ul><h1 id="SpringBoot相较于Spring的好处"><a href="#SpringBoot相较于Spring的好处" class="headerlink" title="SpringBoot相较于Spring的好处"></a>SpringBoot相较于Spring的好处</h1><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>按照流的数据流向可以分为：输入流和输出流</p><p>按照流中处理的数据单位，可以将其流分为：字节流（InputStream，OutputStream）和字符流（Reader，Writer）</p><h1 id="Math-raound-1-5-等于多少"><a href="#Math-raound-1-5-等于多少" class="headerlink" title="Math.raound(-1.5)等于多少"></a>Math.raound(-1.5)等于多少</h1><p>四舍五入，等于-1。</p><h1 id="数据库的三范式"><a href="#数据库的三范式" class="headerlink" title="数据库的三范式"></a>数据库的三范式</h1><p>第一范式：确保每一列的原子性，就是每一列都是不可再分的数据单元</p><p>第二范式：满足第一范式，第二范式要求每个表只描述一件事情</p><p>第三范式：非主键的属性对主键都是直接依赖，而不是间接依赖</p><p><img src="/2022/09/24/%E6%94%BF%E5%BA%9C%E4%BA%8B%E4%B8%9A%E9%83%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95/20210220122950155.png" alt="img"></p><p>以上表既满足第一范式也满足第二范式，非主键字段也完全依赖于主键字段。</p><p>但是，院系电话字段，其实是依赖院系字段的。也就是说，院系电话字段是非主键值，而依赖了另一个非主键值-院系。所以就不符合第三范式。</p><p><img src="/2022/09/24/%E6%94%BF%E5%BA%9C%E4%BA%8B%E4%B8%9A%E9%83%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95/20210220123225855.png" alt="img"></p><p><img src="/2022/09/24/%E6%94%BF%E5%BA%9C%E4%BA%8B%E4%B8%9A%E9%83%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95/20210220123233321.png" alt="img"></p><h1 id="数据库的ACID是什么"><a href="#数据库的ACID是什么" class="headerlink" title="数据库的ACID是什么"></a>数据库的ACID是什么</h1><p><strong>Atomicity（原子性）</strong>：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，</p><p><strong>Consistency（一致性）</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</p><p><strong>Isolation（隔离性）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><p><strong>Durability（持久性）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h1 id="File类中都有哪些方法，随便说几个"><a href="#File类中都有哪些方法，随便说几个" class="headerlink" title="File类中都有哪些方法，随便说几个"></a>File类中都有哪些方法，随便说几个</h1><p>File类构造方法:<br>常用的有三种：<br>1、File(String pathname)：通过路径名创建一个新 File 实例。</p><p>2、File(File parent, String child)：根据父目录路径File实例和子目录或文件路径创建一个新 File 实例。</p><p>3、File(String parent, String child) ：根据父目录路径和子目录或文件路径创建一个新 File 实例。</p><p>isDirectory() 是否为文件夹<br>isFile() 是否为文件<br>getPath() 得到file的路径<br>getName() 得到最后一层的名字<br>getParent() 得到去掉最后一层的路径<br>getParentFile() 得到父类路径的新文件<br>renameTo() 改名<br>mkdir() 创建新文件夹，只能创建一层<br>mkdirs() 创建新文件夹，可以多层<br>createNewFile() 创建新文件，只能一层<br>exists() 路径是否存在<br>delete() 删除文件或者目录（为空的目录）</p><h1 id="除了git代码管理工具还有什么-例如SVN"><a href="#除了git代码管理工具还有什么-例如SVN" class="headerlink" title="除了git代码管理工具还有什么?例如SVN"></a>除了git代码管理工具还有什么?例如SVN</h1><p>git和<a href="https://so.csdn.net/so/search?q=svn&spm=1001.2101.3001.7020">svn</a>都是程序员用来管理代码的。如果是一个人开发项目，则用不上，如果是一个团队进行开发的话，则版本控制就尤为重要啦。</p><p><strong>一、从原理方面说一下SVN和git的区别</strong></p><p><strong>git属于分布式控制系统，SVN属于集中式控制系统</strong></p><p>简单来说前者就是以每一台主机都当成一台服务器，而后者则是只有一台服务器来维护和控制代码。其两者区别如图所示。</p><p><img src="/2022/09/24/%E6%94%BF%E5%BA%9C%E4%BA%8B%E4%B8%9A%E9%83%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95/1903793-20200325114822171-35226656.png" alt="img"></p><p><img src="/2022/09/24/%E6%94%BF%E5%BA%9C%E4%BA%8B%E4%B8%9A%E9%83%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95/1903793-20200325121300709-2105706424.png" alt="img"></p><p>SVN的管理方法是一台主服务器管理所有主机，这样所有代码全部传输到服务器上统一管理。而git采用单个主机管单个主机的方法，即主机2将主机1中所有的信息和内容拷贝到自己的主机下，而主机3，主机4以此类推。</p><p><strong>相比较SVN，git有如下好处：</strong></p><p>1、如果一旦出现断电，SVN里面的数据全部消失，但是git则不会。</p><p>2、使用SVN时，必须联网，否则不能使用。但是git只要第一次将代码下载到自己的主机上，以后就不用联网也可以查看历史记录什么的了。</p><p><strong>二、从应用方面说一下SVN和git的区别</strong></p><p><strong>SVN是专门用来维护文档的，而git则是用来维护代码的。</strong>等等。。</p><h1 id="git-add"><a href="#git-add" class="headerlink" title="git.add()"></a>git.add()</h1><p>将文件的修改加入暂存区</p><h1 id="git-commit"><a href="#git-commit" class="headerlink" title="git.commit()"></a>git.commit()</h1><p>git仓库分为两种：</p><ul><li>本地仓库：一种是开发人员自己电脑上的仓库</li><li>远程仓库：远程服务器上的Git仓库</li></ul><p>commit：提交：是将本地文件和版本保存到本地仓库</p><h1 id="git-push"><a href="#git-push" class="headerlink" title="git.push()"></a>git.push()</h1><p>push：推送，将本地仓库文件的版本信息上传到远程仓库</p><h1 id="git-pull"><a href="#git-pull" class="headerlink" title="git.pull()"></a>git.pull()</h1><p>pull：拉取，将远程仓库文件和版本信息下载到本地仓库</p><h1 id="SpringCloud了解吗"><a href="#SpringCloud了解吗" class="headerlink" title="SpringCloud了解吗"></a>SpringCloud了解吗</h1><p>不了解  哈哈哈！</p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>final可以修饰类，方法和属性。</p><p><strong>修饰类时：</strong>当用final修饰类的时，表明该类不能被其他类所继承。final类中所有的成员方法都会隐式的定义为final方法。</p><p><strong>修饰方法时：</strong>次方法不能被子类重写，如果父类中的方法的访问权限是private，则子类不能继承该方法，可以重新定义。</p><p><strong>修饰属性时：</strong>final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。</p><h1 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h1><p>redis提供了两种持久化方式（也就是将内存中的数据写入到硬盘里）：</p><ul><li><p><strong>RDB（快照）</strong>：在指定的时间间隔内将内存的数据集快照写入磁盘</p><p>优点：适合对大规模的数据进行恢复，比AOF的启动效率高</p><p>缺点：在一定的时间间隔内做一次备份，如果redis突然停止，会丢失最后一次快照的修改</p></li><li><p><strong>AOF（追加文件）</strong>：以日志的形式记录服务器所处理的每一写和删除操作，以文本的方式记录，可以打开看到详细的操作记录。</p><p>优点：（1）更高的安全性，提供了三种同步策略，每秒同步，每修改同步和不同步，相比RDB停止丢失的数据会更少（2）记录所有的修改操作，可以通过文件完成数据的重建</p><p>缺点：对于相同数据量而言，AOF文件通常大于RDB文件，恢复时速度要慢</p></li></ul><h1 id="redis中的内存淘汰机制"><a href="#redis中的内存淘汰机制" class="headerlink" title="redis中的内存淘汰机制"></a>redis中的内存淘汰机制</h1><p><strong>redis提供六种数据淘汰策略：</strong></p><ul><li>已经设置过期时间的数据集中，选择最近最少使用的数据进行淘汰</li><li>已经设置过期时间的数据集中，选择将要过期的进行淘汰</li><li>已经设置过期时间的数据集中，随机选择进行淘汰</li><li>当内存不足以写入数据时，选择最近最少使用的数据进行淘汰</li><li>从数据集中任意选择数据进行淘汰</li><li>当内存不足以容纳数据时，则抛出异常</li></ul><p><strong>4.0新增：</strong></p><ul><li>已经设置过期时间的数据集中，选择最不经常使用的数据进行淘汰</li><li>当内存不足时，移除最不经常使用的key</li></ul><h1 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h1><p><strong>mysql定义了四种隔离级别：</strong></p><ul><li>读未提交：允许读取未提交的数据，可能会导致脏读，幻读，不可重读读</li><li>读已提交：允许读取并发事务已经提交的数据，可以阻止脏读，但幻读和不可重复读可能发生</li><li>可重复读：对同一字段的多次读取结果是一样的，除非被本身的该事务自己修改，可以防止脏读和不可重复读</li><li>串行化：最高的隔离级别，所有的事务逐个执行。可以防止脏读、幻读和不可重读。</li></ul><p><strong>幻读：</strong></p><p>SQL 脚本 1 在第一次查询工资为 500 的记录时只有一条，SQL 脚本 2 插入了一条工资为 500 的记录，提交之后；SQL 脚本 1 在同一个事务中再次使用当前读查询发现出现了两条工资为 500 的记录这种就是幻读。</p><h1 id="redis中，Jedis"><a href="#redis中，Jedis" class="headerlink" title="redis中，Jedis"></a>redis中，Jedis</h1><h1 id="redis中有哪些类型"><a href="#redis中有哪些类型" class="headerlink" title="redis中有哪些类型"></a>redis中有哪些类型</h1><p>常用的数据类型：String，List，Set，Hash，Zset</p><p>特殊的数据结构：BitMap（通过位数来表示当前的状态）应用用户签到情况，活跃用户情况、hyperLogLog（基数计数概率算法）应用数量巨大的应用场景、Geospatial index（用于存储地理位置信息）应用于附近的人。</p><h1 id="redis中的缓存击穿"><a href="#redis中的缓存击穿" class="headerlink" title="redis中的缓存击穿"></a>redis中的缓存击穿</h1><p><strong>请求大量不存在的key，导致请求直接到了数据库上，没有经过缓存这一层，。</strong></p><p><strong>解决方法：</strong>最基本的就是访问不合法的请求时直接抛出异常给客户端，。</p><p><strong>（1）缓存无效key</strong>：将缓存和无效的key都写入到redis中并设置过期时间，这种方式适合key的变化不频繁的情况，如果恶意攻击，会导致redis缓存大量无效的key。</p><p>在java中的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObjectInclNullById</span><span class="hljs-params">(Integer id)</span> &#123;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheValue</span> <span class="hljs-operator">=</span> cache.get(id);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (cacheValue == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 从数据库中获取</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">storageValue</span> <span class="hljs-operator">=</span> storage.get(key);<br>        <span class="hljs-comment">// 缓存空对象</span><br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span><br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 必须设置过期时间，否则有被攻击的风险</span><br>            cache.expire(key, <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cacheValue;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（2）布隆过滤器</strong></p><p>通过他，我们可以非常方便的判断一个给定数据是否存在于海量数据中，需要判断的是key是否合法，</p><p>具体的做法：</p><p>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p><img src="/2022/09/24/%E6%94%BF%E5%BA%9C%E4%BA%8B%E4%B8%9A%E9%83%A8%E9%83%A8%E9%97%A8%E9%9D%A2%E8%AF%95/image-20221001143901867.png" alt="image-20221001143901867"></p><h1 id="redis中的缓存雪崩"><a href="#redis中的缓存雪崩" class="headerlink" title="redis中的缓存雪崩"></a>redis中的缓存雪崩</h1><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求</strong></p><p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol><h1 id="MQ了解吗"><a href="#MQ了解吗" class="headerlink" title="MQ了解吗"></a>MQ了解吗</h1><p>不了解</p><p>市场上现在常用的消息队列有：RabbitMQ、RocketMQ、Kafka，ActiveMQ</p><p>差不多这些~~</p>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>东软</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日常</title>
    <link href="/2022/09/23/%E6%97%A5%E5%B8%B8/"/>
    <url>/2022/09/23/%E6%97%A5%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>h哈哈</p>]]></content>
    
    
    <categories>
      
      <category>要热爱生活呀！</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9.21一面</title>
    <link href="/2022/09/21/9-21%E4%B8%80%E9%9D%A2/"/>
    <url>/2022/09/21/9-21%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="问科研项目"><a href="#问科研项目" class="headerlink" title="问科研项目"></a>问科研项目</h1><p>主要是解决什么问题</p><h1 id="gt-gt-和-gt-gt-gt"><a href="#gt-gt-和-gt-gt-gt" class="headerlink" title="&gt;&gt;和&gt;&gt;&gt;"></a>&gt;&gt;和&gt;&gt;&gt;</h1><p>移位操作符只能处理整数类型。</p><p>int类型占4个字节（一共32位），第一位表示符号位，其它位为数值为。那么它最大能表示2^31-1（即2147483647），最小能表示-2^31(即-2147483648)。</p><p>为什么最小值不是-2^31-1，而是-2^31？</p><ul><li>负数在计算机中以补码表示（符号位不变，原码取反再加1），因此10000000 00000000 00000000 00000000表示最大的负数，为-2^31。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Integer.MAX_VALUE); <span class="hljs-comment">// 2147483647</span><br>System.out.println(Integer.MIN_VALUE); <span class="hljs-comment">// -2147483648</span><br>System.out.println(Integer.toBinaryString(-<span class="hljs-number">2147483648</span>)); <span class="hljs-comment">//10000000000000000000000000000000</span><br>System.out.println(Integer.toBinaryString(-<span class="hljs-number">1</span>)); <span class="hljs-comment">// 11111111111111111111111111111111</span><br></code></pre></td></tr></table></figure><p>移位操作符有以下几种（注意：移位时符号位也会跟着移动）：</p><ul><li>左移位操作符&lt;&lt;，低位补0</li><li>有符号右移位&gt;&gt;，使用符号扩展：若符号为正，则在高位插入0；若符号为负，则在高位插入1</li><li>无符号右移位&gt;&gt;&gt;，使用零扩展：无论正负，都在高位插入0</li></ul><p>如果对char、byte、short类型移位，则在移位前，它们会被转成int类型，且返回值也是int类型；如果对long类型移位，则返回值也是long。</p><h1 id="finally和finalize"><a href="#finally和finalize" class="headerlink" title="finally和finalize"></a>finally和finalize</h1><p><strong>（1）finally：</strong>搭配try-catch一起使用，正常情况下，不管是否抛出异常或者捕获异常，finally都会执行。</p><p>什么是否finally不执行：在try中调用System.exit(1)或者halt函数时不执行，</p><p><strong>以下两种情况要清楚：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.company;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;123&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<span class="hljs-comment">//未处理异常</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// write your code her</span><br>        System.out.println(test());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码抛出异常。</p><p>但finally语句return后就不会抛出异常了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;123&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;finally&quot;</span>;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// write your code her</span><br>        System.out.println(test());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>程序正常，输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">123</span><br><span class="hljs-keyword">finally</span><br></code></pre></td></tr></table></figure><p><strong>覆盖其他返回语句：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;123&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;try&quot;</span>;<span class="hljs-comment">//被覆盖</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;finally&quot;</span>;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// write your code her</span><br>        System.out.println(test());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">123</span><br><span class="hljs-keyword">finally</span><br><br></code></pre></td></tr></table></figure><p><strong>改变throw或return行为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;123&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;try&quot;</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// write your code her</span><br>        System.out.println(test());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果为：</p><p>try代码中没有异常，可以正常返回，。但在fianlly中抛出异常</p><p><strong>（2）finalize</strong></p><p>是Object类提供的方法，Java中的垃圾回收机制在回收对象的时候，会首先调用该对象的finalize方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><p>具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalizeDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>            person=<span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 增大概率*/</span><br>            System.gc();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 有概率回收。</span><br><span class="hljs-comment">     * 垃圾回收前自动调用此方法。*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;对象即将被销毁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">对象被销毁<br>对象被销毁<br>对象被销毁<br>对象被销毁<br>对象被销毁<br>对象被销毁<br>对象被销毁<br>对象被销毁<br>。。。。。。<br></code></pre></td></tr></table></figure><h1 id="内部类的作用和声明方式"><a href="#内部类的作用和声明方式" class="headerlink" title="内部类的作用和声明方式"></a>内部类的作用和声明方式</h1><p><strong>内部类作用：</strong>内部类使得多继承的解决方案变得更加完整（<strong>也就是内部类可以实现多继承</strong>），每个内部类都能独立继承一个实现，所以无论外围类是否已经继承了某个实现，对于内部类都没有影响。</p><p><strong>内部类的特性：</strong></p><ul><li>内部类的对象与外围对象相互独立</li><li>多个内部类可以以不同的方式实现同一个接口或继承同一个类</li><li>内部类提供了更好的封装，除了外围类，其他类不能访问，。</li></ul><p>内部类分为：成员内部类、静态内部类、局部内部类、匿名内部类</p><p><strong>（1）成员内部类</strong></p><blockquote><p>让内部类可以访问外部类中定义的一个私有的msg属性的内容。内部类有一个最大的优点：可以访问外部类中的私有操作。<br>内部类可以访问外部类的私有属性，反之，外部类可以通过内部类对象访问内部类的私有属性</p></blockquote><p><strong>注意：</strong> </p><ul><li>成员内部类不能有任何static的变量和方法</li><li>成员内部类是依附于外围类的，所以只有 先创建外围类才能创建内部类</li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//定义了一个内部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">//              外部类.this = 外部类的当前对象</span><br>System.out.println(Outer.<span class="hljs-built_in">this</span>.msg);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>().print();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br><span class="hljs-type">Outer</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<span class="hljs-comment">//实例化外部类</span><br>out.fun();<span class="hljs-comment">//调用外部类</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>实例化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br>    <span class="hljs-keyword">private</span> String msg=<span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<span class="hljs-comment">//定义了一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(Outer.<span class="hljs-built_in">this</span>.msg);<br>    &#125;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>    Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    oi.print();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>如果内部类定义为private，则内部类不能在外部进行对象的实例化。</strong></p><p><strong>（2）静态内部类</strong></p><blockquote><p>使用static定义的属性或者方法是不受类实例化对象控制的，所以使用了static定义内部类。不受外部类实例化对象的控制。<br><strong>如果一个内部类使用了static定义的话，那么这个内部类就变为了一个外部类</strong>，并且只能访问static定义的操作。相当于定义一个外部类。</p></blockquote><p><strong>注意：</strong></p><ul><li>它的创建是不需要依赖于外部类</li><li>它不能使用任何外部类的非static成员变量和方法</li></ul><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String msg=<span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>System.out.println(msg);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">oi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>.Inner();<span class="hljs-comment">//此时不需要先产生外部类对象，再产生内部类对象，仿佛一个独立的类。</span><br>oi.print();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（3）局部内部类</strong></p><blockquote><p>它是嵌套在方法和作用于内的，它只能在该方法和属性中被使用，出了该方法和属性就会失效。</p></blockquote><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<span class="hljs-comment">//方法参数</span><br><span class="hljs-type">double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">99.9</span>;<span class="hljs-comment">//方法变量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;属性&quot;</span> + Outer.<span class="hljs-built_in">this</span>.msg);<br>System.out.println(<span class="hljs-string">&quot;方法参数：&quot;</span> + num);<br>System.out.println(<span class="hljs-string">&quot;方法变量：&quot;</span> + score);<br>&#125;<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>().print();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().fun(<span class="hljs-number">100</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（4）匿名内部类</strong></p><blockquote><p>匿名内部类是没有访问修饰符的，没有构造方法的。</p></blockquote><p><strong>例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>   fun(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IMessage</span>()&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;匿名内部类&quot;</span>);<br>   &#125;<br>   &#125;);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(IMessage msg)</span>&#123;<br>   msg.print();<br>   &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><h1 id="是否了解设计模式"><a href="#是否了解设计模式" class="headerlink" title="是否了解设计模式"></a>是否了解设计模式</h1><h1 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h1><h1 id="Autowired作用"><a href="#Autowired作用" class="headerlink" title="@Autowired作用"></a>@Autowired作用</h1><p>还有一些不记得了~~</p>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>经纬恒润</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高斯消去法</title>
    <link href="/2022/09/18/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95/"/>
    <url>/2022/09/18/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="高斯消去法解方程组"><a href="#高斯消去法解方程组" class="headerlink" title="高斯消去法解方程组"></a>高斯消去法解方程组</h1><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 nn。</p><p>接下来 nn 行，每行包含 n+1n+1 个实数，表示一个方程的 nn 个系数以及等号右侧的常数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果给定线性方程组存在唯一解，则输出共 nn 行，其中第 ii 行输出第 ii 个未知数的解，结果保留两位小数。</p><p>如果给定线性方程组存在无数解，则输出 <code>Infinite group solutions</code>。</p><p>如果给定线性方程组无解，则输出 <code>No solution</code>。</p><p><strong>高斯消去法的步骤：</strong></p><ul><li>找到当前列绝对值最大的一行</li><li>把它换到最上面一行</li><li>将该行的第一个数变为1</li><li>把下面所有行的该列消为0</li></ul><p><strong>解的形式：</strong></p><ul><li>完美阶梯型：唯一解</li><li>零&#x3D;非零：无解</li><li>零&#x3D;零：无穷解</li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">double</span> arr[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;=n;j++)&#123;<br>                arr[i][j] = scanner.nextDouble();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> guass(arr);<br>        <span class="hljs-keyword">if</span> (index==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                <span class="hljs-keyword">if</span>(arr[i][n]==-<span class="hljs-number">0.0</span>) arr[i][n]=<span class="hljs-number">0.0</span>;<br>                System.out.println(String.format(<span class="hljs-string">&quot;%.2f&quot;</span>,arr[i][n]));<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index==<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Infinite group solutions&quot;</span>);  <span class="hljs-comment">//无穷多个解</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;No solution&quot;</span>);<span class="hljs-comment">//无解</span><br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">guass</span><span class="hljs-params">(<span class="hljs-type">double</span> arr[][])</span>&#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (r = <span class="hljs-number">0</span>,c = <span class="hljs-number">0</span>;c&lt;n;c++)&#123;<br>            <span class="hljs-comment">//第一步，找到该列的最大值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> r;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r;i&lt;n;i++)&#123;<br>                <span class="hljs-keyword">if</span> (Math.abs(arr[t][c])&lt;Math.abs(arr[i][c]))&#123;<br>                    t = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(Math.abs(arr[t][c])&lt;<span class="hljs-number">0.000001</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//最大值的行数为t，与当前行交换</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> c;i&lt;=n;i++)&#123;<br>                <span class="hljs-type">double</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[t][i];<br>                arr[t][i] = arr[r][i];<br>                arr[r][i] = temp;<br>            &#125;<br>            <span class="hljs-comment">//将当前行的第一个数设为1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n;i&gt;=c;i--)&#123;<br>                arr[r][i]/= arr[r][c];<br>            &#125;<br>            <span class="hljs-comment">//将下面所有行的该列消为0</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r+<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>                <span class="hljs-keyword">if</span>(Math.abs(arr[i][c])&gt;<span class="hljs-number">0.000001</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= c; j--) &#123;<br>                        arr[i][j]-= arr[r][j] * arr[i][c];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//进行下一行处理</span><br>            r++;<br>        &#125;<br>        <span class="hljs-comment">//0解或者无穷解</span><br>        <span class="hljs-keyword">if</span> (r&lt;n)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r;i&lt;n;i++)&#123;<br>                <span class="hljs-keyword">if</span> (Math.abs(arr[i][n])&gt;<span class="hljs-number">0.000001</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//0解</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//无穷解</span><br>        &#125;<br>        <span class="hljs-comment">//唯一解</span><br>        <span class="hljs-comment">/*此时这里得到的矩阵是</span><br><span class="hljs-comment">          1.0 0.5 -1.5 -4.5</span><br><span class="hljs-comment">          0.0 1.0 0.33  -1.0</span><br><span class="hljs-comment">          0.0 0.0 1.0  3.0</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">// 其中a[i][j]是主元的位置</span><br>                <span class="hljs-comment">//行从后面向前面消除主元后面的元素</span><br>                <span class="hljs-comment">//例如倒数第二行的[0.0 1.0 0.3  -1.0]</span><br>                <span class="hljs-comment">//[0.0 1.0 0 -2.0] -1.0-0.33*3=-2.0</span><br>                arr[i][n]-=arr[i][j]*arr[j][n];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>高斯消元代码中最难理解的就是往回推的最后一步</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">for (<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>       for (<span class="hljs-built_in">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">n</span>; j ++ )<br>           a[i][<span class="hljs-built_in">n</span>] -= a[j][<span class="hljs-built_in">n</span>] * a[i][j];<br></code></pre></td></tr></table></figure><p>这里的 i，j 其实代表的是 xi和xj ，对于 i 行中的 xj 对应的系数是 <code>a[i][j]</code>,而<code>a[i][j]</code>则代表了此时 i 行的多项式的结果，为了得到xi的解（xi的系数是1）就需要<strong>此时的结果减去后面的多项式的和</strong>即</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for(int j = i + 1; j &lt; n; j ++ )<br>    a<span class="hljs-comment">[i]</span><span class="hljs-comment">[n]</span> -= a<span class="hljs-comment">[j]</span><span class="hljs-comment">[n]</span> * a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;//x_j * x_j的系数<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>科大讯飞笔试</title>
    <link href="/2022/09/18/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E7%AC%94%E8%AF%95/"/>
    <url>/2022/09/18/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h1><p>图像的卷积是对图像处理的最常用的方法，当前深度神经网络中的卷积神经网络当中也用到了卷积的操作来提取特征，卷积一般包含以下几个概念：</p><p>卷积核中心：卷积数组的中心位置。</p><p>卷积操作：将卷积核中心对准输入的某个元素，两个矩阵会有重合区域，将两个矩阵的重合区域中的对应重合元素相乘求和。再将卷积核分别从左到右，从上到下进行滑动。</p><p>这里设置步长为1.</p><p><img src="/2022/09/18/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E7%AC%94%E8%AF%95/A2DFF7529F9C6D074432B701A674F7BF" alt="img"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">//行</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();   <span class="hljs-comment">//列</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> scanner.nextInt();<span class="hljs-comment">//行</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> scanner.nextInt();<span class="hljs-comment">//列</span><br>        <span class="hljs-type">int</span> arr[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                arr[i][j] = scanner.nextInt();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> p[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k][l];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;l;j++)&#123;<br>                p[i][j] = scanner.nextInt();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> res[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<span class="hljs-comment">//结果数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> -(k/<span class="hljs-number">2</span>);r&lt;=k/<span class="hljs-number">2</span>;r++)&#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -(l/<span class="hljs-number">2</span>);c&lt;=l/<span class="hljs-number">2</span>;c++)&#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i+r;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> j+c;<br>                        <span class="hljs-keyword">if</span> (x&gt;=<span class="hljs-number">0</span> &amp;&amp;x&lt;m &amp;&amp; y&gt;=<span class="hljs-number">0</span> &amp;&amp; y&lt;n)&#123;<br>                            sum+=arr[x][y] * p[r+k/<span class="hljs-number">2</span>][c+l/<span class="hljs-number">2</span>];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (sum&gt; <span class="hljs-number">255</span>)&#123;<br>                    sum = <span class="hljs-number">255</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (sum&lt;<span class="hljs-number">0</span>)&#123;<br>                    sum = <span class="hljs-number">0</span>;<br>                &#125;<br>                res[i][j] = sum;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;res.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;res[<span class="hljs-number">0</span>].length;j++)&#123;<br>                System.out.print(res[i][j]+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h1><p>力扣岛屿的最大面积，变形题：</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> M;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> N;<br>        <span class="hljs-type">int</span> area[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">while</span> (m--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span> (n--&gt;<span class="hljs-number">0</span>)&#123;<br>                area[m][n] = scanner.nextInt();<br>            &#125;<br>            n = N;<br>        &#125;<br>        m= M;<br>        n = N;<br>        <span class="hljs-type">int</span> t;<br>        <span class="hljs-keyword">while</span> (m--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span> (n--&gt;<span class="hljs-number">0</span>)&#123;<br>                t = scanner.nextInt();<br>                area[m][n] = area[m][n]==t?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>            &#125;<br>            n = N;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i!=M;++i)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j!=N;++j)&#123;<br>                ans = Math.max(ans,dfs(area,i,j));<br>            &#125;<br>        &#125;<br>        System.out.println(ans);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> [][]area,<span class="hljs-type">int</span> cur_i,<span class="hljs-type">int</span> cur_j)</span>&#123;<br>        <span class="hljs-keyword">if</span> (cur_i&lt;<span class="hljs-number">0</span>||cur_j&lt;<span class="hljs-number">0</span>||cur_i==area.length||cur_j==area[<span class="hljs-number">0</span>].length||area[cur_i][cur_j]!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        area[cur_i][cur_j] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []di = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span> dj[] = &#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;index!=<span class="hljs-number">4</span>;++index)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next_i</span> <span class="hljs-operator">=</span> cur_i+di[index],next_j = cur_j+dj[index];<br>            ans+=dfs(area,next_i,next_j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>科大讯飞</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经准备</title>
    <link href="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/"/>
    <url>/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试官您好，我叫张露文，现就读于东北大学软件学院研究生三年级，面试的岗位是JAVA工程师。在校期间，我的成绩一直在前5%的位置，多次获得了学习奖学金，读研期间发表一篇EI检索的论文，第二篇SCI论文正在投稿过程中，自身掌握了Java语言的基础知识，熟悉mysql数据库，在最近做的项目《<strong>酒店外卖点餐系统</strong>》后端的开发中也是使用Java语言编写的，用到了目前主流的开源框架SpringBoot、mybatisplus等等。在闲暇的时间，也会去访问csdn、博客园等这些网站来提高自己的知识量。所以，我相信在以后的工作中我一定会给公司创造更大的价值。很荣幸得到这次的面试机会，以上就是我的自我介绍。</p><h2 id="1、说说你觉得做过印象最深的项目"><a href="#1、说说你觉得做过印象最深的项目" class="headerlink" title="1、说说你觉得做过印象最深的项目"></a>1、说说你觉得做过印象最深的项目</h2><p>就是那个<strong>酒店外卖点餐系统</strong>，主要负责了后端的菜品管理，分类管理，员工管理，套餐管理，订单明细，这个项目是以SpringBoot框架进行开发的，使用mybatis-plus进行数据库连接的，用到了maven管理工具，使用restful风格进行开发，在控制层使用了RequestMapping来编写代码，，在业务代码中使用Service注解进行开发，Autowired方式来引入类的。</p><p><strong>也对项目进行了优化，</strong></p><p>在每一次添加员工或者菜单的时候，需要设置以下四个字段（创建时间，更新时间，创建人，更新人），在每一次更新时，要设置以下两个字段（更新时间，更新人）而这些代码属于重复部分，可以拿出来，不用反复重写。在mybatisplus中提供了一种方法，<strong>公共字段自动填充功能（在插入或更新时为指定的字段赋予相应的值，避免了重复的代码）</strong>。<strong>怎么做的：</strong> <strong>自定义元数据对象处理器使用注解@Component</strong>，实现MetaObjectHandler 类，重写里面的两个方法insertFill和updateFill。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> LocalDateTime createTime;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.UPDATE)</span><br><span class="hljs-keyword">private</span> LocalDateTime updateTime;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br><span class="hljs-keyword">private</span> Long createUser;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> Long updateUser;<br></code></pre></td></tr></table></figure><p>对于缓存的优化，当用户数量多，系统访问数据库过于频繁时，系统性能下降，用户体验差。因此使用redis进行缓存优化，对于缓存菜品数据。使用菜品分类的id作为键，菜品分类中的菜品作为值，如果查找菜品分类对应的菜品时，先通过键在缓存中查找，有就直接返回，如果没有就从数据库中查找，查找成功后再放入到redis中。</p><h2 id="2、遇到什么困难，怎么解决"><a href="#2、遇到什么困难，怎么解决" class="headerlink" title="2、遇到什么困难，怎么解决"></a>2、遇到什么困难，怎么解决</h2><p><strong>第一个：</strong></p><p>对于 用户可以不登录直接访问后台， 配置了过滤器 用于页面访问控制 对于无法直接访问的资源 要先判断 用户是否登录 登录成功后要把用户id存到threadlocal线程类中（创建一个类） 用于后续用户id获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于ThreadLocal封装的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseContext</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentId</span><span class="hljs-params">(Long id)</span>&#123;<br>        threadLocal.set(id);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> threadLocal.get();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>第二个：</strong></p><p>在编辑员工，通过id来进行员工信息修改的时候，查询数据库的时候发现，修改不成功。发现页面发送请求的id和数据库中要修改的id后三位不同，通过百度查询，发现js对long类型的数据进行处理时丢失了精度。需要使用对象转换器和Spring MVC的消息转换器。（将服务器给页面响应json数据的时候进行处理，将long类型转换为String字符串）</p><p><strong>第三个：</strong></p><p>新建菜品的时候，前端发过来的请求包含菜品的口味，但是菜品实体中不包含菜品口味的属性。使用dto进行解决。</p><h2 id="3、你在项目中负责的什么模块"><a href="#3、你在项目中负责的什么模块" class="headerlink" title="3、你在项目中负责的什么模块"></a>3、你在项目中负责的什么模块</h2><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/image-20220920223102550.png" alt="image-20220920223102550"></p><h2 id="4、具体功能讲解"><a href="#4、具体功能讲解" class="headerlink" title="4、具体功能讲解"></a>4、具体功能讲解</h2><p>员工管理：新增员工，员工禁用，编辑员工信息，员工信息分页查询</p><h2 id="5、数据库怎么设计的"><a href="#5、数据库怎么设计的" class="headerlink" title="5、数据库怎么设计的"></a>5、<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE">数据</a>库怎么设计的</h2><p>首先进行需求分析，通过需求分析来标识要管理的对象，分析对象要存储的信息，也就是有哪些字段，根据字段来确定是什么类型，以及各个对象之间的联系，创建概念模型，画出e-r图，再创建数据库表的同时也要遵循数据库的三大范式，（第一范式，就是保证数据库表中字段的原子性，就是字段是不可再分的数据单元。第二范式，要满足第一范式，每个表描述的是同一间事情，不能订单表还包含产品编号什么的。第三范式就是要满足第二范式，并且字段和主键是直接相关不能是间接相关）</p><p><strong>第一范式：</strong></p><p>不良做法如下，“学生”一列有多项信息都合在一起了，不再具有原子性，所以应该分开：</p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/20210220121125532.png" alt="img"></p><p>实际中，原子性还是比较容易理解的。</p><p>修改后：</p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/20210220121225775.png" alt="img"></p><p><strong>第二范式：</strong></p><p>不良做法：</p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/20210220122011873.png" alt="img"></p><p>这个表虽然满足了<strong>第一范式</strong>，但是也很明显的感受到它的冗余性，其中学生信息和课程信息是冗余的。</p><p>修改后，分为学生信息表、课程信息表、学生学分表：</p><p>学生信息表：只代表学生的个人信息，主键使用id以防止重名。</p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/20210220122426319.png" alt="img"></p><p>课程信息表：这里的主键可以不用id，使用课程名称也可以，不会有重名。</p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/2021022012244740.png" alt="img"></p><p>学生学分表：学生和课程，确定一个学分，这里学生id和课程id作为联合主键来对应一条成绩。</p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/20210220122538388.png" alt="img"></p><p><strong>第三范式：</strong></p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/20210220122950155.png" alt="img"></p><p>以上表既满足第一范式也满足第二范式，非主键字段也完全依赖于主键字段。</p><p>但是，院系电话字段，其实是依赖院系字段的。也就是说，院系电话字段是非主键值，而依赖了另一个非主键值-院系。所以就不符合第三范式。</p><p>改良：</p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/20210220123225855.png" alt="img"></p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/20210220123233321.png" alt="img"></p><p><img src="/2022/09/16/%E9%9D%A2%E7%BB%8F%E5%87%86%E5%A4%87/image-20220920223219442.png" alt="image-20220920223219442"></p><h2 id="6、项目是怎么使用MVC思想"><a href="#6、项目是怎么使用MVC思想" class="headerlink" title="6、项目是怎么使用MVC思想"></a>6、项目是怎么使用MVC思想</h2><p>MVC就是将软件进行分层设计和实现，分为，视图层（V），控制层（C），模型层（M）。通过分层可以使程序具有更好的灵活性和扩展性，</p><p><a href="https://blog.csdn.net/liuyufeng509/article/details/94588359">https://blog.csdn.net/liuyufeng509/article/details/94588359</a></p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li><p>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</p></li><li><p>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</p></li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p><strong>MVC的工作流程：</strong> 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller</p><p>调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果</p><p>找到相应的View视图，渲染数据后最终响应给浏览器</p><h2 id="包括java的值引用"><a href="#包括java的值引用" class="headerlink" title="包括java的值引用"></a>包括java的值引用</h2><p>java中的值传递：传递对象的副本，即使副本的值改变了，也不会影响源对象，因为值传递的时候是将实参的值拷贝一份给形参。</p><p>java中的引用传递：传递的并不是实际的对象，而是对象的引用，外部对引用对象的改变会反应到源对象上（数组、类、接口）</p><h2 id="redis锁，"><a href="#redis锁，" class="headerlink" title="redis锁，"></a><a href="https://www.nowcoder.com/jump/super-jump/word?word=redis">redis</a>锁，</h2><p>redis能用的的加锁命令分表是<code>INCR</code>、<code>SETNX</code>、<code>SET</code></p><p><code>incr：</code></p><p>这种加锁的思路是， key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作进行加一。<br>然后其它用户在执行 INCR 操作进行加一时，如果返回的数大于 1 ，说明这个锁正在被使用当中。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-number">1</span>、 客户端A请求服务器获<span class="hljs-built_in">取key</span>的值为<span class="hljs-number">1</span>表示获取了锁<br>  <span class="hljs-number">2</span>、 客户端B也去请求服务器获<span class="hljs-built_in">取key</span>的值为<span class="hljs-number">2</span>表示获取锁失败<br>  <span class="hljs-number">3</span>、 客户端A执行代码完成，删除锁<br>  <span class="hljs-number">4</span>、 客户端B在等待一段时间后在去请求的时候获<span class="hljs-built_in">取key</span>的值为<span class="hljs-number">1</span>表示获取锁成功<br>  <span class="hljs-number">5</span>、 客户端B执行代码完成，删除锁<br> <br>  <span class="hljs-variable">$redis-</span>&gt;incr(<span class="hljs-variable">$key</span>);<br>  <span class="hljs-variable">$redis-</span>&gt;expire(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$ttl</span>); //设置生成时间为<span class="hljs-number">1</span>秒<br></code></pre></td></tr></table></figure><p><code>setnx：</code></p><p>这种加锁的思路是，如果 key 不存在，将 key 设置为 value<br>如果 key 已存在，则 <code>SETNX</code> 不做任何动作</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-number">1</span>、 客户端A请求服务器设<span class="hljs-built_in">置key</span>的值，如果设置成功就表示加锁成功<br>    <span class="hljs-number">2</span>、 客户端B也去请求服务器设<span class="hljs-built_in">置key</span>的值，如果返回失败，那么就代表加锁失败<br>    <span class="hljs-number">3</span>、 客户端A执行代码完成，删除锁<br>    <span class="hljs-number">4</span>、 客户端B在等待一段时间后在去请求设<span class="hljs-built_in">置key</span>的值，设置成功<br>    <span class="hljs-number">5</span>、 客户端B执行代码完成，删除锁<br>    <br>    <span class="hljs-variable">$redis-</span>&gt;setNX(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>);<br>    <span class="hljs-variable">$redis-</span>&gt;expire(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$ttl</span>);<br></code></pre></td></tr></table></figure><p><code>set：</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-number">1</span>、 客户端A请求服务器设<span class="hljs-built_in">置key</span>的值，如果设置成功就表示加锁成功<br>    <span class="hljs-number">2</span>、 客户端B也去请求服务器设<span class="hljs-built_in">置key</span>的值，如果返回失败，那么就代表加锁失败<br>    <span class="hljs-number">3</span>、 客户端A执行代码完成，删除锁<br>    <span class="hljs-number">4</span>、 客户端B在等待一段时间后在去请求设<span class="hljs-built_in">置key</span>的值，设置成功<br>    <span class="hljs-number">5</span>、 客户端B执行代码完成，删除锁<br>        <br>    <span class="hljs-variable">$redis-</span>&gt;set(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;nx&#x27;</span>, <span class="hljs-string">&#x27;ex&#x27;</span> =&gt; <span class="hljs-variable">$ttl</span>));  //ex表示秒<br></code></pre></td></tr></table></figure><h2 id="过期策略，"><a href="#过期策略，" class="headerlink" title="过期策略，"></a>过期策略，</h2><p>redis对于设置过期时间的数据，如果一个键过期了，什么时候被删除，redis使用的是惰性删除和定期删除。</p><ul><li>惰性删除：每次获取键时，都要检查键是否过期，如果过期则删除，没有过期则返回改键</li><li>定期删除：每隔一段时间，程序对数据库进行一次检查，删除里面过期的键。</li></ul><h2 id="spring事务及失效场景，"><a href="#spring事务及失效场景，" class="headerlink" title="spring事务及失效场景，"></a>spring事务及失效场景，</h2><p><a href="https://blog.csdn.net/m0_67391120/article/details/126041740">https://blog.csdn.net/m0_67391120/article/details/126041740</a></p><h2 id="springboot的自动装配，线程安全解决办法，抽奖概率场景设计，"><a href="#springboot的自动装配，线程安全解决办法，抽奖概率场景设计，" class="headerlink" title="springboot的自动装配，线程安全解决办法，抽奖概率场景设计，"></a>springboot的自动装配，线程安全解决办法，抽奖概率场景设计，</h2><h2 id="1-期望工作地点是哪里，接不接受去别的地方，第一年需要去北京培训巴拉巴拉，如果接受的话就开始面试"><a href="#1-期望工作地点是哪里，接不接受去别的地方，第一年需要去北京培训巴拉巴拉，如果接受的话就开始面试" class="headerlink" title="1.期望工作地点是哪里，接不接受去别的地方，第一年需要去北京培训巴拉巴拉，如果接受的话就开始面试"></a>1.期望工作地点是哪里，接不接受去别的地方，第一年需要去北京培训巴拉巴拉，如果接受的话就开始面试</h2><h2 id="2-自我介绍"><a href="#2-自我介绍" class="headerlink" title="2.自我介绍"></a>2.自我介绍</h2><h2 id="3-平时开发有没有做项目，你介绍一下你第一个项目，有没有用到数据库，sql语句怎么写的，写的多不多，用到了什么复合查询"><a href="#3-平时开发有没有做项目，你介绍一下你第一个项目，有没有用到数据库，sql语句怎么写的，写的多不多，用到了什么复合查询" class="headerlink" title="3.平时开发有没有做项目，你介绍一下你第一个项目，有没有用到数据库，sql语句怎么写的，写的多不多，用到了什么复合查询"></a>3.平时开发有没有做项目，你介绍一下你第一个项目，有没有用到<a href>数据</a>库，sql语句怎么写的，写的多不多，用到了什么复合查询</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(<span class="hljs-type">name</span>,sex,age) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;张三&#x27;</span>，<span class="hljs-number">18</span>，<span class="hljs-string">&#x27;男&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">delete <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span> student <span class="hljs-keyword">set</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;张三&#x27;</span> <span class="hljs-keyword">where</span> id=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student<br></code></pre></td></tr></table></figure><p><strong>复合查询：</strong></p><h2 id="3-springboot的controller层是干嘛的，"><a href="#3-springboot的controller层是干嘛的，" class="headerlink" title="3.springboot的controller层是干嘛的，"></a>3.springboot的controller层是干嘛的，</h2><p>controller层：根据用户提交过来的请求，通过url匹配匹配给不同的接收器，</p><h2 id="get和post区别是什么，项目中哪个用的多"><a href="#get和post区别是什么，项目中哪个用的多" class="headerlink" title="get和post区别是什么，项目中哪个用的多"></a>get和post区别是什么，项目中哪个用的多</h2><p><strong>第一个区别：</strong></p><p>get请求一般是用来获取资源的，</p><p>post请求是用来进行增删改操作的，</p><p><strong>第二个区别：</strong></p><p>get请求将请求参数拼接到url上进行参数传递的 </p><p>post请求将请求的参数写入到请求正文中传递。（文件上传只能使用post）</p><p>参数值比较少的时候，可以选择get。</p><h2 id="4-linux项目怎么部属的，镜像文件怎么用的"><a href="#4-linux项目怎么部属的，镜像文件怎么用的" class="headerlink" title="4.linux项目怎么部属的，镜像文件怎么用的"></a>4.linux项目怎么部属的，镜像文件怎么用的</h2><h2 id="5-写项目的时候怎么调试的（我说我没遇到什么逻辑上的问题，然后说用swagger测试后端，然后如何处理异常"><a href="#5-写项目的时候怎么调试的（我说我没遇到什么逻辑上的问题，然后说用swagger测试后端，然后如何处理异常" class="headerlink" title="5.写项目的时候怎么调试的（我说我没遇到什么逻辑上的问题，然后说用swagger测试后端，然后如何处理异常"></a>5.写项目的时候怎么调试的（我说我没遇到什么逻辑上的问题，然后说用swagger<a href>测试</a>后端，然后如何处理异常</h2><h2 id="重点：这个公司真的会问期望薪资和工作地，提前准备好"><a href="#重点：这个公司真的会问期望薪资和工作地，提前准备好" class="headerlink" title="重点：这个公司真的会问期望薪资和工作地，提前准备好"></a><strong>重点：</strong>这个公司真的会问<strong>期望薪资和工作地</strong>，提前准备好</h2><ul><li><h2 id="自我介绍（询问是否有ppt）"><a href="#自我介绍（询问是否有ppt）" class="headerlink" title="自我介绍（询问是否有ppt）"></a>自我介绍（询问是否有ppt）</h2></li><li><h2 id="询问了一下科研情况"><a href="#询问了一下科研情况" class="headerlink" title="询问了一下科研情况"></a>询问了一下<a href>科研</a>情况</h2></li><li><h2 id="Spring-IOC和AOP"><a href="#Spring-IOC和AOP" class="headerlink" title="Spring IOC和AOP"></a>Spring IOC和AOP</h2><p>IOC:控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理，使用 IOC 目的：为了耦合度降低</p><p>AOP：面向切面，不修改源代码进行功能增强</p></li><li><h2 id="Spring-xml开发和注解开发具体实现和区别"><a href="#Spring-xml开发和注解开发具体实现和区别" class="headerlink" title="Spring xml开发和注解开发具体实现和区别"></a>Spring xml开发和注解开发具体实现和区别</h2></li><li><h2 id="SpringMVC说说"><a href="#SpringMVC说说" class="headerlink" title="SpringMVC说说"></a>SpringMVC说说</h2></li></ul><p>我主要问了一下具体做的业务，和工作城市主要在哪里，还有后面面试的内容</p><ul><li>持续时间：30min </li><li>22号二面</li></ul>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>经纬恒润</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高途笔试</title>
    <link href="/2022/09/16/%E9%AB%98%E9%80%94%E7%AC%94%E8%AF%95/"/>
    <url>/2022/09/16/%E9%AB%98%E9%80%94%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h1><p><strong>实现支持 ‘.’ 和 ‘*’ 的正则表达式匹配</strong></p><blockquote><p>给定一个<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a> (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘<em>’ 的正则表达式匹配。<br>‘.’ 匹配任意单个字符。<br>‘</em>’ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串</p></blockquote><p><strong>说明:</strong></p><blockquote><p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和</p></blockquote><p><strong>思路：</strong></p><p><strong>当模式中的下一个字符不是”*”时：</strong></p><blockquote><ul><li>如果字符串当前字符和模式中的当前字符相匹配，那么字符串指针和模式指针都后移一个字符，然后匹配剩余的。</li><li>如果字符串当前字符和模式中当前字符不匹配，直接返回false。</li></ul></blockquote><p><strong>当模式中的下一个是”*”时：</strong></p><p>如果字符串当前字符跟模式当前字符不匹配，则模式指针后移2个字符，继续匹配。</p><blockquote><p>如果字符串当前字符跟模式当前字符匹配，可以有3种匹配方式：<br>    1、模式指针后移2字符，相当于x<em>被忽略；<br>    2、字符串指针后移1字符，模式指针后移2字符；<br>    3、字符串指针后移1字符，模式不变，即继续匹配字符下一位，因为</em>可以匹配多位；</p></blockquote><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (p.equals(<span class="hljs-string">&quot;.*&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || p == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果字符串或者模式是空的，那么肯定没有匹配的</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">strIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, patternIndex = <span class="hljs-number">0</span>;                 <span class="hljs-comment">// 从字符串和模式的第一位开始进行匹配</span><br>        <span class="hljs-keyword">return</span> matchChar(s, strIndex, p, patternIndex);<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matchChar</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> strIndex, String pattern, <span class="hljs-type">int</span> patternIndex)</span>&#123;<br><br>        <span class="hljs-keyword">if</span> (strIndex == str.length() &amp;&amp; patternIndex == pattern.length())&#123;  <span class="hljs-comment">// 字符串和模式同时都到末尾</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (strIndex != str.length() &amp;&amp; patternIndex == pattern.length())&#123;  <span class="hljs-comment">// 模式先到末尾</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    <span class="hljs-comment">// 下一个字符是*</span><br>        <span class="hljs-keyword">if</span> (patternIndex + <span class="hljs-number">1</span> &lt; pattern.length() &amp;&amp; pattern.charAt(patternIndex + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;  <br>        <span class="hljs-comment">//如果匹配，则3种匹配方式</span><br>            <span class="hljs-keyword">if</span> ((strIndex != str.length() &amp;&amp; str.charAt(strIndex) == pattern.charAt(patternIndex)) ||<br>                    (strIndex != str.length() &amp;&amp; pattern.charAt(patternIndex) == <span class="hljs-string">&#x27;.&#x27;</span>) )&#123;<br>                <span class="hljs-keyword">return</span> matchChar(str, strIndex, pattern, patternIndex + <span class="hljs-number">2</span>) ||<br>                        matchChar(str, strIndex + <span class="hljs-number">1</span>, pattern, patternIndex + <span class="hljs-number">2</span>) ||<br>                        matchChar(str, strIndex + <span class="hljs-number">1</span>, pattern, patternIndex);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">//如果不匹配，模式指针后移2个字符，继续匹配。</span><br>                <span class="hljs-keyword">return</span> matchChar(str, strIndex, pattern, patternIndex + <span class="hljs-number">2</span>);<br>            &#125;<br>        <span class="hljs-comment">// 下一个字符不是*</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((strIndex!=str.length() &amp;&amp; str.charAt(strIndex) == pattern.charAt(patternIndex)) ||<br>                (strIndex != str.length() &amp;&amp; pattern.charAt(patternIndex) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>            <span class="hljs-comment">// 下一个字符不是*，字符串当前字符和模式中的当前字符相匹配</span><br>            <span class="hljs-keyword">return</span> matchChar(str, strIndex + <span class="hljs-number">1</span>, pattern, patternIndex + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h1><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><blockquote><p> 例如，121 是回文，而 123 不是。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">121</span><br>输出：<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">-121</span><br>输出：<span class="hljs-keyword">false</span><br>解释：从左向右读<span class="hljs-punctuation">,</span> 为 <span class="hljs-number">-121</span> 。 从右向左读<span class="hljs-punctuation">,</span> 为 <span class="hljs-number">121</span>- 。因此它不是一个回文数。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">输入：<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>输出：<span class="hljs-keyword">false</span><br>解释：从右向左读<span class="hljs-punctuation">,</span> 为 <span class="hljs-number">01</span> 。因此它不是一个回文数。<br></code></pre></td></tr></table></figure><p><strong>思路为：</strong></p><p>反转数字的一半，该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><blockquote><p> 例如:1221的反转数字一半 的过程。</p><p>将1221%10&#x3D;1，则为该数字的最后一个，</p><p>倒数第二位：1221&#x2F;10 &#x3D; 122；122%10 &#x3D; 2；第二位计算完毕</p><p>将第一个计算的数字×10再加第二位数字，依次进行下去。（r &#x3D; r*10 + x%10;  x &#x3D; x&#x2F;10;）</p><p>结束条件：当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p></blockquote><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span> || (x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>)&amp;&amp;x!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (r&lt;x)&#123;<br>            r = r*<span class="hljs-number">10</span> + x%<span class="hljs-number">10</span>;<br>            x = x/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (x==r) || (x==(r/<span class="hljs-number">10</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h1><p><strong>有效的括号</strong></p><p>给定一个只包括 <code>&#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><pre><code class="hljs">1. 左括号必须用相同类型的右括号闭合。 2. 左括号必须以正确的顺序闭合。 3. 每个右括号都有一个对应的相同类型的左括号。</code></pre><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>创建一个栈进行存放<code>&#39;(&#39;</code>和<code>&#39;[&#39;</code>和<code>&#39;&#123;&#39;</code>。</p><p>如果遇到符号的右半部分，则判断栈是否为空，如果为空，直接返回false，如果不为空，判断是否和栈顶元素相等，不相等返回false。</p><p>如果遇到符号左半部分，则入栈。</p><p>最后判断栈种的元素是否为空来判断是否满足。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> scanner.next();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Map&lt;Character,Character&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;(&#x27;</span>);<br>        map.put(<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>);<br>        map.put(<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        Deque&lt;Character&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (map.containsKey(c))&#123;<br>                <span class="hljs-keyword">if</span> (deque.isEmpty()||deque.peek()!= map.get(c))&#123;<br>                    System.out.println(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                deque.pop();<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                deque.push(c);<br>            &#125;<br>        &#125;<br>        System.out.println(deque.isEmpty());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>高途</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>度小满笔试题</title>
    <link href="/2022/09/16/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2022/09/16/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h1><h1 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h1><p><img src="/2022/09/16/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%95%E9%A2%98/image-20220916164327108.png" alt="image-20220916164327108"></p><p><strong>代码为：</strong></p><p>差分方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> arr[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l,r;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            l = scanner.nextInt();<br>            r = scanner.nextInt();<br>            arr[l]++;<br>            arr[r++]--;<br>            max = Math.max(max,r);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=max;i++)&#123;<br>            arr[i] = arr[i]+arr[i-<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (arr[i]&gt;=h) res++;<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h1><p><img src="/2022/09/16/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%AC%94%E8%AF%95%E9%A2%98/image-20220916165235709.png" alt="image-20220916165235709"></p>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>度小满</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>米哈游笔试</title>
    <link href="/2022/09/15/%E7%AC%94%E8%AF%95/"/>
    <url>/2022/09/15/%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="算法题1"><a href="#算法题1" class="headerlink" title="算法题1"></a>算法题1</h1><p>米小游拿到了一个字符串，她想截取一个连续子串，使得该子串中包含至少K个连续的“mihoyo”。你可以帮米小游求出最短的子串长度，以及对应的子串位置吗？</p><p><strong>输入：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">22</span> <span class="hljs-number">2</span>（字符串长度，至少有两个连续的）<br>mihoyoyomihoyomimihoyo<br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">21</span>（左右下标），该题也可以为<span class="hljs-number">0</span> <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mihoyo;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> scanner.next();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mihoyo&quot;</span>;<br>        <span class="hljs-comment">//用于存储每一个出现mihoyo的位置</span><br>        List&lt;Integer&gt; l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;s.length()-<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;t.length();j++)&#123;<br>                <span class="hljs-keyword">if</span> (s.charAt(i+j)!=t.charAt(j))&#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果与mihoyo相等，则记录m的位置</span><br>            <span class="hljs-keyword">if</span> (flag==<span class="hljs-literal">true</span>)&#123;<br>                l.add(i);<br>                i = i+<span class="hljs-number">5</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果所有mihoyo出现的位置小于要所要求的k则直接输出-1</span><br>        <span class="hljs-keyword">if</span> (l.size()&lt;k) &#123;<br>            System.out.println(-<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//比较哪k个mihoyo的字符数最少</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//用于存储第一位位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> l.get(k-<span class="hljs-number">1</span>)-l.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//k个mihoyo的长度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k;i&lt;l.size();i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tlen</span> <span class="hljs-operator">=</span> l.get(i)-l.get(i-k+<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">//选出最小的长度</span><br>                <span class="hljs-keyword">if</span> (tlen&lt;=len)&#123;<br>                    index = i-k+<span class="hljs-number">1</span>;<br>                    len = tlen;<br>                &#125;<br>            &#125;<br>            System.out.println(l.get(index)+<span class="hljs-string">&quot; &quot;</span>+(l.get(index+k-<span class="hljs-number">1</span>)+<span class="hljs-number">5</span>));<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="算法题2"><a href="#算法题2" class="headerlink" title="算法题2"></a>算法题2</h1><p>一个人内心有个正整数 X，有 n 个人过来猜，这个人会对猜的结果进行统计， </p><p> 有 a 个人的结果 &gt;&#x3D; X，有 b 个人的结果 &lt; X </p><p> 问这个数 X 有多少种可能的解决方法，如果无穷，输出 “infinity”</p><p><strong>输入：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span>（猜谜的人数）<br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span>（每个人猜的数字）<br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span>（a，b）<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> mihoyo;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> arr[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            arr[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">//&gt;=</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scanner.nextInt();  <span class="hljs-comment">//&lt;</span><br>        <span class="hljs-comment">//排序</span><br>        Arrays.sort(arr);<br>        <span class="hljs-keyword">if</span> (b==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//只有等于的，所以方案数就是0-(arr[0]-1),也就是arr[0]个</span><br>            System.out.println(arr[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//全部都是小于该数，则该数的方案数是无穷多个</span><br>            System.out.println(<span class="hljs-string">&quot;infinity&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//除上述两个特殊情况之外，判断方案数</span><br>        <span class="hljs-comment">//方案数等于：（大于该数的第一个数也就是小于该数的最后一个的后面一个）到（小于该数的最后一个数）</span><br>        <span class="hljs-comment">//例如：2，6，10，12</span><br>        <span class="hljs-comment">//如果小于和大于都是2 和 2 则该数的可能为6到10 种情况</span><br>        <span class="hljs-comment">//如果小于个数为1，大于个数为3，则该数可能为2到6 种情况</span><br>        <span class="hljs-comment">//如果小于个数为3，大于个数为1.则该数可能为10到12种情况</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> arr[b-<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> arr[b];<br>        <span class="hljs-keyword">if</span> (left!=right) &#123;<br>            System.out.println(right - left);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(-<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="算法题3"><a href="#算法题3" class="headerlink" title="算法题3"></a>算法题3</h1><p>有一棵树(没说是不是<a href>二叉树</a>)有 N 个节点。如果相邻两个节点同奇数或同偶数，则认为是同一个连通分量，否则不同的连通分量。<br> 根据此条件，可以获得每个子树的连通分量个数。打印所有子树连通分量个数的和。<br>   3<br> &#x2F;  \<br> 4   1<br>   &#x2F;   \<br>   2     5 </p><p> 例如，3-1-5是同一个连通分量，其余各自是一个连通分量。 </p><p> 1、2、3、4、5子树连通分量个数分别为 2、1、3、1、1，总和为 8</p><p><strong>输入：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span>（节点总数，根节点）<br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span>（节点<span class="hljs-number">1</span>和节点<span class="hljs-number">2</span>有一条边相连）<br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8（所有子树连通块之和）<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>某节点为根的子树的贡献 &#x3D; 所有子树贡献和 - 与该节点奇偶性相同的子节点数量。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">static</span> Map&lt;Integer, Integer&gt; map;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> ret;<br>    <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; l;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> vis[];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        vis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>];<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        ret = <span class="hljs-number">0</span>;<br><br>        l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>            l.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n-<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sc.nextInt();<br>            l.get(a).add(b);<br>            l.get(b).add(a);<br>        &#125;<br><br>        dfs(root);<br>        System.out.println(ret);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> &#123;<br>        List&lt;Integer&gt; childs = l.get(pos);<br>        vis[pos] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 当前节点是一个连通分量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> child: childs)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[child])&#123;<br>                <span class="hljs-comment">// 获取 child 的连通分量</span><br>                tmp += dfs(child);<br>                <span class="hljs-comment">// 如果同奇偶，则连通分量个数-1</span><br>                <span class="hljs-keyword">if</span>(child % <span class="hljs-number">2</span> == pos%<span class="hljs-number">2</span>) &#123;<br>                    tmp -=<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ret += tmp;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
      <category>米哈游</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树展开为链表</title>
    <link href="/2022/09/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/09/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h1><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="/2022/09/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/flaten.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：<strong>递归</strong></h2><p><strong>通过递归的方法，对树进行前序遍历，存入到list中，遍历list。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//前序遍历</span><br>        first(root,list);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-comment">//遍历list，展开为链表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> list.get(i-<span class="hljs-number">1</span>),right = list.get(i);<br>            temp.left = <span class="hljs-literal">null</span>;<br>            temp.right = right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">(TreeNode root,List&lt;TreeNode&gt; list)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>            list.add(root);<br>            first(root.left,list);<br>            first(root.right,list);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//迭代</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>                list.add(root);<br>                stack.add(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> list.get(i-<span class="hljs-number">1</span>),right = list.get(i);<br>            t.left = <span class="hljs-literal">null</span>;<br>            t.right = right;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：在进行前序遍历的同时进行展开"><a href="#解法三：在进行前序遍历的同时进行展开" class="headerlink" title="解法三：在进行前序遍历的同时进行展开"></a>解法三：在进行前序遍历的同时进行展开</h2><p><img src="/2022/09/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/image-20220910141634715.png" alt="image-20220910141634715"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//在进行前序遍历的同时进行展开</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">null</span>) stack.push(root);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-keyword">if</span> (pre!=<span class="hljs-literal">null</span>)&#123;<br>                pre.left = <span class="hljs-literal">null</span>;<br>                pre.right = current;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current.right!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> current.right;<br>                stack.push(right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current.left!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> current.left;<br>                stack.push(left);<br>            &#125;<br>            pre = current;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法四：不利用前序遍历，用寻找前驱节点"><a href="#解法四：不利用前序遍历，用寻找前驱节点" class="headerlink" title="解法四：不利用前序遍历，用寻找前驱节点"></a>解法四：不利用前序遍历，用寻找前驱节点</h2><p><img src="/2022/09/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/image-20220910142357003.png" alt="image-20220910142357003"></p><p><img src="/2022/09/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/image-20220910142523751.png" alt="image-20220910142523751"></p><p><img src="/2022/09/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/image-20220910142706338.png" alt="image-20220910142706338"></p><p><img src="/2022/09/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/image-20220910142715297.png" alt="image-20220910142715297"></p><p><img src="/2022/09/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/image-20220910142727633.png" alt="image-20220910142727633"></p><p>​具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-comment">//不利用前序遍历，用寻找前驱节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (cur.left!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> cur.left;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> left;<br>                <span class="hljs-keyword">while</span> (pre.right!=<span class="hljs-literal">null</span>)&#123;<br>                    pre = pre.right;<br>                &#125;<br>                pre.right = cur.right;<br>                cur.left = <span class="hljs-literal">null</span>;<br>                cur.right = left;<br>            &#125;<br>            cur = cur.right;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从中序和后序构造二叉树</title>
    <link href="/2022/09/08/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/09/08/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="从中序和后序构造二叉树"><a href="#从中序和后序构造二叉树" class="headerlink" title="从中序和后序构造二叉树"></a>从中序和后序构造二叉树</h1><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><p><strong>示例 1:</strong></p><p><img src="/2022/09/08/%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/tree.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：inorder = <span class="hljs-string">[9,3,15,20,7]</span>, postorder = <span class="hljs-string">[9,15,7,20,3]</span><br>输出：<span class="hljs-string">[3,9,20,null,null,15,7]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：inorder = <span class="hljs-comment">[-1]</span>, postorder = <span class="hljs-comment">[-1]</span><br>输出：<span class="hljs-comment">[-1]</span><br></code></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>与从中序和前序遍历构造二叉树的代码相似，参考那个即可。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> inorder.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            map.put(inorder[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> myBuildTree(inorder,postorder,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder,<span class="hljs-type">int</span> inl,<span class="hljs-type">int</span> inr,<span class="hljs-type">int</span> postl,<span class="hljs-type">int</span> postr)</span>&#123;<br>        <span class="hljs-keyword">if</span> (inl&gt;inr) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (postr&lt;postl) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//找到中序遍历中节点的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index_root</span> <span class="hljs-operator">=</span> map.get(postorder[postr]);<br><br>        <span class="hljs-comment">//构造根节点</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(postorder[postr]);<br><br>        <span class="hljs-comment">//右子树的数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size_right</span> <span class="hljs-operator">=</span> inr-index_root;<br><br><br>        <span class="hljs-comment">//左</span><br>        root.left = myBuildTree(inorder,postorder,inl,index_root-<span class="hljs-number">1</span>,postl,postr-size_right-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//右</span><br>        root.right = myBuildTree(inorder,postorder,index_root+<span class="hljs-number">1</span>,index_root+size_right,postr-size_right,postr-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从前序和中序构造二叉树</title>
    <link href="/2022/09/08/%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/09/08/%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="从前序和中序构造二叉树"><a href="#从前序和中序构造二叉树" class="headerlink" title="从前序和中序构造二叉树"></a>从前序和中序构造二叉树</h1><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是<strong>二叉树的先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: preorder = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>], inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]<br>输出: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: preorder = [-<span class="hljs-number">1</span>], inorder = [-<span class="hljs-number">1</span>]<br>输出: [-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="解法-递归"><a href="#解法-递归" class="headerlink" title="解法 递归"></a>解法 递归</h2><p>对于任意一颗树而言，前序遍历的形式总是</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[ 根节点, <span class="hljs-comment">[左子树的前序遍历结果]</span>, <span class="hljs-comment">[右子树的前序遍历结果]</span> ]</span><br></code></pre></td></tr></table></figure><p>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[ <span class="hljs-comment">[左子树的中序遍历结果]</span>, 根节点, <span class="hljs-comment">[右子树的中序遍历结果]</span> ]</span><br></code></pre></td></tr></table></figure><p>只要我们在中序遍历中<strong>定位</strong>到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有<strong>左右括号</strong>进行定位。</p><p>这样以来，<strong>我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置</strong></p><p><img src="/2022/09/08/%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/fe215cdc993b06a2eeca7939ac04d370f3fe725e7e568e6ced17d1757020be9f-105-1.png" alt="105-1.png"></p><p><img src="/2022/09/08/%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/1c96c49acdd0e51b195dd5916526291f23897f77cea700ea89aa81a4a900a6d7-image.png" alt="image.png"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;inorder.length;i++)&#123;<br>            map.put(inorder[i],i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> preorder.length;<br>        <span class="hljs-keyword">return</span> myBuildTree(preorder,inorder,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder,<span class="hljs-type">int</span> prel,<span class="hljs-type">int</span> prer,<span class="hljs-type">int</span> inl,<span class="hljs-type">int</span> inr)</span>&#123;<br>        <span class="hljs-keyword">if</span> (prel&gt;prer) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//在中序遍历中定位根节点</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">root_index</span> <span class="hljs-operator">=</span> map.get(preorder[prel]);<br>        <span class="hljs-comment">// 先把根节点建立出来</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[prel]);<br>        <span class="hljs-comment">//得到左子树中的节点数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size_left</span> <span class="hljs-operator">=</span> root_index-inl;<br><br>        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span><br>        root.left = myBuildTree(preorder,inorder,prel+<span class="hljs-number">1</span>,prel+size_left,inl,root_index-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span><br>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span><br>        root.right = myBuildTree(preorder,inorder,prel+size_left+<span class="hljs-number">1</span>,prer,root_index+<span class="hljs-number">1</span>,inr);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql高级</title>
    <link href="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/"/>
    <url>/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-存储引擎架构了解吗？"><a href="#MySQL-存储引擎架构了解吗？" class="headerlink" title="MySQL 存储引擎架构了解吗？"></a>MySQL 存储引擎架构了解吗？</h1><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><p><strong>存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法</strong>。</p><ol><li>所以我们用SQL语句对数据进行操作，好像是我们的SQL语句对数据进行了直接操作，但是呢，本质上是通过存储引擎来真正对数据进行操作。</li><li>存储引擎把怎么对数据操作什么的都封装好了，SQL语句更像是一个接口！你不用管存储引擎内部到底是怎样实现的，你只要会用SQL语句就好了！</li></ol><h1 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h1><ul><li><p><strong>第一范式</strong></p><p>第一范式的目标是确保每列的原子性:<strong>如果每列都是不可再分的最小数据单元</strong>（也称为最小的原子单元），则满足第一范式（1NF）  </p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908124314451.png" alt="image-20220908124314451"></p></li><li><p><strong>第二范式</strong></p><p>满足第一范式，表中非主键列不存在对主键的部分依赖  （<strong>也就是第二范式要求每个表只描述一件事情</strong>  ）</p><p><strong>什么叫“部分依赖”：</strong></p><p>如果确定一个表中的某个数据组合（A，B），则就可以确定该表中的其他另一个数据（C），则我们说：C依赖于（A，B）（此时A，B通常就是做出主键）。</p><p>但：如果某个数据D，它只依赖于数据A，或者说，A一确定，则D也可以确定，此时我们就称为“数据D部分依赖于数据A——可见部分依赖是指某个非主键字段，依赖于联合主键字段的其中部分字段。</p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210220122011873.png" alt="img"></p><p>学生和课程作为联合主键，第二范式的要求非主键字段必须完全依赖主键，所以上表中，学分是依赖课程的，成绩和依赖学生的。要进行修改：</p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210220122426319.png" alt="img"></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2021022012244740.png" alt="img"></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210220122538388.png" alt="img"></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908124511218.png" alt="image-20220908124511218"></p></li><li><p><strong>第三范式</strong></p><p>满足第一和第二范式，<strong>不存在对非主键列的传递依赖</strong>  ，非主键的属性对主键都是直接依赖，而不是间接依赖</p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908124619358.png" alt="image-20220908124619358"></p></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><a href="https://www.jb51.net/article/257835.htm">https://www.jb51.net/article/257835.htm</a></p><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是对数据库表中的一列或多列的值进行排序的一种数据结构，使用索引可以快速访问数据表中的特定信息。</p><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><p><strong>优点</strong> ：</p><ul><li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221005221522286.png" alt="image-20221005221522286"></p><p>但是hash算法存在hash冲突问题,也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。</p><p><strong>为什么MySQL 没有使用hash表这个数据结构呢？</strong></p><p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p><p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a><strong>B+树索引</strong></h3><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309560640.png" alt="img"></p><ul><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个单向链表。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul><h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>哈希索引一般用于精确等值查询但不支持排序，B+树用于精确等值查询之外的查询（范围查询and模糊查询等）。</p><h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><p><strong>区别：</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p><strong>B树索引</strong></p><ul><li>B树中的内部节点和叶子节点均存放键和值，而B+树的内部节点只有键没有值，叶子节点存放所有的键和值。</li><li>B+树的叶子节点相连，方便顺序检索</li></ul><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221006121109983.png" alt="image-20221006121109983"></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221006121114693.png" alt="image-20221006121114693"></p><h2 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908115444190.png" alt="image-20220908115444190"></p><h2 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908120042584.png" alt="image-20220908120042584"></p><h2 id="什么是聚簇索引，什么是非聚簇索引"><a href="#什么是聚簇索引，什么是非聚簇索引" class="headerlink" title="什么是聚簇索引，什么是非聚簇索引"></a>什么是聚簇索引，什么是非聚簇索引</h2><p><strong>聚簇索引：</strong>将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。</p><p><strong>非聚簇索引</strong>：将数据和索引分开存储，索引叶子节点存储的是指向数据行的地址。（叶子节点存储的是主键）</p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309560646.jpg" alt="img"></p><p><strong>也就是说通过非聚簇索引找到主键，再通过聚簇索引找到主键对应的数据。</strong></p><p><strong>当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309560647.jpg" alt="img"></p><ul><li>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</li><li>最终拿到这一行的数据，直接返回即可。</li></ul><blockquote><p> 回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p></blockquote><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908120558009.png" alt="image-20220908120558009"></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908120605893.png" alt="image-20220908120605893"></p><h2 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908121149094.png" alt="image-20220908121149094"></p><h2 id="索引在什么情况下会失效"><a href="#索引在什么情况下会失效" class="headerlink" title="索引在什么情况下会失效"></a>索引在什么情况下会失效</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908123400865.png" alt="image-20220908123400865"></p><h2 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h2><ul><li>选择唯一性索引： 唯一性索引一般基于 Hash 算法实现， 可以快速、唯一地定位某条数据。</li><li>为经常需要排序、分组和联合操作的字段建立索引。</li><li>为常作为查询条件的字段建立索引。</li><li>限制索引的数量：索引越多，数据更新表越慢，因为在数据更新时会不断计算和添加索引。</li><li>尽量使用数据量少的索引：如果索引的值很长，则占用的磁盘变大，查询速度会受到影响。</li><li>尽量使用前缀来索引：如果索引字段的值过长， 则不但影响索引的大小，而且会降低索引的执行效率， 这时需要使用字段的部分前缀来作为索引。</li><li>删除不再使用或者很少使用的索引。</li><li>尽量选择区分度高的列作为索引：区分度表示字段值不重复的比例。</li><li>索引列不能参与计算：带函数的查询不建议参与索引。</li><li>尽量扩展现有索引： 联合索引的查询效率比多个独立索引高。</li></ul><h2 id="索引举例"><a href="#索引举例" class="headerlink" title="索引举例"></a>索引举例</h2><ul><li>创建表<code>test_table1</code>,并分别是在<code>id</code>字段上名称为<code>uniqidx</code>的唯一索引；在<code>name</code>和<code>address</code>字段上的组合索引；在<code>description</code>字段上长度为30的普通索引。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table test_table1    -&gt; (<br><br>    -&gt; id int not null primary key auto_increment,<br><br>    -&gt; name char(100) not null,<br><br>    -&gt; address char(100) not null,<br><br>    -&gt; description char(100) not null,<br><br>    -&gt; unique index uniqidx(id),<br><br>    -&gt; index MultiColidx(name(20),address(30) ),<br><br>    -&gt; index Comidx(description(30));<br></code></pre></td></tr></table></figure><ul><li>创建表test_table2，存储引擎为MyISAM</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table test_table2    -&gt; (<br><br>    -&gt; id int not null primary key auto_increment,<br><br>    -&gt; firstname char(100) not null,<br><br>    -&gt; middlename char(100) not null,<br><br>    -&gt; lastname char(100) not null,<br><br>    -&gt; birth date not null,<br><br>    -&gt; title char(100) null<br><br>    -&gt; )ENGINE=MyISAM;<br></code></pre></td></tr></table></figure><ul><li>使用alter table 语句在表test_table2的birth字段上建立名称为ComDateIdx的普通索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table test_table2 add index ComDateidx(birth);<br></code></pre></td></tr></table></figure><ul><li>使用alter table语句在表test_table2的id字段上添加名称为Uniqidx2的唯一索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table test_table2 add unique index Uniqidx(id);<br></code></pre></td></tr></table></figure><ul><li>使用create index 在firstname和middlename两个字段上建立名称为 MultiColidx2的组合索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index MultiColidx2 on test_table2(firstname,middlename);<br></code></pre></td></tr></table></figure><ul><li>使用create index在title字段上建立名称为FTidx的全文索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create fulltext index ftidx on test_table2(title);<br></code></pre></td></tr></table></figure><ul><li>使用alter table语句删除表test_table1中名称为Uniqidx的唯一索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table test_table1 drop index uniqidx;<br></code></pre></td></tr></table></figure><ul><li>使用drop index语句删除表test_table2中名称为MultiColidx2的组合索引</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop index MultiColidx2 on test_table2;<br></code></pre></td></tr></table></figure><h2 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h2><p><strong>对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。</strong></p><p><strong>注意： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</strong></p><p>下面以一个表的例子进行展示，查询表中的索引，看是否有联合索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show index from tb_user<br></code></pre></td></tr></table></figure><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140105574.png" alt="image-20221126140105574"></p><p><strong>（1）符合最左原则，成功！红框中的是联合索引，最左边的列是profession，因此下面的查询都是有效的：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27;;<br>explain select * from tb_user where profession = &#x27;软件工程&#x27; and age = 31;<br>explain select * from tb_user where profession = &#x27;软件工程&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140422974.png" alt="image-20221126140422974"></p><p><strong>（2）不符合最左原则，失败！如果profession列没有用到的时候，则索引失效</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_user where age = 31 and status = &#x27;0&#x27;;<br>explain select * from tb_user where status = &#x27;0&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140549906.png" alt="image-20221126140549906"></p><p><strong>（3）跨列查询</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_user where profession = &#x27;软件工程&#x27; and status = &#x27;0&#x27;;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140922771.png" alt="image-20221126140922771"></p><p><strong>根据索引使用的长度，索引的部分生效，只用到了profession列的部分</strong></p><p><strong>思考：如果顺序不同的话是否可以执行索引，答案是：可以！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">explain select * from tb_user <span class="hljs-type">where</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-type">and</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-type">and</span> <span class="hljs-variable">profession</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126141104785.png" alt="image-20221126141104785"></p><p><strong>出现 &gt; 或 &lt; 时，&gt;或&lt;的列失效，其他的不是失效</strong></p><p><strong>mysql8的时候，如果条件语句中有or，并且两边都有索引，则走索引，否则失效。而mysql5无论两边是否有索引，出现or就会失效</strong></p><p><strong>对于is null 和 is not null，按照情况说是否走索引，会判断走索引块还是查询表块</strong></p><h2 id="Using-where-和-Using-index"><a href="#Using-where-和-Using-index" class="headerlink" title="Using where 和 Using index"></a>Using where 和 Using index</h2><p><strong>Using where和USing index：</strong>查找使用到了索引，需要的数据都能在索引列中找到，不需要回表查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id, profession from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27; ;<br></code></pre></td></tr></table></figure><p><strong>Using index</strong>：使用覆盖索引的时候就会生效。</p><p><strong>using index condition：</strong>查找使用了索引，不需要回表查询，因为要过滤的字段在索引中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id,profession,age, status, name from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27; ;<br></code></pre></td></tr></table></figure><p><strong>Using Where</strong>：在查找使用索引的情况下，需要回表去查询所需的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_user where age = 31 and name=&#x27;zw&#x27;; #删除了name的索引<br></code></pre></td></tr></table></figure><p>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p><p>执行SQL : <code>select * from tb_user where id = 2;</code></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309561197.jpg" alt="img"></p><p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><p>执行SQL：<code>selet id,name from tb_user where name = &#39;Arm&#39;;</code></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309561198.jpg" alt="img"></p><p>执行SQL：<code>selet id,name,gender from tb_user where name = &#39;Arm&#39;;</code></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309561199.jpg" alt="img"></p><p><strong>思考题：</strong> 一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对以下SQL语句进行优化, 该如何进行才是最优方案:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>id,username,<span class="hljs-symbol">``</span><span class="hljs-keyword">password</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span>tb_user <span class="hljs-symbol">``</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>username =<span class="hljs-symbol">``</span><span class="hljs-string">&#x27;zhangsan&#x27;</span><span class="hljs-symbol">``</span>;<br></code></pre></td></tr></table></figure><p>答案: 针对于 username, password建立联合索引, sql为:<br><code>create index idx_user_name_pass on tb_user(username,password);</code><br>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。</p><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>当字段类型为字符串（varchar，text，longtext等）时，<strong>有时候需要索引很长的字符串，这会让索引变得很大</strong>，查询时，浪费大量的磁盘IO， 影响查询效率。<strong>此时可以只将字符串的一部分前缀，建立索引</strong>，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(column(n)) ;</code></p><p>实例：</p><p><code>create index idx_email_5 on tb_user(email(5));</code></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126145423129.png" alt="image-20221126145423129"></p><p><strong>查询流程：</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20220803095611101.jpg" alt="img"></p><h2 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h2><ul><li><p>单列索引：即一个索引只包含单个列。</p></li><li><p>联合索引：即一个索引包含了多个列。</p><p><strong>如果查询条件存在两个单列索引的话，只能用到一个索引并进行回表查询，</strong></p><p><strong>但创建联合索引后，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。</strong></p></li></ul><p><strong>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20220803095612105.jpg" alt="img"></p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p> 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。说白了就是避免回表查询</p><h1 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a>事务篇</h1><h2 id="什么是数据库事务"><a href="#什么是数据库事务" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h2><p>数据库事务执行一系列基本操作，这些基本操作组成一个逻辑工作单元一起向数据库提交，要么都执行，要么都不执行。事务是一个不可分割的工作逻辑单元。  </p><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><ul><li><strong>原子性</strong>：包含事务的操作要么全部执行成功，要么全部失败执行回滚</li><li><strong>一致性</strong>：事务在执行前后状态是一致的</li><li><strong>隔离性</strong>：并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；  </li><li><strong>持久性</strong>：⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</li></ul><h2 id="数据库并发一致性问题"><a href="#数据库并发一致性问题" class="headerlink" title="数据库并发一致性问题"></a>数据库并发一致性问题</h2><p>当多个事务并发执行时，会出现以下问题：</p><ul><li><strong>脏读</strong>：事务A更新了数据，但没有提交，事务B读取了事务A更新的数据，然后事务A进行回滚，则数据B读到的数据为脏读数据。</li><li><strong>不可重复读取</strong>：事务A对数据进行多次读取，事务B在事务A的多次读取中，更新了数据并提交，导致事务A多次读取到数据的数据不一致。</li><li><strong>幻读</strong>：事务A读取了数据库中的数据后，事务B向事务A中插入了几行数据，事务A再次读取数据时发现多了几条数据，和之间读取的数据不一致。</li><li><strong>丢失修改</strong>：事务A和事务B对同一个数据进行修改，事务A 先修改随后事务B再修改覆盖了事务A的修改。</li></ul><h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><p><strong>数据库的隔离级别可以解决数据库的脏读、幻读、不可重复读的问题</strong></p><ul><li><strong>未提交读</strong>：一个事务在提交之前，它的修改对其他事务也是可见的。  </li><li><strong>提交读</strong>：一个事务提交之后，才可能被其他事务看到。</li><li><strong>可重复读</strong>：同一事务中多次读取到的数据是一致的</li><li><strong>串行化</strong>：加锁实现，事务串行执行</li></ul><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908130942497.png" alt="image-20220908130942497"></p><h2 id="Mysql的默认隔离级别：可重复读是怎么实现的"><a href="#Mysql的默认隔离级别：可重复读是怎么实现的" class="headerlink" title="Mysql的默认隔离级别：可重复读是怎么实现的"></a>Mysql的默认隔离级别：可重复读是怎么实现的</h2><p>InnoDB是通过维护两个隐藏列来实现mvcc，隐藏列记录了数据行<strong>创建版本号</strong>和<strong>删除版本号</strong></p><p><strong>mvcc在可重复读级别下的具体实现：</strong></p><ul><li><p>查询：需要满足两个条件，</p><ul><li>创建版本号小于等于当前事务的版本号，这样可以保证查询到的数据是事务开始之前就已经存在的，或者由该事务创建和修改的。</li><li>删除版本号要大于等于当前事务的版本号，可以保证在该事务之前是存在的。</li></ul></li><li><p>插入：插入的每条数据将创建版本号与该事务的版本号一致。</p></li><li><p>删除：删除每条数据，要将删除版本号与该事务版本号一致。</p></li><li><p>修改：将创建版本号修改为事务版本号，将删除版本号修改为事务版本号。</p></li></ul><h1 id="数据的锁"><a href="#数据的锁" class="headerlink" title="数据的锁"></a>数据的锁</h1><h2 id="什么是数据库的锁"><a href="#什么是数据库的锁" class="headerlink" title="什么是数据库的锁"></a>什么是数据库的锁</h2><p>有并发事务时，保证事务的访问顺序机制是锁机制</p><h2 id="数据库锁的类型"><a href="#数据库锁的类型" class="headerlink" title="数据库锁的类型"></a>数据库锁的类型</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908131726920.png" alt="image-20220908131726920"></p><h2 id="数据库的乐观锁和悲观锁"><a href="#数据库的乐观锁和悲观锁" class="headerlink" title="数据库的乐观锁和悲观锁"></a>数据库的乐观锁和悲观锁</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908132425625.png" alt="image-20220908132425625"></p><h2 id="MySql锁"><a href="#MySql锁" class="headerlink" title="MySql锁"></a>MySql锁</h2><h3 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h3><p><strong>MyISAM 仅仅支持表级锁</strong>(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。</p><p><strong>InnoDB 不光支持表级锁</strong>(table-level locking)，<strong>还支持行级锁(row-level locking)，默认为行级锁。</strong>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高.</p><p><strong>表级锁和行级锁对比</strong> ：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，<strong>是针对非索引字段加的锁，对当前操作的整张表加锁,其锁定粒度最大</strong>，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，<strong>是针对索引字段加的锁，只针对当前操作的行记录进行加锁</strong>。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong> ：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p><strong>手动加锁:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 共享锁<br>SELECT ... LOCK IN SHARE MODE;<br># 排他锁<br>SELECT ... FOR UPDATE;<br></code></pre></td></tr></table></figure><h3 id="意向共享锁和意向排他锁"><a href="#意向共享锁和意向排他锁" class="headerlink" title="意向共享锁和意向排他锁"></a>意向共享锁和意向排他锁</h3><ul><li><strong>意向共享锁（IS）：</strong>当需要对数据加行级读锁时，会像整个表加意向读锁。</li><li><strong>意向排他锁（IX）：</strong>当需要对数据加行级写锁时，会像整个表加意向写锁。</li></ul><p><strong>为什么要加入意向锁：</strong>为了告诉你当前表中已经有了共享锁&#x2F;排他锁，就没有必要加表锁了，起到一个标识的作用，提高表锁的效率。</p><p>如果需要对表加锁的时候，可以快速遍历表是否有行锁，避免用遍历的方式检查是否上行锁。</p><ul><li>如果意向锁是行锁，则需要遍历每一行数据去确认；</li><li>如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。</li></ul><h1 id="MySQL的三大日志"><a href="#MySQL的三大日志" class="headerlink" title="MySQL的三大日志"></a>MySQL的三大日志</h1><p>mysql比较重要的三大日志为:<strong>二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</strong></p><h2 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a><code>redo log</code>（重做日志）</h2><p>是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p><p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p><p>记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p><h2 id="bin-log-归档日志"><a href="#bin-log-归档日志" class="headerlink" title="bin log(归档日志)"></a><code>bin log</code>(归档日志)</h2><p> <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p><h1 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h1><p>Sql中in包含的值不应该过多</p><p>SELECT语句务必指明字段名称</p><p>当只需要一条数据的时候，使用limit 1</p><p>如果限制条件中其他字段没有索引，尽量少用or</p><p>尽量用union all代替union</p><p>避免在where子句中对字段进行null值判断</p><p>不建议使用%前缀模糊查询</p><p>避免在where子句中对字段进行表达式操作</p><p>禁止使用 order by rand() 进行随机排序</p><h1 id="Mysql的执行流程"><a href="#Mysql的执行流程" class="headerlink" title="Mysql的执行流程"></a>Mysql的执行流程</h1><h2 id="Mysql基础架构分析"><a href="#Mysql基础架构分析" class="headerlink" title="Mysql基础架构分析"></a>Mysql基础架构分析</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/13526879-3037b144ed09eb88.png" alt="img"></p><p><strong>Server层：</strong>所有跨存储引擎的功能都在这层实现，比如存储过程，触发器，函数等，还有一个通用的binlog模块。</p><p><strong>存储引擎：</strong>支持多个引擎（InnoDB、MyISAM、Memory）。其中InnoDB引擎有自由的redolog模块。</p><p><strong>下面解释Server层里面的组件：</strong></p><ul><li><p><strong>连接器：</strong>主要和身份认证和权限相关，主要负责登录数据库，用户身份验证，权限等操作。如果用户名和密码通过，连接器会到权限表中查询该用户的权限（一直到断开，权限都是相同的）。</p></li><li><p><strong>查询缓存：</strong>在Mysql8.0之后就取消了这个组件，因为很少去用，它主要就是查询数据的时候，以 Key-Value 的形式缓存在内存中，会先在查询缓存中查询，如果查到则直接返回，否则执行后序的操作，并且也会存储到查询缓存中。</p><ul><li><strong>MySQL 查询不建议使用缓存，</strong>因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</li></ul></li><li><p><strong>分析器：</strong>分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p><ul><li>词法分析：提取关键字，提出查询的表，提出字段名，提出查询条件等。</li><li>语法分析：主要是判断输入的SQL是否正确</li></ul></li><li><p><strong>优化器：</strong>选择最优的执行方案去执行（比如有多个条件的时候，先执行哪个条件）</p></li><li><p><strong>执行器：</strong>选择执行方案后，开始执行，校验用户有没有权限，如果没有则返回错误，如果有则调用引擎接口，返回执行结果。</p></li></ul><h2 id="查询语句分析"><a href="#查询语句分析" class="headerlink" title="查询语句分析"></a>查询语句分析</h2><p><strong>分析下面这条查询语句：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from tb_student  A where A.age=&#x27;18&#x27; and A.name=&#x27; 张三 &#x27;;<br></code></pre></td></tr></table></figure><p><strong>权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</strong></p><p>（1）先检查语句是否有权限，Mysql8.0之前先查询缓存，有直接返回，没有接着执行。</p><p>（2）通过分析器进行语法分析，提取上面的select，查询表名为tb_student，需要查询所有的列，查询条件是什么，然后判断是否有语法错误，如果没有则下一步</p><p>（3）接下来就是优化器，可能有以下两种方案，优化器选择一个效率最高的方案进行执行，</p><blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。<br>b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。<br></code></pre></td></tr></table></figure></blockquote><p>（4）权限校验，如果没有权限则返回错误，如果有权限，则调用引擎接口，返回引擎结果。</p><h2 id="更新语句分析"><a href="#更新语句分析" class="headerlink" title="更新语句分析"></a>更新语句分析</h2><p><strong>分析下面这条更新语句：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update tb_student A set A.age=&#x27;19&#x27; where A.name=&#x27; 张三 &#x27;;<br></code></pre></td></tr></table></figure><p>在更新的时候要引入日志模块，Mysql自带的日志模块是bin log（归档日志），InnoDB引擎还引入了一个自带的日志模块 redo log（重做日志）</p><p><strong>分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</strong></p><p>（1）通过分析器进行语法分析，更新操作，操作哪张表，条件是什么，检查有没有语法错误。</p><p>（2）权限校验，如果没有权限则返回错误信息，如果有权限则调用引擎接口执行。</p><p>（3）调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</p><p>（4）执行器收到通过后记录bin log，然后调用引擎接口，提交redo log为提交状态。</p><p>（5）更新完成</p><h2 id="为什么同时用redo-log和bin-log"><a href="#为什么同时用redo-log和bin-log" class="headerlink" title="为什么同时用redo log和bin log"></a>为什么同时用redo log和bin log</h2><p><strong>redo log</strong>是InnoDB特有的，它有一个特殊的功能：<strong>如果数据库发生异常重启，之前提交的记录都不会丢失。</strong></p><p>并不是说只用一个<code>bin log</code>日志不行，而是<strong>使用<code>redo log</code>来支持事务。</strong></p><p><strong>那如果说用两个日志，但不用这么复杂可不可以，没有<code>prepare</code>状态和提交状态？</strong></p><ul><li>**先写 <code>redo log</code> 直接提交，然后写 <code>binlog</code>**，假设写完 <code>redo log</code> 后，机器挂了，<code>binlog</code> 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li>**先写 <code>binlog</code>，然后写 <code>redo log</code>**，假设写完了 <code>binlog</code>，机器异常重启了，由于没有 <code>redo log</code>，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><blockquote><p> <strong>如果采用 <code>redo log</code> 两阶段提交的方式就不一样了，写完 <code>binlog</code> 后，然后再提交 <code>redo log</code> 就会防止出现上述的问题，从而保证了数据的一致性。</strong></p></blockquote><p><strong>假设 <code>redo log</code> 处于预提交状态，<code>binlog</code> 也已经写完了，这个时候发生了异常重启会怎么样呢？</strong>下面为Mysql的处理机制：</p><ul><li>判断 <code>redo log</code> 是否完整，如果判断是完整的，就立即提交。</li><li>如果 <code>redo log</code> 只是预提交但不是 <code>commit</code> 状态，这个时候就会去判断 <code>binlog</code> 是否完整，如果完整就提交 <code>redo log</code>, 不完整就回滚事务。</li></ul><p>这样就保证了数据的一致性。</p><h1 id="Mysql怎么保证事务的持久性"><a href="#Mysql怎么保证事务的持久性" class="headerlink" title="Mysql怎么保证事务的持久性"></a>Mysql怎么保证事务的持久性</h1><p><strong>利用了redo log</strong>。Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。</p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/03.png" alt="img"></p><p><code>redo log</code>包括两部分：一是内存中的日志缓冲(<code>redo log buffer</code>)，该部分日志是易失性的；二是磁盘上的重做日志文件(<code>redo log file</code>)，该部分日志是持久的。</p><p><code>innodb</code>通过<code>force log at commit</code>机制实现事务的持久性，即<strong>在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。也就是说提交了两个日志文件。</strong></p><p><strong>当事务提交的时候，会对redo log日志进行刷盘，当数据库挂掉重启的时候，会将redo log中的内存恢复到数据中，再根据undo log和bin log内容决定回滚数据还是提交数据。</strong></p><h1 id="Mysql怎么保证事务的原子性"><a href="#Mysql怎么保证事务的原子性" class="headerlink" title="Mysql怎么保证事务的原子性"></a>Mysql怎么保证事务的原子性</h1><p><strong>是利用<code>Innodb</code>的<code>undo log</code>。</strong><br><code>undo log</code>名为回滚日志，是实现原子性的关键，<strong>当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。</strong></p><p>例如:<br>(1)当你<code>delete</code>一条数据的时候，就需要记录这条数据的信息，回滚的时候，<code>insert</code>这条旧数据<br>(2)当你<code>update</code>一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行<code>update</code>操作<br>(3)当年<code>insert</code>一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行<code>delete</code>操<br><strong><code>undo log</code>记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</strong></p><h1 id="Mysql怎么保证事务的隔离性"><a href="#Mysql怎么保证事务的隔离性" class="headerlink" title="Mysql怎么保证事务的隔离性"></a>Mysql怎么保证事务的隔离性</h1><p><strong>有两种方法MVCC和LBCC保证事务的隔离性，至于到底使用的哪种，就看程序员的sql语句是怎样写的。</strong></p><h2 id="MVCC-Multi-Version-Concurrency-Control-多版本并发控制"><a href="#MVCC-Multi-Version-Concurrency-Control-多版本并发控制" class="headerlink" title="MVCC (Multi-Version Concurrency Control) 多版本并发控制."></a>MVCC (Multi-Version Concurrency Control) 多版本并发控制.</h2><blockquote><p> 建立一个快照，同一个事务无论查多少次都是一个结果。某一个事务第一次查询确认了快照之后，无论后面的事务插入数据，删除数据还是更新数据，都不会影响该事务的查询结果，只能看到最初建立快照时饿情况。</p></blockquote><p><strong>(1)MVCC的底层支持，InnoDB为每个表提供了三个隐藏的字段以及事务id和删除版本号的使用</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620160153106.png" alt="在这里插入图片描述"></p><p><strong>(2)MVCC的底层是read view（一致性视图）。</strong></p><p>不同的表类型生成的时机不同：</p><ul><li><p><strong>RR repeat read 可重复读:</strong> <code>read view</code> 是在事务第一次查询的时候建立（之后 <code>read view</code> 就不会变了）；</p></li><li><p><strong>RC read commit 已提交读:</strong> <code>read view</code> 是在事务每次查询的时候建立（每次查询都重新生成一个 <code>read view</code> ）；</p></li></ul><p><strong>(3)readview一致性视图的结构</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620161433980.png" alt="在这里插入图片描述"></p><p><strong>readview一致性视图的应用</strong></p><ul><li><p>对于某个事务<code>trx_id</code>，如果这个<code>trx_id=creator_trx_id</code>，表示这个<code>readview</code>就是这个<code>trx_id</code>创建的，自然可以访问这个<code>trx_id</code></p></li><li><p>对于某个事务<code>trx_id</code>，如果这个<code>trx_id&lt;min_trx_id</code>，表示这个<code>trx_id</code> 比最小的未提交的事务id还小，表示这个事务<code>id</code>是已提交的，自然可以访问这个<code>trx_id</code></p></li><li><p>对于某个事务<code>trx_id</code>，如果这个<code>trx_id&gt;max_trx_id</code>，表示这个<code>trx_id</code> 比最大的未提交的事务<code>id</code>还大，表示这个事务<code>id</code>是未提交的，自然不可以访问这个<code>trx_id</code></p></li><li><p>对于某个事务<code>trx_id</code>，如果这个<code>max_trx_id &gt; trx_id&gt;min_trx_id</code>，表示这个 <code>trx_id</code> 比在这个范围内，如果在 <code>m_ids</code> ,表示未提交，不可访问，如果不在 <code>m_ids</code> ，表示已提交，可以访问</p></li></ul><p><strong>（4）MVCC的局限</strong></p><p>只作用于RC和RR隔离级别。</p><p><strong>repeat read特点：</strong>只保存第一次查询的视图；<br><strong>repeat read优点：</strong>解决了幻读问题（第一次生成视图之后，不受 update&#x2F;insert&#x2F;delete 影响）；<br><strong>repeat read缺点：</strong>不能查询到最新的实时数据。</p><p><strong>MVCC的局限：</strong>对于RR repeat read 可重复读，只能保存第一次查询的视图，不能查询到最新的实时数据，要想实时查询到最新的实时数据，只能 LBCC ，就是加锁。</p><h2 id="LBCC-Lock-Base-Concurrency-Control-基于锁的并发控制"><a href="#LBCC-Lock-Base-Concurrency-Control-基于锁的并发控制" class="headerlink" title="LBCC(Lock-Base Concurrency Control)基于锁的并发控制."></a>LBCC(Lock-Base Concurrency Control)基于锁的并发控制.</h2><blockquote><p>使用加锁的方式来保证并发下数据的一致性，实现了事务隔离</p></blockquote><p><strong>（1）表锁到行锁</strong></p><p>表锁和行锁的区别：表锁粒度大，行锁效率高，行锁冲突概率小，行锁并发性能强，所以行锁优于表锁。</p><p><strong>（2）四种基本锁</strong></p><p>共享锁，独占锁，意向共享锁，意向独占锁。</p><blockquote><p>对于程序员给表加上行锁（读共享锁 写独占锁），<br>如果存在索引，锁住的索引，如果where条件中有索引列，仅锁住where条件命中的这一行或多行数据；如果where条件中没有索引列 或者 没有根本就没有where子句，会锁住整个表（连插入都插入不进去了 解决幻读问题）。<br>如果不存在索引，锁住的隐藏的rowid，此时会锁住整个表（连插入都插入不进去了 解决幻读问题）。</p></blockquote><p><strong>（3）三种高级锁</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620172422570.png" alt="在这里插入图片描述"></p><ul><li><p><strong>record记录锁</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620172534743.png" alt="在这里插入图片描述"></p></li><li><p><strong>间隙锁</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620172630964.png" alt="在这里插入图片描述"></p></li><li><p><strong>临键锁</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620173251235.png" alt="在这里插入图片描述"></p></li></ul><p><strong>（4）四种隔离级别的锁，哪种mvcc,哪种加锁</strong></p><blockquote><p>mvcc只有在RC RR中有，</p></blockquote><ul><li>在read uncommited(读未提交)啥都没有，没有锁，没有mvcc，</li><li>在rc（读已提交）里面，有mvcc，有锁，只有记录锁，没有间隙锁，所以无法解决幻读问题</li><li>在rr（可重复读）里面，有mvcc，有锁，有记录锁，有间隙锁，可以解决幻读问题</li><li>在serializable（串行化），只有锁，没有mvcc</li></ul><h1 id="mysql中explain"><a href="#mysql中explain" class="headerlink" title="mysql中explain"></a>mysql中explain</h1><p><strong>返回执行计划的信息</strong></p><blockquote><p>select语句前面加explain关键字，执行mysql就会返回执行计划的信息，而不是执行mysql。</p></blockquote><p><strong>exception中的列：</strong></p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2f768fa6e05f4d89ab95c3b27a2886d5.png" alt="img"></p><p><strong>（1）id：</strong>id列的编号是select的序列号，有几个select就有几个id</p><p><strong>（2）select_type：</strong>对应行的查询是简单查询还是复杂查询。</p><blockquote><p> simple：不包含子查询和union的简单查询</p></blockquote><blockquote><p>primary：复杂查询中的最外层的查询</p><p>subquery：包含在select中的子查询（不在from中的子句中，可以是where后的子查询）</p><p>derived：包含在from中的子查询</p></blockquote><p><strong>（3）table：</strong>表示当前行访问的是哪张表，</p><p><strong>（4）partitions：</strong>查询将匹配记录的分区，如果是非分区表，则为null。</p><p><strong>（5）type：</strong>表示访问类型，就是mysql如何查找表中的行，最优到最差：<code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。</code></p><blockquote><p>system：主键索引或者唯一索引，表中只有一条元组匹配时。</p><p>const：主键索引或者唯一索引上的等值查询。</p><p>eq_ref：命中主键索引或唯一索引join查询，等值连接，前表的每一行，后表只有一行命中。</p><p>ref：使用了普通索引，没有使用主键索引和唯一索引，可能有多行命中。</p><p>range：索引上的范围扫描，相比index的全文索引扫描有范围限制，因此要优于index。</p><p>index：扫描全部索引</p><p>all：全表扫描</p></blockquote><p><strong>（6）possible_keys：</strong>显示查询中可能用到的索引，如果为null，表示没有用到相关索引。</p><p><strong>（7）key：</strong>实际查询用到的索引，。</p><p><strong>（8）key_len：</strong>具体使用了索引的哪些列，索引中使用的字节数</p><p><strong>（9）ref：</strong>索引中使用到的列或者常量</p><p><strong>（10）row：</strong>mysql查询中估计要读取的行数</p><p><strong>（11）extra：</strong>额外的信息</p><h1 id="如何保证缓存与数据库的双写一致性？"><a href="#如何保证缓存与数据库的双写一致性？" class="headerlink" title="如何保证缓存与数据库的双写一致性？"></a>如何保证缓存与数据库的双写一致性？</h1><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。- 更新的时候，先更新数据库，然后再删除缓存。</p><p><strong>为什么是删除缓存，而不是更新缓存？</strong></p><p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存</p><p><strong>明确了是删除缓存后，目前存在两种选择:</strong></p><ul><li>先更新数据库，再删除缓存</li><li>先删除缓存，再更新数据库</li></ul><p><strong>（1）先更新数据库，再删除缓存</strong></p><p><strong>问题：</strong>更新数据库成功，线程出现问题，缓存删除失败，缓存中的是旧数据，数据不一致，有两种解决方式；<strong>失败重试</strong>和<strong>异步更新</strong></p><p><strong>失败重试：</strong>把删除的key放入到消息队中，从消息队列中进行删除，（有个缺点，首先会对业务代码造成入侵，其次引入了消息队列，增加了系统的不确定性。）</p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20224285758787.png" alt="MySQL和Redis的数据一致性问题_一致性问题_04"></p><p><strong>异步更新：</strong>因为更新数据库时会往 <code>binlog </code>中写入日志，所以我们可以启动一个监听 binlog变化的服务（比如使用阿里的 canal开源组件），然后在客户端完成删除 key 的操作。如果删除失败的话，再发送到消息队列。</p><p><strong>（2）先删除缓存，再更新数据库</strong></p><p><strong>问题：</strong>如果先删除Redis缓存数据，然而还没有来得及写入MySQL，另一个线程就来读取。这个时候发现缓存为空，则去Mysql数据库中读取旧数据写入缓存，此时缓存中为脏数据。出现了数据不一致的问题。可以采用<strong>延时双删</strong>的策略解决。</p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20224285758788.png" alt="MySQL和Redis的数据一致性问题_缓存_05"></p><p><strong>延时双删</strong>：就是更新数据库之后，再删除一次缓存。</p><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20224285758789.png" alt="MySQL和Redis的数据一致性问题_缓存_06"></p>]]></content>
    
    
    <categories>
      
      <category>Mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单词搜索</title>
    <link href="/2022/08/30/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/08/30/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h1><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="/2022/08/30/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/word2.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/08/30/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/word-1.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;SEE&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/2022/08/30/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/word3.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCB&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><ul><li><p>以<code>&quot;SEE&quot;</code>为例，首先要选起点：遍历矩阵，找到起点S。</p></li><li><p>起点可能不止一个，基于其中一个S，看看能否找出剩下的”EE”路径。</p></li><li><p>下一个字符E有四个可选点：当前点的上、下、左、右。</p></li><li><p>逐个尝试每一种选择。基于当前选择，为下一个字符选点，又有四种选择。</p></li><li><p>每到一个点做的事情是一样的。DFS 往下选点，构建路径。</p></li><li><p>当发现某个选择不对，不用继续选下去了，结束当前递归，考察别的选择。</p></li></ul><p><img src="/2022/08/30/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/1599959074-dSSwlm-image.png" alt="image.png"></p><h3 id="递归把握什么？"><a href="#递归把握什么？" class="headerlink" title="递归把握什么？"></a><strong>递归把握什么？</strong></h3><p>关注当前考察的点，处理它，其他丢给递归子调用去做。</p><ul><li>判断当前选择的点，本身是不是一个错的点。</li><li>剩下的字符能否找到路径，交给递归子调用去做。</li></ul><p>如果当前点是错的，不用往下递归了，返回false。否则继续递归四个方向，为剩下的字符选点。那么，<strong>哪些情况说明这是一个错的点：</strong></p><ol><li><p>当前的点，越出矩阵边界。</p></li><li><p>当前的点，之前访问过，不满足「同一个单元格内的字母不允许被重复使用」。</p></li><li><p>当前的点，不是目标点，比如你想找 E，却来到了 D。</p></li><li><p><img src="/2022/08/30/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/1599959104-OOyFVT-image.png" alt="image.png"></p></li></ol><h3 id="记录访问过的点"><a href="#记录访问过的点" class="headerlink" title="记录访问过的点"></a><strong>记录访问过的点</strong></h3><p>用一个二维矩阵 used，记录已经访问过的点，下次再选择访问这个点，就直接返回 false。</p><h3 id="为什么要回溯"><a href="#为什么要回溯" class="headerlink" title="为什么要回溯?"></a><strong>为什么要回溯?</strong></h3><p>有的选点是错的，选它就构建不出目标路径，不能继续选。要撤销这个选择，去尝试别的选择。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// canFindRest 表示：基于当前选择的点[row,col]，能否找到剩余字符的路径。</span><br>const canFindRest =<br>      can<span class="hljs-constructor">Find(<span class="hljs-params">row</span> + 1, <span class="hljs-params">col</span>, <span class="hljs-params">i</span> + 1)</span><span class="hljs-operator"> ||</span><br><span class="hljs-operator">      </span>can<span class="hljs-constructor">Find(<span class="hljs-params">row</span> - 1, <span class="hljs-params">col</span>, <span class="hljs-params">i</span> + 1)</span><span class="hljs-operator"> ||</span><br><span class="hljs-operator">      </span>can<span class="hljs-constructor">Find(<span class="hljs-params">row</span>, <span class="hljs-params">col</span> + 1, <span class="hljs-params">i</span> + 1)</span><span class="hljs-operator"> ||</span><br><span class="hljs-operator">      </span>can<span class="hljs-constructor">Find(<span class="hljs-params">row</span>, <span class="hljs-params">col</span> - 1, <span class="hljs-params">i</span> + 1)</span><br></code></pre></td></tr></table></figure><p>如果第一个递归调用返回 false，就会执行||后的下一个递归调用</p><ul><li>这里暗含回溯：当前处在[row,col]，选择[row+1,col]继续递归，返回false的话，会撤销[row+1,col]这个选择，回到[row,col]，继续选择[row-1,col]递归。</li></ul><p>只要其中有一个递归调用返回 true，||后的递归就不会执行，即找到解就终止搜索，利用||的短路效应，把枝剪了。</p><p>如果求出 canFindRest 为 false，说明基于当前点不能找到剩下的路径，所以当前递归要返回false，还要在used矩阵中把当前点恢复为未访问，让它后续能正常被访问。</p><ul><li>因为，基于当前路径，选当前点是不对的，但基于别的路径，走到这选它，有可能是对的。</li></ul><h3 id="什么时候返回-true？"><a href="#什么时候返回-true？" class="headerlink" title="什么时候返回 true？"></a><strong>什么时候返回 true？</strong></h3><p>在递归中，我们设置了所有返回 false 的情况。</p><p>当指针越界，此时已经考察完单词字符，意味着，在该递归分支中，为一个个字符选点，始终没有返回过 false，这些字符都选到对的点。所以指针越界就可以返回 true。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span> used[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-comment">// 每个格子都可能是起点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span> (isOk(i,j,board,word,used,<span class="hljs-number">0</span>))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOk</span><span class="hljs-params">(<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n,<span class="hljs-type">char</span>[][] board, String word,<span class="hljs-type">boolean</span> [][]used,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-comment">// 不在网格内</span><br>        <span class="hljs-keyword">if</span> (!(m&gt;=<span class="hljs-number">0</span> &amp;&amp; m&lt;board.length &amp;&amp; n&gt;=<span class="hljs-number">0</span> &amp;&amp; n&lt;board[<span class="hljs-number">0</span>].length))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 当前字符不等</span><br>        <span class="hljs-keyword">if</span> (board[m][n]!=word.charAt(k))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 重复访问 </span><br>        <span class="hljs-keyword">if</span> (used[m][n])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 全部字符匹配</span><br>        <span class="hljs-keyword">if</span> (k==word.length()-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 当前字符匹配 做访问标记</span><br>        used[m][n] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 当前点四个方向匹配下一个字符</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> isOk(m+<span class="hljs-number">1</span>,n,board,word,used,k+<span class="hljs-number">1</span>) ||<br>                isOk(m,n+<span class="hljs-number">1</span>,board,word,used,k+<span class="hljs-number">1</span>) ||<br>                isOk(m-<span class="hljs-number">1</span>,n,board,word,used,k+<span class="hljs-number">1</span>) ||<br>                isOk(m,n-<span class="hljs-number">1</span>,board,word,used,k+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 回溯修改当前不能访问的点 但是接下来的方向可以访问它</span><br>        used[m][n] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">boolean</span> used[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span>  isOk(i,j,board,word,used,<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (flag)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOk</span><span class="hljs-params">(<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n,<span class="hljs-type">char</span>[][] board, String word,<span class="hljs-type">boolean</span> [][]used,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span> (board[m][n]!=word.charAt(k)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k==word.length()-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        used[m][n] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> [][]t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []tt : t)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newm</span> <span class="hljs-operator">=</span> m + tt[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newn</span> <span class="hljs-operator">=</span> n + tt[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (newm&gt;=<span class="hljs-number">0</span> &amp;&amp; newm&lt;board.length &amp;&amp; newn&gt;=<span class="hljs-number">0</span> &amp;&amp; newn&lt;board[<span class="hljs-number">0</span>].length)&#123;<br>                <span class="hljs-keyword">if</span> (!used[newm][newn])&#123;<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> isOk(newm,newn,board,word,used,k+<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span> (flag)&#123;<br>                        res = flag;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        used[m][n] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>回溯法</category>
      
      <category>练习题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子集</title>
    <link href="/2022/08/29/%E5%AD%90%E9%9B%86/"/>
    <url>/2022/08/29/%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>回溯法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        set(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums,<span class="hljs-type">int</span> start)</span>&#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;i&lt;nums.length;i++)&#123;<br>            list.add(nums[i]);<br>            set(nums, i+<span class="hljs-number">1</span>);<br>            list.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>回溯法</category>
      
      <category>练习题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>颜色分类</title>
    <link href="/2022/08/29/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
    <url>/2022/08/29/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h1><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p> <strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="解法一：快速排序"><a href="#解法一：快速排序" class="headerlink" title="解法一：快速排序"></a>解法一：快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        quick(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-keyword">if</span> (l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> sort(nums,l,r);<br>            quick(nums,l,index-<span class="hljs-number">1</span>);<br>            quick(nums,index+<span class="hljs-number">1</span>,r);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[l];<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-keyword">while</span> (l&lt;r &amp;&amp; nums[r]&gt;=t)&#123;<br>                r--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[r]&lt;t)&#123;<br>                nums[l] = nums[r];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (l&lt;r &amp;&amp;nums[l]&lt;=t)&#123;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[l]&gt;t)&#123;<br>                nums[r] = nums[l];<br>            &#125;<br>        &#125;<br>        nums[l] = t;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：单指针"><a href="#解法二：单指针" class="headerlink" title="解法二：单指针"></a>解法二：单指针</h2><ul><li>两次遍历数组，定义指针，开始指向0</li><li>第一次遍历数组，寻找数组中数字是0的与指针交换，指针后移</li><li>第二次遍历数组，寻找数组中数字是1的与指针交换，指针后移</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">//寻找是0的元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = t;<br>                p0++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//寻找是1的元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p0;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = t;<br>                p0++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[p1];<br>                nums[p1] = t;<br>                p1++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>                nums[i] = nums[p0];<br>                nums[p0] = t;<br>                <span class="hljs-keyword">if</span> (p0&lt;p1)&#123;<br>                    t = nums[i];<br>                    nums[i] = nums[p1];<br>                    nums[p1] = t;<br>                &#125;<br>                p0++;<br>                p1++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法四：计数"><a href="#解法四：计数" class="headerlink" title="解法四：计数"></a>解法四：计数</h2><p>分别算出0，1，2的个数，再依次填入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>           <span class="hljs-keyword">if</span> (nums[i]==<span class="hljs-number">0</span>)&#123;<br>               n0++;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i]==<span class="hljs-number">1</span>)&#123;<br>               n1++;<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               n2++;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>           <span class="hljs-keyword">if</span> (i&lt;n0)&#123;<br>               nums[i] = <span class="hljs-number">0</span>;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i&lt;n0+n1)&#123;<br>               nums[i] = <span class="hljs-number">1</span>;<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               nums[i] = <span class="hljs-number">2</span>;<br>           &#125;<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>合并区间</title>
    <link href="/2022/08/29/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2022/08/29/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h1><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> []o1, <span class="hljs-type">int</span> []o2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (o1[<span class="hljs-number">0</span>]==o2[<span class="hljs-number">0</span>])&#123;<br>                    <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br>        <span class="hljs-type">int</span> res[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//如果是第一个元素，获取第二个元素的第一位比当前res中的最后一位大的话，则直接加入</span><br>            <span class="hljs-keyword">if</span> (index==-<span class="hljs-number">1</span> || intervals[i][<span class="hljs-number">0</span>]&gt;res[index][<span class="hljs-number">1</span>])&#123;<br>                ++index;<br>                res[index][<span class="hljs-number">0</span>] = intervals[i][<span class="hljs-number">0</span>];<br>                res[index][<span class="hljs-number">1</span>] = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span> &#123;     <br>                res[index][<span class="hljs-number">1</span>] = Math.max(intervals[i][<span class="hljs-number">1</span>], res[index][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//复制指定长度的数组</span><br>        <span class="hljs-keyword">return</span> Arrays.copyOf(res,index+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> []o1, <span class="hljs-type">int</span> []o2)</span> &#123;<br>                <span class="hljs-keyword">if</span> (o1[<span class="hljs-number">0</span>]==o2[<span class="hljs-number">0</span>])&#123;<br>                    <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> intervals.length;<br>        <span class="hljs-type">int</span> res[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//下一个数组的起始值必须要小于上一个数组的最大值才能合并</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//如果当前最小界比上一个的最大界小 说明可以合并 ，更新更新后的上界</span><br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>]&lt;=end)&#123;<br>                end = Math.max(intervals[i][<span class="hljs-number">1</span>],end);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//说明不能继续合并了 ，把之前合并的结果存入结果集中</span><br>                res[index][<span class="hljs-number">0</span>] = start;<br>                res[index][<span class="hljs-number">1</span>] = end;<br>                index++;<br>                 <span class="hljs-comment">//更新start 和 end 为当前新范围</span><br>                start = intervals[i][<span class="hljs-number">0</span>];<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        res[index][<span class="hljs-number">0</span>] = start;<br>        res[index][<span class="hljs-number">1</span>] = end;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(res,index+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二维数组排序</title>
    <link href="/2022/08/29/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/08/29/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] intervals = &#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">10</span>&#125;&#125;;<br>Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(o1[<span class="hljs-number">0</span>]==o2[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] - o2[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>] - o2[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>此代码中，对于每个<code>o1</code>和<code>o2</code>数组，若各自第一个元素（也就是<code>o1[0]</code>和<code>o2[0]</code>）相等，则按照各自第二个元素进行升序比较，否则就按照第一个元素进行升序比较。</p><p><strong>在此，<code>o1[0] - o2[0]</code> 表示升序，<code>o2[0] - o1[0]</code> 表示降序。</strong></p><p>比如这个代码，结果如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">10</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">9</span> <br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <br><span class="hljs-symbol">8 </span><span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure><p>o1[0]表示第一个元素，以此类推，所以我们想要根据第几个元素排序，就写入就好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 按照第三个元素排序</span><br><span class="hljs-type">int</span>[][] intervals = &#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br>Arrays.sort(intervals, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1[<span class="hljs-number">2</span>] - o2[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <br></code></pre></td></tr></table></figure><p><strong>其他写法</strong></p><p><strong>1、使用Lambda表达式的方式对Comparator<a href="https://so.csdn.net/so/search?q=%E6%AF%94%E8%BE%83%E5%99%A8&spm=1001.2101.3001.7020">比较器</a>进行简写（JDK1.8+）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] intervals = &#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br>Arrays.sort(intervals, (o1, o2) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> o1[<span class="hljs-number">2</span>] - o2[<span class="hljs-number">2</span>];<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>项目优化</title>
    <link href="/2022/08/29/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    <url>/2022/08/29/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h1><p><img src="/2022/08/29/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20220829114113741.png" alt="image-20220829114113741"></p><h2 id="纳入Git管理"><a href="#纳入Git管理" class="headerlink" title="纳入Git管理"></a>纳入Git管理</h2><p><strong>在码云中新建一个仓库为:</strong></p><p><img src="/2022/08/29/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20220829114442275.png" alt="image-20220829114442275"></p><p><strong>将项目上传到仓库中：</strong></p><p>先创建一个本地的仓库：</p><p><img src="/2022/08/29/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20220829115026209.png" alt="image-20220829115026209"></p><p>add本地仓库并提交，再push远程仓库</p><p>新建一个分支为V1.0，对于所有缓存的操作，都在这个v1.0的分支下操作。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>pom.xml文件中导入spring data redis的maven的坐标</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p><strong>添加配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">spring: <br>    redis:<br>        host: <span class="hljs-number">192.168</span><span class="hljs-number">.106</span><span class="hljs-number">.100</span><br>        port: <span class="hljs-number">6739</span><br>        password: Zlw199805<br>        database: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>添加配置类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Redis配置类</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br><br>        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br><br>        redisTemplate.setConnectionFactory(connectionFactory);<br><br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缓存短信验证码"><a href="#缓存短信验证码" class="headerlink" title="缓存短信验证码"></a>缓存短信验证码</h2><p><img src="/2022/08/29/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20220829121757768.png" alt="image-20220829121757768"></p><p>1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将生成的验证码保存到session中</span><br><span class="hljs-comment">//            httpSession.setAttribute(phone,code);</span><br><br>            <span class="hljs-comment">//将生成的验证码缓存到redis中</span><br>            redisTemplate.opsForValue().set(phone,code,<span class="hljs-number">5</span>, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure><p>2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//获取session里面的验证码</span><br><span class="hljs-comment">//        Object codeInSession = httpSession.getAttribute(phone);</span><br><br>        <span class="hljs-comment">//获取redis中的验证码</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">codeInSession</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(phone);<br></code></pre></td></tr></table></figure><p>3:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将redis中缓存的验证码删除</span><br>           redisTemplate.delete(phone);<br></code></pre></td></tr></table></figure><h2 id="缓存菜单数据"><a href="#缓存菜单数据" class="headerlink" title="缓存菜单数据"></a>缓存菜单数据</h2><p><img src="/2022/08/29/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20220829130815939.png" alt="image-20220829130815939"></p><p><strong>改造list方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> List&lt;DishDto&gt; dishDtoList = <span class="hljs-literal">null</span>;<br> <span class="hljs-comment">//动态的构造key</span><br> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dish_&quot;</span>+dish.getCategoryId()+<span class="hljs-string">&quot;_&quot;</span>+dish.getStatus();<br> <span class="hljs-comment">//获取key</span><br> dishDtoList = (List&lt;DishDto&gt;) redisTemplate.opsForValue().get(key);<br> <span class="hljs-comment">//如果存在，则直接从redis中返回</span><br> <span class="hljs-keyword">if</span> (dishDtoList!=<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> R.success(dishDtoList);<br> <br><span class="hljs-comment">//如果不存在，执行操作后：</span><br><span class="hljs-comment">//如果不存在，则从数据库中查找，并加入的redis中</span><br>        redisTemplate.opsForValue().set(key,dishDtoList,<span class="hljs-number">60</span>, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure><p><strong>改造save和update方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//清理所有菜品缓存数据</span><br><span class="hljs-comment">//        Set keys = redisTemplate.keys(&quot;dish_*&quot;);</span><br><span class="hljs-comment">//        redisTemplate.delete(keys);</span><br>        <br>        <span class="hljs-comment">//精确清理：清理某个分类下面的菜品缓存数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dish_&quot;</span> + dishDto.getCategoryId()+<span class="hljs-string">&quot;_1&quot;</span>;<br>        redisTemplate.delete(key);<br></code></pre></td></tr></table></figure><p><strong>提交给本体的Git，并推送到远程的仓库</strong></p><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p><img src="/2022/08/29/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20220829134419524.png" alt="image-20220829134419524"></p><p><img src="/2022/08/29/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/image-20220829134535958.png" alt="image-20220829134535958"></p><h2 id="缓存套餐数据"><a href="#缓存套餐数据" class="headerlink" title="缓存套餐数据"></a>缓存套餐数据</h2>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/2022/08/24/linux/"/>
    <url>/2022/08/24/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p><img src="/2022/08/24/linux/image-20220825111341308.png" alt="image-20220825111341308"></p><p>命令格式：</p><p><img src="/2022/08/24/linux/image-20220825111434292.png" alt="image-20220825111434292"></p><p><code>rm -f [文件名]</code>：强制删除，不会有确认询问</p><p><code>ls -l</code>：当前目录下详细的内容，除文件的名称外，同时显示文件型态（d表示目录，-表示文件），权限，拥有者，文件大小等信息。简写：<code>ll</code></p><p><code>echo  “内容” &gt;&gt; 文件</code>：将内容追加到文件中</p><h2 id="目录类操作命令"><a href="#目录类操作命令" class="headerlink" title="目录类操作命令"></a>目录类操作命令</h2><h3 id="进入指定目录：cd"><a href="#进入指定目录：cd" class="headerlink" title="进入指定目录：cd"></a>进入指定目录：cd</h3><p>用于切换当前工作目录，进入指定目录</p><p><img src="/2022/08/24/linux/image-20220825112247229.png" alt="image-20220825112247229"></p><h3 id="显示文件内容：cat"><a href="#显示文件内容：cat" class="headerlink" title="显示文件内容：cat"></a>显示文件内容：cat</h3><p><img src="/2022/08/24/linux/image-20220825112411488.png" alt="image-20220825112411488"></p><h3 id="分页形式显示内容：more"><a href="#分页形式显示内容：more" class="headerlink" title="分页形式显示内容：more"></a>分页形式显示内容：more</h3><p><img src="/2022/08/24/linux/image-20220825112517027.png" alt="image-20220825112517027"></p><h3 id="查看文件末尾：tail"><a href="#查看文件末尾：tail" class="headerlink" title="查看文件末尾：tail"></a>查看文件末尾：tail</h3><p><img src="/2022/08/24/linux/image-20220825112722475.png" alt="image-20220825112722475"></p><h3 id="创建目录：mkdir"><a href="#创建目录：mkdir" class="headerlink" title="创建目录：mkdir"></a>创建目录：mkdir</h3><p><img src="/2022/08/24/linux/image-20220825113051401.png" alt="image-20220825113051401"></p><h3 id="删除空目录：rmdir"><a href="#删除空目录：rmdir" class="headerlink" title="删除空目录：rmdir"></a>删除空目录：rmdir</h3><p><img src="/2022/08/24/linux/image-20220825113344610.png" alt="image-20220825113344610"></p><h3 id="删除文件或目录：rm"><a href="#删除文件或目录：rm" class="headerlink" title="删除文件或目录：rm"></a>删除文件或目录：rm</h3><p><img src="/2022/08/24/linux/image-20220825140456085.png" alt="image-20220825140456085"></p><h2 id="拷贝移动命令"><a href="#拷贝移动命令" class="headerlink" title="拷贝移动命令"></a>拷贝移动命令</h2><h3 id="复制文件和目录：cp"><a href="#复制文件和目录：cp" class="headerlink" title="复制文件和目录：cp"></a>复制文件和目录：cp</h3><p><img src="/2022/08/24/linux/image-20220825143853801.png" alt="image-20220825143853801"></p><h3 id="移动文件目录命令：mv"><a href="#移动文件目录命令：mv" class="headerlink" title="移动文件目录命令：mv"></a>移动文件目录命令：mv</h3><p><img src="/2022/08/24/linux/image-20220825144313677.png" alt="image-20220825144313677"></p><h2 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h2><h3 id="对文件进行打包、解包、压缩、解压：tar"><a href="#对文件进行打包、解包、压缩、解压：tar" class="headerlink" title="对文件进行打包、解包、压缩、解压：tar"></a>对文件进行打包、解包、压缩、解压：tar</h3><p><img src="/2022/08/24/linux/image-20220825144912562.png" alt="image-20220825144912562"></p><p><strong>举例：</strong></p><p><img src="/2022/08/24/linux/image-20220825145759233.png" alt="image-20220825145759233"></p><h2 id="文件编辑命令"><a href="#文件编辑命令" class="headerlink" title="文件编辑命令"></a>文件编辑命令</h2><h3 id="文件编辑命令：vi-x2F-vim"><a href="#文件编辑命令：vi-x2F-vim" class="headerlink" title="文件编辑命令：vi&#x2F;vim"></a>文件编辑命令：vi&#x2F;vim</h3><p><img src="/2022/08/24/linux/image-20220825150015639.png" alt="image-20220825150015639"></p><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><h3 id="指定目录下查找文件：find"><a href="#指定目录下查找文件：find" class="headerlink" title="指定目录下查找文件：find"></a>指定目录下查找文件：find</h3><p><img src="/2022/08/24/linux/image-20220825150601713.png" alt="image-20220825150601713"></p><h3 id="指定文件中查找指定文本内容：grep"><a href="#指定文件中查找指定文本内容：grep" class="headerlink" title="指定文件中查找指定文本内容：grep"></a>指定文件中查找指定文本内容：grep</h3><p><img src="/2022/08/24/linux/image-20220825150821612.png" alt="image-20220825150821612"></p><h1 id="Linux软件安装"><a href="#Linux软件安装" class="headerlink" title="Linux软件安装"></a>Linux软件安装</h1><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p><img src="/2022/08/24/linux/image-20220825152619982.png" alt="image-20220825152619982"></p><h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p><img src="/2022/08/24/linux/image-20220825152716522.png" alt="image-20220825152716522"></p><p><img src="/2022/08/24/linux/image-20220825153304526.png" alt="image-20220825153304526"></p><h2 id="安装MySql"><a href="#安装MySql" class="headerlink" title="安装MySql"></a>安装MySql</h2><p><img src="/2022/08/24/linux/image-20220825154458311.png" alt="image-20220825154458311"></p><p><img src="/2022/08/24/linux/image-20220825154710200.png" alt="image-20220825154710200"></p><p><img src="/2022/08/24/linux/image-20220825154909215.png" alt="image-20220825154909215"></p><p><img src="/2022/08/24/linux/image-20220825155003775.png" alt="image-20220825155003775"></p><p><img src="/2022/08/24/linux/image-20220825155140045.png" alt="image-20220825155140045"></p><p><img src="/2022/08/24/linux/image-20220825155617709.png" alt="image-20220825155617709"></p><h2 id="安装lrzsz"><a href="#安装lrzsz" class="headerlink" title="安装lrzsz"></a>安装lrzsz</h2><p><img src="/2022/08/24/linux/image-20220825165625678.png" alt="image-20220825165625678"></p><p>输入<code>rz</code>：可以弹出文件上传窗口</p><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="手工部署项目"><a href="#手工部署项目" class="headerlink" title="手工部署项目"></a>手工部署项目</h2><p><img src="/2022/08/24/linux/image-20220825170211439.png" alt="image-20220825170211439"></p><p><img src="/2022/08/24/linux/image-20220825170322327.png" alt="image-20220825170322327"></p><p><code>java -jar name.jar</code></p><p><img src="/2022/08/24/linux/image-20220825170403866.png" alt="image-20220825170403866"></p><p><img src="/2022/08/24/linux/image-20220825170509688.png" alt="image-20220825170509688"></p><p>上线的项目，运行信息不展示到控制台，而是输出到日志中。</p><p><img src="/2022/08/24/linux/image-20220825170625715.png" alt="image-20220825170625715"></p><p><img src="/2022/08/24/linux/image-20220825170956692.png" alt="image-20220825170956692"></p><h2 id="通过Shell脚本自动部署项目"><a href="#通过Shell脚本自动部署项目" class="headerlink" title="通过Shell脚本自动部署项目"></a>通过Shell脚本自动部署项目</h2><p><img src="/2022/08/24/linux/image-20220825171131049.png" alt="image-20220825171131049"></p><h3 id="在Linux中安装Git"><a href="#在Linux中安装Git" class="headerlink" title="在Linux中安装Git"></a>在Linux中安装Git</h3><p><img src="/2022/08/24/linux/image-20220825171328046.png" alt="image-20220825171328046"></p><p><strong>使用Git克隆代码</strong></p><p><img src="/2022/08/24/linux/image-20220825171454045.png" alt="image-20220825171454045"></p><h3 id="在Linux中安装maven"><a href="#在Linux中安装maven" class="headerlink" title="在Linux中安装maven"></a>在Linux中安装maven</h3><p><img src="/2022/08/24/linux/image-20220825171707081.png" alt="image-20220825171707081"></p><p><img src="/2022/08/24/linux/image-20220825211147589.png" alt="image-20220825211147589"></p><p><code>bootStart.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>echo =================================<br>echo  自动化部署脚本启动<br>echo =================================<br><br>echo 停止原来运行中的工程<br>APP_NAME=helloworld  #!运行项目的名称<br><br>tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`<br>if [ $&#123;tpid&#125; ]; then<br>    echo &#x27;Stop Process...&#x27;<br>    kill -15 $tpid<br>fi<br>sleep 2<br>tpid=`ps -ef|grep $APP_NAME|grep -v grep|grep -v kill|awk &#x27;&#123;print $2&#125;&#x27;`<br>if [ $&#123;tpid&#125; ]; then<br>    echo &#x27;Kill Process!&#x27;<br>    kill -9 $tpid<br>else<br>    echo &#x27;Stop Success!&#x27;<br>fi<br><br>echo 准备从Git仓库拉取最新代码<br>cd /usr/local/helloworld<br><br>echo 开始从Git仓库拉取最新代码<br>git pull<br>echo 代码拉取完成<br><br>echo 开始打包<br>output=`mvn clean package -Dmaven.test.skip=true`<br><br>cd target<br><br>echo 启动项目<br>nohup java -jar helloworld-1.0-SNAPSHOT.jar &amp;&gt; helloworld.log &amp;<br>echo 项目启动完成<br><br></code></pre></td></tr></table></figure><p><img src="/2022/08/24/linux/image-20220825211856696.png" alt="image-20220825211856696"></p><p><img src="/2022/08/24/linux/image-20220825212236558.png" alt="image-20220825212236558"></p><p><strong>通过Shell脚本自动部署项目</strong></p><p>设置IP地址为静态的IP地址，如果是动态则，当断开连接的时候，再次连接有可能IP地址变化，就找不到了。</p><p><img src="/2022/08/24/linux/image-20220825212752119.png" alt="image-20220825212752119"></p><p><img src="/2022/08/24/linux/image-20220825213757248.png" alt="image-20220825213757248"></p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>不同路径2</title>
    <link href="/2022/08/24/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/"/>
    <url>/2022/08/24/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/</url>
    
    <content type="html"><![CDATA[<h1 id="不同路径2"><a href="#不同路径2" class="headerlink" title="不同路径2"></a>不同路径2</h1><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 0 来表示。</p><p><strong>示例 1：</strong></p><p><img src="/2022/08/24/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/robot1.jpg" alt="img"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：obstacleGrid = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span>x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 <span class="hljs-number">2</span> 条不同的路径：<br><br><span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/08/24/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/robot2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="/2022/08/24/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842/1afcfae835024eac94d327f93c406149.png" alt="在这里插入图片描述"></p><p><strong>注意：</strong></p><blockquote><p>f[i,j]里面包含两种情况，但两种情况不一定全部都包含，从某一个点的路径数量由两部分组成，一种是：从左边到该位置，一种是从上边到该位置， 但不是所有的点都满足，当<code>i = 0</code>时，不能满足从上边到该位置，当<code>j = 0</code>时不能满足从左边到该位置。<br>如果遇到障碍物也就是该点为1的时候跳过，当第一个点不为1，状态数组为1.</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-type">int</span> dp[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[obstacleGrid.length][obstacleGrid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;obstacleGrid.length;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;obstacleGrid[i].length;j++)&#123;<br>                <span class="hljs-comment">//如果时障碍物，则跳过</span><br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">//走到当前点路径只有1个</span><br>                <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> &amp;&amp; j==<span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//如果不在第一行</span><br>                <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span>) dp[i][j] +=dp[i-<span class="hljs-number">1</span>][j];<br>                <span class="hljs-comment">//不在第一列</span><br>                <span class="hljs-keyword">if</span> (j&gt;<span class="hljs-number">0</span>) dp[i][j] +=dp[i][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">//第二种方式：</span><br><span class="hljs-comment">//                if (i==0) dp[i][j] = dp[i][j-1];</span><br><span class="hljs-comment">//                if (j==0) dp[i][j] = dp[i-1][j];</span><br><span class="hljs-comment">//                else dp[i][j] = dp[i-1][j] + dp[i][j-1];</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[obstacleGrid.length-<span class="hljs-number">1</span>][obstacleGrid[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>练习题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三角形最小路径和</title>
    <link href="/2022/08/24/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2022/08/24/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h1><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br> <span class="hljs-number"> 3 </span>4<br><span class="hljs-number"> 6 </span>5 7<br>4<span class="hljs-number"> 1 </span>8 3<br>自顶向下的最小路径和为 11（即，2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>= 11）<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：triangle = <span class="hljs-string">[[-10]]</span><br>输出：<span class="hljs-number">-10</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="/2022/08/24/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/944bf8ff57b54e1bac0584c3f774c3f0.png" alt="在这里插入图片描述"></p><p><strong>注意：</strong></p><blockquote><p>f[i,j]里面包含两种情况，两种情况不一定全部都包含， 分两种情况，但两种情况也不是全部都在的：<br>例如三角形的最左边，不可能从左上下来，三角形的最右面，不可能从右上下来。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>        <span class="hljs-type">int</span> dp[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;triangle.get(i).size();j++)&#123;<br>                dp[i][j] = Integer.MAX_VALUE;<br>                <span class="hljs-comment">//从左上方来，但是三角形的最左边不可能从左上来</span><br>                <span class="hljs-keyword">if</span> (j&gt;<span class="hljs-number">0</span>) dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+triangle.get(i).get(j),dp[i][j]);<br>                <span class="hljs-comment">//从右上方来，但是三角形的最右面不可能从右上方来</span><br>                <span class="hljs-keyword">if</span> (j&lt;i) dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j]+triangle.get(i).get(j), dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//从最后一行中，选择一个最小的路径</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;triangle.size();i++)&#123;<br>            res = Math.min(res,dp[triangle.size()-<span class="hljs-number">1</span>][i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>练习题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最大子数组和</title>
    <link href="/2022/08/24/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2022/08/24/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1</strong>：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[5,4,-1,7,8]</span><br>输出：<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="/2022/08/24/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/1ed1d3707e834b23ac5a98a7702270c4.png" alt="在这里插入图片描述"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>nums.length;<br>        <span class="hljs-type">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>],<span class="hljs-number">0</span>)+nums[i];<br>            max = Math.max(max,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>练习题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划分析</title>
    <link href="/2022/08/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/08/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划在查找有很多重叠子问题的情况的最优解时有效。<br>动态规划只能用于有最优子结构的问题，最优子结构的意思就是局部最优解能决定全局最优解。简单的说：问题能够分解成子问题来解决。</p><p><strong>以下是动态规划题目的一种分析方式，</strong><br><strong>状态表示</strong>：分为一维和二维的，一般这个的选择，多做题，按照经验来设置，如果是二维的一般第二个是限制。<br><strong>状态计算</strong>：一般是将 f[i] 这个集合划分为若干份，一般找最后一个不同点，就是选择最后一个 i 的方法，就是选不选择 i 。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字母异位词分组</title>
    <link href="/2022/08/24/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2022/08/24/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><h2 id="解法一：排序"><a href="#解法一：排序" class="headerlink" title="解法一：排序"></a>解法一：排序</h2><p>将字符串数组中的元素，进行排序，根据排序后的值作为键，原始值存储到map中，返回map中的值就是结果。</p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String ,LinkedList&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;strs.length;i++)&#123;<br>            <span class="hljs-type">char</span>[] chars = strs[i].toCharArray();<br>            <span class="hljs-comment">//排序</span><br>            Arrays.sort(chars);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.valueOf(chars);<br>            <span class="hljs-keyword">if</span> (!map.containsKey(key))&#123;<br>                map.put(key,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>            &#125;<br>            map.get(key).add(strs[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法：计数"><a href="#解法：计数" class="headerlink" title="解法：计数"></a>解法：计数</h2><p>对每个字符串计数得到该字符串的计数数组，对于计数数组相同的字符串，就互为异位词。<br>因为数组类型没有重写 <code>hashcode()</code> 和 <code>equals()</code> 方法，因此不能直接作为 <code>HashMap</code> 的 <code>Key</code> 进行聚合，那么我们就 把这个数组手动编码变成字符串就行了。<br>比如将 <code>[b,a,a,a,b,c]</code> 编码成 <code>a3b2c1</code>，使用编码后的字符串作为 <code>HashMap</code> 的 <code>Key</code> 进行聚合。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        Map&lt;String,List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;strs.length;i++)&#123;<br>            <span class="hljs-type">int</span> count[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>            <span class="hljs-type">char</span>[] chars = strs[i].toCharArray();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;chars.length;j++)&#123;<br>                count[chars[j]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            &#125;<br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span> (count[j]!=<span class="hljs-number">0</span>)&#123;<br>                    stringBuffer.append((<span class="hljs-type">char</span>) j+<span class="hljs-string">&#x27;a&#x27;</span>);<br>                    stringBuffer.append(count[j]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> stringBuffer.toString();<br>            List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>            list.add(strs[i]);<br>            map.put(key,list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;List&lt;String&gt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>旋转图像</title>
    <link href="/2022/08/23/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/08/23/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p>给定一个 n × n 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 <strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="/2022/08/23/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/mat1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong> </p><p><img src="/2022/08/23/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/mat2.jpg" alt="img"> </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[5,1,9,11]</span>,<span class="hljs-comment">[2,4,8,10]</span>,<span class="hljs-comment">[13,3,6,7]</span>,<span class="hljs-comment">[15,14,12,16]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[15,13,2,5]</span>,<span class="hljs-comment">[14,3,4,1]</span>,<span class="hljs-comment">[12,6,8,9]</span>,<span class="hljs-comment">[16,7,10,11]</span>]</span><br></code></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul><li>首先将这个二维数组，按照这个<code>\</code>对角线进行交换。</li><li>再将交换完的数组，左右对称。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">//先对称</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span> (j&gt;i)  swap1(matrix,i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//再左右</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            swap2(matrix,i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//右对角线的交换</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap1</span><span class="hljs-params">(<span class="hljs-type">int</span> matrix[][],<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span>  matrix[i][j];<br>        matrix[i][j] = matrix[j][i];<br>        matrix[j][i] = t;<br>    &#125;<br>    <span class="hljs-comment">//左右交换</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap2</span><span class="hljs-params">(<span class="hljs-type">int</span> matrix[][],<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].length/<span class="hljs-number">2</span>;j++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> matrix[i][j];<br>            matrix[i][j] = matrix[i][matrix.length-<span class="hljs-number">1</span>-j];<br>            matrix[i][matrix.length-<span class="hljs-number">1</span>-j] = t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>全排列</title>
    <link href="/2022/08/23/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2022/08/23/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>使用回溯法中的模板</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">boolean</span> used[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        array(nums,used);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">array</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[],<span class="hljs-type">boolean</span> used[])</span>&#123;<br>        <span class="hljs-keyword">if</span> (list.size()==nums.length) &#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//选择</span><br>            used[i] = <span class="hljs-literal">true</span>;<br>            list.add(nums[i]);<br>            array(nums,used);<br>            <span class="hljs-comment">//撤销选择</span><br>            used[i] = <span class="hljs-literal">false</span>;<br>            list.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>回溯法</category>
      
      <category>练习题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组合总和</title>
    <link href="/2022/08/23/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
    <url>/2022/08/23/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p><code>candidates</code> 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], target = <span class="hljs-number">7</span><br>输出：[[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">7</span>]]<br>解释：<br><span class="hljs-number">2</span> 和 <span class="hljs-number">3</span> 可以形成一组候选，<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">7</span> 。注意 <span class="hljs-number">2</span> 可以使用多次。<br><span class="hljs-number">7</span> 也是一个候选， <span class="hljs-number">7</span> = <span class="hljs-number">7</span> 。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], target = <span class="hljs-number">8</span><br>输出: [[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入: candidates = [<span class="hljs-number">2</span>], target = <span class="hljs-number">1</span><br>输出: []<br></code></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>回溯算法中，组合的框架（元素不重复，可重复选择）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;<br>        combina(<span class="hljs-number">0</span>,candidates,target);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combina</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-keyword">if</span> (sum==target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sum&gt;target) <span class="hljs-keyword">return</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;i&lt;candidates.length;i++)&#123;<br>            <span class="hljs-comment">//选择</span><br>            list.add(candidates[i]);<br>            sum = sum + candidates[i];<br>            combina(i,candidates,target);<br>            <span class="hljs-comment">//撤销选择</span><br>            list.removeLast();<br>            sum = sum - candidates[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>回溯法</category>
      
      <category>练习题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>leetCode34</title>
    <link href="/2022/08/23/leetCode34/"/>
    <url>/2022/08/23/leetCode34/</url>
    
    <content type="html"><![CDATA[<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br></code></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>两次二分法，分别运用两个代码的模板即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] searchRange(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//第一个数的位置</span><br>        <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left+right)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (target&lt;=nums[mid]) right = mid;<br>            <span class="hljs-keyword">else</span> left = mid +<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[left]==target) res[<span class="hljs-number">0</span>] = left;<br>        <span class="hljs-keyword">else</span> res[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>        left = <span class="hljs-number">0</span>;<br>        right = n-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//第二个数的位置</span><br>        <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left+right+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid]&lt;=target) left = mid;<br>            <span class="hljs-keyword">else</span> right = mid-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[left]==target) res[<span class="hljs-number">1</span>] = left;<br>        <span class="hljs-keyword">else</span> res[<span class="hljs-number">1</span>] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分法</category>
      
      <category>二分法练习题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="/2022/08/23/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/08/23/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p>整数数组 <code>nums</code> 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 旋转后 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>], target = <span class="hljs-number">0</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>对于有序的数组，可以进行二分法进行查找，只不过这题有些不同，改变了顺序，但进行二分之后，左右两侧，总有一侧是有序的，因此还可以进行二分法。</p><ul><li>对元素进行二分，判断左右两侧，哪一侧是有序的</li><li>如果左侧有序，判断目标值是否满足左侧条件，如果满足则缩小范围，在左侧遍历</li><li>如果右侧有序，判断目标值是否满足右侧条件，如果满足则缩小范围，在右侧遍历</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>            <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]==target?<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left+right)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (target==nums[mid]) <span class="hljs-keyword">return</span> mid;<br>                <span class="hljs-comment">//如果左边有序</span><br>                <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>]&lt;=nums[mid])&#123;<br>                    <span class="hljs-comment">//看目标值是否在左边</span><br>                    <span class="hljs-keyword">if</span> (target&lt;nums[mid] &amp;&amp; target&gt;=nums[<span class="hljs-number">0</span>])&#123;<br>                        right = mid-<span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">//如果右边有序</span><br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//看目标值是否在右边</span><br>                    <span class="hljs-keyword">if</span> (target&gt;nums[mid] &amp;&amp; target&lt;=nums[n-<span class="hljs-number">1</span>])&#123;<br>                        left = mid + <span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[left]==target) <span class="hljs-keyword">return</span> left;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>下一个排列</title>
    <link href="/2022/08/23/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2022/08/23/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h1><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p><p>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]</code> 。<br>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。<br>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</li></ul><p>必须 原地 修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>过程：</p><ul><li>从后往前找，找到第一个<code>nums[i]&gt;nums[i-1]</code></li><li>再从后忘前找，找到第一个大于nums[i-1]的元素</li><li>将两个元素进行交换</li><li>对i-1后的元素进行逆转</li></ul><p><strong>以求 <code>12385764</code> 的下一个排列为例：</strong></p><p><img src="/2022/08/23/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/6e8c9822771be77c6f34cd3086153984eec386fb8376e09e36132ac36bb9cd6f-image.png" alt="image.png"></p><p>首先从后向前查找第一个相邻升序的元素对 <code>(i,j)</code>。这里 <code>i=4</code>，<code>j=5</code>，对应的值为 <code>5</code>，<code>7</code>：</p><p><img src="/2022/08/23/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/d7acefea4f7d4e2f19fb5eaa269c448a3098eee53656926a0ab592c564dde150-image.png" alt="image.png"></p><p>然后在 <code>[j,end)</code> 从后向前查找第一个大于 <code>A[i]</code> 的值 <code>A[k]</code>。这里 <code>A[i]</code> 是 <code>5</code>，故 <code>A[k]</code> 是 <code>6</code>：</p><p><img src="/2022/08/23/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/061cf291c237e6f5bcd0554192f894cd0c3e361b4564aa542aabe96e644afbf1-image.png" alt="image.png"></p><p>将 <code>A[i]</code> 与 <code>A[k]</code> 交换。这里交换 <code>5</code>、<code>6</code>：</p><p><img src="/2022/08/23/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/eb1470fd9942da6d2ab4855d13dfadcb715b629b4ea9cba0edfe2d1298744186-image.png" alt="image.png"></p><p>这时 <code>[j,end)</code> 必然是降序，逆置 <code>[j,end)</code>，使其升序。这里逆置 <code>[7,5,4]</code>：</p><p><img src="/2022/08/23/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/9d627a4ffda635bbf0c4fcdb7b1359c557db8e1c300ab54383a0bc89f6763c18-image.png" alt="image.png"></p><p>因此，<code>12385764</code> 的下一个排列就是 <code>12386457</code>。</p><p>最后再可视化地对比一下这两个相邻的排列（橙色是蓝色的下一个排列）</p><p><img src="/2022/08/23/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/e56a66ed318d1761cd8c8f9d1521f82a30c71ecc84f551912b90d8fe254c8f3d-image.png" alt="image.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>,b = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//从后往前，找到第一个nums[i]&gt;nums[i-1]的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i-<span class="hljs-number">1</span>]&lt;nums[i])&#123;<br>                a = i-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果已经是逆序，则逆转</span><br>        <span class="hljs-keyword">if</span> (a==-<span class="hljs-number">1</span>) &#123;<br>            resver(nums,a+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//从后往前 计算出比nums[a]的点</span><br>        <span class="hljs-keyword">if</span> (a&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;i&gt;a;i--)&#123;<br>                <span class="hljs-keyword">if</span> (nums[i]&gt;nums[a])&#123;<br>                    b = i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            swap(nums,a,b);<br>        &#125;<br>        resver(nums,a+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//交换</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[],<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = t;<br>    &#125;<br>    <span class="hljs-comment">//逆转</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resver</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[],<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> a;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>          swap(nums,left,right);<br>          left++;<br>          right--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯法</title>
    <link href="/2022/08/22/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2022/08/22/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。只需要思考 3 个问题：</p><p><strong>1、路径</strong>：也就是已经做出的选择。</p><p><strong>2、选择列表</strong>：也就是你当前可以做的选择。</p><p><strong>3、结束条件</strong>：也就是到达决策树底层，无法再做选择的条件。</p><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><h3 id="形式一-不包含重复数字，不可以重复选择的框架"><a href="#形式一-不包含重复数字，不可以重复选择的框架" class="headerlink" title="形式一:不包含重复数字，不可以重复选择的框架"></a>形式一:不包含重复数字，不可以重复选择的框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;LinkedList&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">//参数：路径，选择条件</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">way</span><span class="hljs-params">(LinkedList&lt;Integer&gt; list,<span class="hljs-type">int</span> nums[])</span>&#123;<br>       <span class="hljs-keyword">if</span> (list.size()==nums.length())&#123;<span class="hljs-comment">//如果满足结束条件</span><br>           res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(list));<span class="hljs-comment">//将路径加入到集合中</span><br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-comment">//在选择列表中选择</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>           <span class="hljs-comment">//排除不合法的选择</span><br>           <span class="hljs-keyword">if</span> (list.contains(nums[i])) <span class="hljs-keyword">continue</span>;<br>           <span class="hljs-comment">//做选择</span><br>           list.add(nums[i]);<br>           <span class="hljs-comment">//进入下一层决策树</span><br>           way(list,nums);<br>           <span class="hljs-comment">//取消选择</span><br>           list.removeLast();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p><p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。</p><p><strong>可以把「路径」和「选择列表」作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p><p><img src="/2022/08/22/%E5%9B%9E%E6%BA%AF%E6%B3%95/640" alt="图片"></p><p><strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。</p><p><img src="/2022/08/22/%E5%9B%9E%E6%BA%AF%E6%B3%95/640" alt="图片"></p><p>下面直接看全排列的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><span class="hljs-comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><br>List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 记录「路径」</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    backtrack(nums, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 路径：记录在 track 中</span><br><span class="hljs-comment">// 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="hljs-comment">// 结束条件：nums 中的元素全都在 track 中出现</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> &#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 排除不合法的选择</span><br>        <span class="hljs-keyword">if</span> (track.contains(nums[i]))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 进入下一层决策树</span><br>        backtrack(nums, track);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="形式二：包含重复数字，不可重复选择的框架"><a href="#形式二：包含重复数字，不可重复选择的框架" class="headerlink" title="形式二：包含重复数字，不可重复选择的框架"></a>形式二：包含重复数字，不可重复选择的框架</h3><p>先将数组排序，让相等的元素靠在一起。</p><p>在回溯的循环里面，多一个条件，就是判断当前的元素是否和前一个元素相等，并且前一个元素已经被选择完成。</p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;LinkedList&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>   <span class="hljs-comment">//先对nums进行排序</span><br>Arrays.sort(nums);<br><span class="hljs-comment">//定义一个判断是否选择的条件</span><br>used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br><span class="hljs-comment">//参数：路径，选择条件</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">way</span><span class="hljs-params">(LinkedList&lt;Integer&gt; list,<span class="hljs-type">int</span> nums[])</span>&#123;<br>       <span class="hljs-keyword">if</span> (list.size()==nums.length())&#123;<span class="hljs-comment">//如果满足结束条件</span><br>           res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(list));<span class="hljs-comment">//将路径加入到集合中</span><br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-comment">//在选择列表中选择</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>           <span class="hljs-comment">//排除不合法的选择</span><br>           <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>           <span class="hljs-comment">//多一个判断条件</span><br>           <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>           <span class="hljs-comment">//做选择</span><br>           list.add(nums[i]);<br>           used[i] = <span class="hljs-literal">true</span>;<br>           <span class="hljs-comment">//进入下一层决策树</span><br>           way(list,nums);<br>           <span class="hljs-comment">//取消选择</span><br>           list.removeLast();<br>           used[i] = <span class="hljs-literal">false</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="形式三：没有重复，可以重复选择"><a href="#形式三：没有重复，可以重复选择" class="headerlink" title="形式三：没有重复，可以重复选择"></a>形式三：没有重复，可以重复选择</h3><p>这个相对简单，没有判断是否选择的条件</p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;LinkedList&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">//参数：路径，选择条件</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">way</span><span class="hljs-params">(LinkedList&lt;Integer&gt; list,<span class="hljs-type">int</span> nums[])</span>&#123;<br>       <span class="hljs-keyword">if</span> (list.size()==nums.length())&#123;<span class="hljs-comment">//如果满足结束条件</span><br>           res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(list));<span class="hljs-comment">//将路径加入到集合中</span><br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-comment">//在选择列表中选择</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>           <span class="hljs-comment">//做选择</span><br>           list.add(nums[i]);<br>           <span class="hljs-comment">//进入下一层决策树</span><br>           way(list,nums);<br>           <span class="hljs-comment">//取消选择</span><br>           list.removeLast();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="形式四：有重复，可以重复选择"><a href="#形式四：有重复，可以重复选择" class="headerlink" title="形式四：有重复，可以重复选择"></a>形式四：有重复，可以重复选择</h3><p>既然可以重复选择，则有没有重复元素则没有意义。</p><p>将数组去重后，和形式三一样</p><h3 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><p>可以直接套用代码模板解答</p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">char</span> bord[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                bord[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>        just(<span class="hljs-number">0</span>,n,bord);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//二维数组转化为list</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">arrToList</span><span class="hljs-params">(<span class="hljs-type">char</span> bord[][])</span>&#123;<br>        List&lt;String&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;bord.length;i++)&#123;<br>            <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;bord[<span class="hljs-number">0</span>].length;j++)&#123;<br>                str.append(bord[i][j]);<br>            &#125;<br>            s.add(str.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-comment">//回溯</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">just</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> n,<span class="hljs-type">char</span> bord[][])</span>&#123;<br>        <span class="hljs-keyword">if</span> (row==n)&#123;<br>            res.add(arrToList(bord));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;col&lt;n;col++)&#123;<br>            <span class="hljs-keyword">if</span> (!Vaild(row,col,bord))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            bord[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            just(row+<span class="hljs-number">1</span>,n,bord);<br>            bord[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断是否符合规则</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">Vaild</span><span class="hljs-params">(<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col,<span class="hljs-type">char</span> bord[][])</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> bord.length;<br>        <span class="hljs-comment">//检查列是否有皇后冲突问题</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (bord[i][col]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查右上是否有皇后冲突问题</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row-<span class="hljs-number">1</span>,j = col+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;n;i--,j++)&#123;<br>            <span class="hljs-keyword">if</span> (bord[i][j] ==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查左上是否有皇后冲突问题</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row-<span class="hljs-number">1</span>,j = col-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span>;i--,j--)&#123;<br>            <span class="hljs-keyword">if</span> (bord[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>给出一个数组，返回数组中所有元素的子集。</p><p>比如输入<code>nums = [1,2,3]</code>，算法应该返回如下子集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[ [],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] ]<br></code></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdGKCHO6ezUG2HdfMuOx5XP3YSqUYKrxpIGXnnYMqQr1ibeMRZXzq0HgB2icK0jQoNVtsLUTdeHahMpw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="形式一：无重复，不可重复选择"><a href="#形式一：无重复，不可重复选择" class="headerlink" title="形式一：无重复，不可重复选择"></a>形式一：无重复，不可重复选择</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testgather</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> nums[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>            nums[i] = scanner.nextInt();<br>        &#125;<br>        gather(<span class="hljs-number">0</span>,nums);<br>        System.out.println(res.toString());<br>    &#125;<br>    <span class="hljs-comment">// 回溯算法核心函数，遍历子集问题的回溯树</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gather</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> nums[])</span>&#123;<br>        <span class="hljs-comment">// 前序位置，每个节点的值都是一个子集</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-comment">// 回溯算法标准框架</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-comment">// 做选择</span><br>            list.add(nums[i]);<br>            <span class="hljs-comment">// 通过 start 参数控制树枝的遍历，避免产生重复的子集</span><br>            gather(i+<span class="hljs-number">1</span>,nums);<br>            <span class="hljs-comment">// 撤销选择</span><br>            list.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="形式二：元素重复，不可重复选择"><a href="#形式二：元素重复，不可重复选择" class="headerlink" title="形式二：元素重复，不可重复选择"></a>形式二：元素重复，不可重复选择</h3><p>比如输入<code>nums = [1,2,2]</code>，你应该输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">[ [],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] ]<br></code></pre></td></tr></table></figure><p><img src="/2022/08/22/%E5%9B%9E%E6%BA%AF%E6%B3%95/640" alt="图片"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">[ <br>    [],<br>    [<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">2</span><span class="hljs-string">&#x27;],</span><br><span class="hljs-string">    [1,2],[1,2&#x27;</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span><span class="hljs-string">&#x27;],</span><br><span class="hljs-string">    [1,2,2&#x27;</span>]<br>]<br></code></pre></td></tr></table></figure><p>里面有重复的集合，所以要进行剪枝。</p><p><strong>体现在代码上，需要先进行排序，让相同的元素靠在一起，如果发现<code>nums[i] == nums[i-1]</code>，则跳过</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testgather</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> nums[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>            nums[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-comment">// 先排序，让相同的元素靠在一起</span><br>        Arrays.sort(nums);<br>        gather(<span class="hljs-number">0</span>,nums);<br>        System.out.println(res.toString());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gather</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> nums[])</span>&#123;<br>        <span class="hljs-comment">// 前序位置，每个节点的值都是一个子集</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-comment">// 剪枝逻辑，值相同的相邻树枝，只遍历第一条</span><br>            <span class="hljs-keyword">if</span> (i&gt;start &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            list.add(nums[i]);<br>            gather(i+<span class="hljs-number">1</span>,nums);<br>            list.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="形式三：没有重复，但可以重复选择"><a href="#形式三：没有重复，但可以重复选择" class="headerlink" title="形式三：没有重复，但可以重复选择"></a>形式三：没有重复，但可以重复选择</h3><p>比如输入<code>candidates = [1,2,3], target = 3</code>，算法应该返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[ [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>] ]<br></code></pre></td></tr></table></figure><p>首先来看，怎么样的实现使得不可以重复选择，</p><p>在于递归函数是输入的参数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯算法标准框架</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 递归遍历下一层回溯树，注意参数</span><br>    backtrack(nums, i + <span class="hljs-number">1</span>, target);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>i</code>从<code>start</code>开始，那么下一层回溯树就是从<code>start + 1</code>开始，从而保证<code>nums[start]</code>这个元素不会被重复使用：</p><p>那么反过来，如果我想让每个元素被重复使用，我只要把<code>i + 1</code>改成<code>i</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯算法标准框架</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 递归遍历下一层回溯树</span><br>    backtrack(nums, i, target);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/08/22/%E5%9B%9E%E6%BA%AF%E6%B3%95/640" alt="图片"></p><p>当然，这样这棵回溯树会永远生长下去，即路径和大于<code>target</code>时就没必要再遍历下去了。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testjihe</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-comment">//计算当前的和</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> nums[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>            nums[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        gather(<span class="hljs-number">0</span>,nums,target);<br>        System.out.println(res.toString());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gather</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-comment">//如果集合的和等于目标值，则将改子集加入到结果中</span><br>        <span class="hljs-keyword">if</span> (sum==target)&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果集合中的和大于结果集，则不再继续向下遍历</span><br>        <span class="hljs-keyword">if</span> (sum&gt;target) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 回溯算法标准框架</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-comment">// 选择 nums[i]</span><br>            sum = sum + nums[i];<br>            list.add(nums[i]);<br>            <span class="hljs-comment">// 递归遍历下一层回溯树</span><br>        <span class="hljs-comment">// 同一元素可重复使用，注意参数</span><br>            gather(i,nums,target);<br>            <span class="hljs-comment">// 撤销选择 nums[i]</span><br>            sum = sum-nums[i];<br>            list.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>如果你能够成功的生成所有无重子集，那么你稍微改改代码就能生成所有无重组合了。</p><p><strong>因此集合和子集是相同的</strong></p><p>给定两个整数<code>n</code>和<code>k</code>，返回范围<code>[1, n]</code>中所有可能的<code>k</code>个数的组合。</p><p>函数签名如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">List&lt;List&lt;Integer&gt;&gt; combine(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>, <span class="hljs-built_in">int</span> k)<br></code></pre></td></tr></table></figure><p>比如<code>combine(3, 2)</code>的返回值应该是：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span> ]</span><br></code></pre></td></tr></table></figure><p>这是标准的组合问题，但换一种说就成了子集，</p><p><strong>给你输入一个数组<code>nums = [1,2..,n]</code>和一个正整数<code>k</code>，请你生成所有大小为<code>k</code>的子集</strong>。</p><p><img src="/2022/08/22/%E5%9B%9E%E6%BA%AF%E6%B3%95/640" alt="图片"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testCom</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        com(<span class="hljs-number">1</span>,n,k);<br>        System.out.println(res.toString());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">com</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k)</span>&#123;<br>        <span class="hljs-keyword">if</span> (k== list.size())&#123;<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(list));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a;i&lt;=n;i++)&#123;<br>            list.add(i);<br>            com(i+<span class="hljs-number">1</span>,n,k);<br>            list.removeLast();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合和子集相同，可以直接看子集。</p><h1 id="框架总结"><a href="#框架总结" class="headerlink" title="框架总结"></a>框架总结</h1><h2 id="形式一、元素无重不可复选"><a href="#形式一、元素无重不可复选" class="headerlink" title="形式一、元素无重不可复选"></a><strong>形式一、元素无重不可复选</strong></h2><p><strong>即<code>nums</code>中的元素都是唯一的，每个元素最多只能被使用一次</strong>，<code>backtrack</code>核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 组合/子集问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>    <span class="hljs-comment">// 回溯算法标准框架</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.addLast(nums[i]);<br>        <span class="hljs-comment">// 注意参数</span><br>        backtrack(nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 排列问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 剪枝逻辑</span><br>        <span class="hljs-keyword">if</span> (used[i]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 做选择</span><br>        used[i] = <span class="hljs-literal">true</span>;<br>        track.addLast(nums[i]);<br><br>        backtrack(nums);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>        used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="形式二、元素可重不可复选"><a href="#形式二、元素可重不可复选" class="headerlink" title="形式二、元素可重不可复选"></a><strong>形式二、元素可重不可复选</strong></h2><p><strong>即<code>nums</code>中的元素可以存在重复，每个元素最多只能被使用一次</strong>，其关键在于排序和剪枝，<code>backtrack</code>核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(nums);<br><span class="hljs-comment">/* 组合/子集问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>    <span class="hljs-comment">// 回溯算法标准框架</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 剪枝逻辑，跳过值相同的相邻树枝</span><br>        <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 做选择</span><br>        track.addLast(nums[i]);<br>        <span class="hljs-comment">// 注意参数</span><br>        backtrack(nums, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br><br><br>Arrays.sort(nums);<br><span class="hljs-comment">/* 排列问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 剪枝逻辑</span><br>        <span class="hljs-keyword">if</span> (used[i]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 剪枝逻辑，固定相同的元素在排列中的相对位置</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 做选择</span><br>        used[i] = <span class="hljs-literal">true</span>;<br>        track.addLast(nums[i]);<br><br>        backtrack(nums);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>        used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="形式三、元素无重可复选"><a href="#形式三、元素无重可复选" class="headerlink" title="形式三、元素无重可复选"></a><strong>形式三、元素无重可复选</strong></h2><p><strong>即<code>nums</code>中的元素都是唯一的，每个元素可以被使用若干次</strong>，只要删掉去重逻辑即可，<code>backtrack</code>核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 组合/子集问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> &#123;<br>    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br>    <span class="hljs-comment">// 回溯算法标准框架</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.addLast(nums[i]);<br>        <span class="hljs-comment">// 注意参数</span><br>        backtrack(nums, i);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/* 排列问题回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.addLast(nums[i]);<br><br>        backtrack(nums);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>回溯法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/08/22/Git/"/>
    <url>/2022/08/22/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote><p>Git是分布式版本控制工具，主要用于管理开发过程中的源代码文件（Java类、xml文件、html页面等）。</p></blockquote><h2 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h2><p><img src="/2022/08/22/Git/image-20220822085724395.png" alt="image-20220822085724395"></p><h2 id="Git下载安装"><a href="#Git下载安装" class="headerlink" title="Git下载安装"></a>Git下载安装</h2><p>下载路径:<a href="https://git-scm.com/download">https://git-scm.com/download</a></p><p>安装成功后，在任意目录下右键，可以显示：</p><p><img src="/2022/08/22/Git/image-20220822090055165.png" alt="image-20220822090055165"></p><p>其中</p><p><code>Git GUI Here：</code>打开Git图形界面</p><p><code>Git Bash Here:</code>打开Git命令行</p><h2 id="Git代码托管服务"><a href="#Git代码托管服务" class="headerlink" title="Git代码托管服务"></a>Git代码托管服务</h2><p>以gitee为例，注册账号，登录账号，新建仓库。</p><p><img src="/2022/08/22/Git/image-20220822091048308.png" alt="image-20220822091048308"></p><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="Git全局设置"><a href="#Git全局设置" class="headerlink" title="Git全局设置"></a>Git全局设置</h3><p>当安装Git后首先要做的是设置用户名和email地址，这是非常重要的，因为每次提交都会使用该用户的信息。</p><p>在Git命令中执行以下：</p><p><code>git config --global user.name</code></p><p><img src="/2022/08/22/Git/image-20220822091743137.png" alt="image-20220822091743137"></p><p><code>git config --global user.email</code></p><p><img src="/2022/08/22/Git/image-20220822091748656.png" alt="image-20220822091748656"></p><p>查看配置信息：</p><p><code>git config --list</code></p><p><img src="/2022/08/22/Git/image-20220822091809664.png" alt="image-20220822091809664"></p><h3 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h3><p><img src="/2022/08/22/Git/image-20220822091911085.png" alt="image-20220822091911085"></p><p><strong>（1）在本地初始化一个Git仓库</strong></p><p><code>git init</code></p><p><img src="/2022/08/22/Git/image-20220822092406019.png" alt="image-20220822092406019"></p><p><strong>（2）从远程克隆</strong></p><p>复制远程仓库的地址：</p><p><img src="/2022/08/22/Git/image-20220822092427908.png" alt="image-20220822092427908"></p><p>执行以下命令：</p><p><code>git clone</code></p><p><img src="/2022/08/22/Git/image-20220822092558274.png" alt="image-20220822092558274"></p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><img src="/2022/08/22/Git/image-20220822104044152.png" alt="image-20220822104044152"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="本地仓库操作的命令"><a href="#本地仓库操作的命令" class="headerlink" title="本地仓库操作的命令"></a>本地仓库操作的命令</h3><p><img src="/2022/08/22/Git/image-20220823204616363.png" alt="image-20220823204616363"></p><p><code>git commit -m &quot;init user.java&quot; user.java</code>:其中”init user.java”可以随意写，是log日志。</p><p>切换到指定版本：</p><p><img src="/2022/08/22/Git/image-20220823205059464.png" alt="image-20220823205059464"></p><h3 id="远程仓库操作的命令"><a href="#远程仓库操作的命令" class="headerlink" title="远程仓库操作的命令"></a>远程仓库操作的命令</h3><p><img src="/2022/08/22/Git/image-20220823205433537.png" alt="image-20220823205433537"></p><p><code>git remote</code>:展示的不够完全，<code>git remote -v</code>：展示的完全</p><p><img src="/2022/08/22/Git/image-20220823205721615.png" alt="image-20220823205721615"></p><p><code>git remote add 别名 url地址</code>：让本地创建的仓库与远程的仓库关联。</p><p>下面这个仓库repo1是本地初始化的仓库</p><p>想要与远程仓库建立联系要进行操作：</p><p><img src="/2022/08/22/Git/image-20220823210331912.png" alt="image-20220823210331912"></p><p><code>git push origin master</code>：将本地文件推送到远程仓库</p><p><img src="/2022/08/22/Git/image-20220823211302960.png" alt="image-20220823211302960"></p><p><strong>将文件推送到远程仓库时，切记先要提交给本地仓库后再推送到远程仓库，就是上图的步骤</strong></p><p><img src="/2022/08/22/Git/image-20220823211411991.png" alt="image-20220823211411991"></p><p><code>git pull origin master</code>：主要用于多人协作，将远程上的东西拉取下来，一般是某个人推送上去，另一人拉取下来。</p><p><img src="/2022/08/22/Git/image-20220823212800237.png" alt="image-20220823212800237"></p><p><strong>注意：</strong></p><p>如果本地仓库不是从远程仓库克隆下来的，而是本地初始化的话，此时再从远程仓库拉取文件将会报错。因为没有关联之前的文件是没有相关性的，不能合并。要加入下面的语句：</p><p><code>--allow-unrelated-histories</code>      完整的：  <code>git push origin master --allow-unrelated-histories</code></p><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p><img src="/2022/08/22/Git/image-20220823213457668.png" alt="image-20220823213457668"></p><p><strong>查看分支</strong></p><p>git branck：查看本地分支</p><p>git branch -r:列出所有远程分支</p><p>git branch -a :列出所有本地和远程的分支</p><p><img src="/2022/08/22/Git/image-20220823214250863.png" alt="image-20220823214250863"></p><p><strong>创建分支</strong></p><p><img src="/2022/08/22/Git/image-20220823215337530.png" alt="image-20220823215337530"></p><p><strong>切换分支</strong></p><p><img src="/2022/08/22/Git/image-20220823215417676.png" alt="image-20220823215417676"></p><p><strong>将分支推送至远程</strong></p><p><img src="/2022/08/22/Git/image-20220823215352630.png" alt="image-20220823215352630"></p><p><img src="/2022/08/22/Git/image-20220823215359005.png" alt="image-20220823215359005"></p><p><strong>合并分支</strong></p><p><img src="/2022/08/22/Git/image-20220823220120130.png" alt="image-20220823220120130"></p><h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><p><img src="/2022/08/22/Git/image-20220824093538544.png" alt="image-20220824093538544"></p><p>以repo2为例：</p><p><img src="/2022/08/22/Git/image-20220824094245773.png" alt="image-20220824094245773"></p><p><img src="/2022/08/22/Git/image-20220824094254892.png" alt="image-20220824094254892"></p><p><strong>检出标签时，要新建一个分支来指向某个标签，</strong></p><p><img src="/2022/08/22/Git/image-20220824094435083.png" alt="image-20220824094435083"></p><p><img src="/2022/08/22/Git/image-20220824094419085.png" alt="image-20220824094419085"></p><p><img src="/2022/08/22/Git/image-20220824094425944.png" alt="image-20220824094425944"></p><h2 id="在IDEA中使用Git"><a href="#在IDEA中使用Git" class="headerlink" title="在IDEA中使用Git"></a>在IDEA中使用Git</h2><h3 id="本地初始化仓库"><a href="#本地初始化仓库" class="headerlink" title="本地初始化仓库"></a>本地初始化仓库</h3><p><img src="/2022/08/22/Git/image-20220824135419327.png" alt="image-20220824135419327"></p><p><img src="/2022/08/22/Git/image-20220824135610735.png" alt="image-20220824135610735"></p><p><img src="/2022/08/22/Git/image-20220824135624799.png" alt="image-20220824135624799"></p><h3 id="从远程克隆仓库"><a href="#从远程克隆仓库" class="headerlink" title="从远程克隆仓库"></a>从远程克隆仓库</h3><p><strong>方式一：点击Get from VCS</strong></p><p><img src="/2022/08/22/Git/image-20220824135830143.png" alt="image-20220824135830143"></p><p><img src="/2022/08/22/Git/image-20220824135838423.png" alt="image-20220824135838423"></p><p><strong>方式二：</strong></p><p><img src="/2022/08/22/Git/image-20220824135920425.png" alt="image-20220824135920425"></p><p>填写远程仓库的url地址</p><p><img src="/2022/08/22/Git/image-20220824135931849.png" alt="image-20220824135931849"></p><h2 id="在IDEA中操作Git"><a href="#在IDEA中操作Git" class="headerlink" title="在IDEA中操作Git"></a>在IDEA中操作Git</h2><h3 id="本地仓库的操作"><a href="#本地仓库的操作" class="headerlink" title="本地仓库的操作"></a>本地仓库的操作</h3><p><img src="/2022/08/22/Git/image-20220824140443197.png" alt="image-20220824140443197"></p><p><strong>将类加入到暂存区</strong></p><p><img src="/2022/08/22/Git/image-20220824140353439.png" alt="image-20220824140353439"></p><p><strong>将暂存区的文件提交到版本库</strong></p><p>下图中的√就是提交</p><p><img src="/2022/08/22/Git/image-20220824140700241.png" alt="image-20220824140700241"></p><p><strong>查看日志</strong></p><p>下图中一个小钟的图形就可以查看日志</p><h3 id="远程仓库的操作"><a href="#远程仓库的操作" class="headerlink" title="远程仓库的操作"></a>远程仓库的操作</h3><p><img src="/2022/08/22/Git/image-20220824140926453.png" alt="image-20220824140926453"></p><p><strong>查看远程仓库</strong></p><p><img src="/2022/08/22/Git/image-20220824141351657.png" alt="image-20220824141351657"></p><p><img src="/2022/08/22/Git/image-20220824141404377.png" alt="image-20220824141404377"></p><p><strong>添加远程仓库</strong></p><p>按下面的加号进行添加</p><p><img src="/2022/08/22/Git/image-20220824141458844.png" alt="image-20220824141458844"></p><p><strong>推送远程仓库</strong></p><p><img src="/2022/08/22/Git/image-20220824141713621.png" alt="image-20220824141713621"></p><p>提交并推送：（第一个是只提交，第二个是提交并推送）</p><p><img src="/2022/08/22/Git/image-20220824141836404.png" alt="image-20220824141836404"></p><p><strong>从远程仓库拉取</strong></p><p>点击向下的箭头</p><p><img src="/2022/08/22/Git/image-20220824140700241.png" alt="image-20220824140700241"></p><h3 id="在IDEA中分支操作"><a href="#在IDEA中分支操作" class="headerlink" title="在IDEA中分支操作"></a>在IDEA中分支操作</h3><p><img src="/2022/08/22/Git/image-20220824142045040.png" alt="image-20220824142045040"></p><p><strong>查看分支</strong></p><p>快捷方式：点击右下角的master分支进行查看</p><p><img src="/2022/08/22/Git/image-20220824142615707.png" alt="image-20220824142615707"></p><p><img src="/2022/08/22/Git/image-20220824142629848.png" alt="image-20220824142629848"></p><p><strong>创建分支</strong></p><p><img src="/2022/08/22/Git/image-20220824142721945.png" alt="image-20220824142721945"></p><p><strong>切换分支</strong></p><p>也是以上的操作，选择要切换的分支</p><p><strong>将分支推送到远程仓库</strong></p><p>点击要推送分支里面的push</p><p><strong>合并分支</strong></p><p>master合并b1分支时：</p><p><img src="/2022/08/22/Git/image-20220824143027816.png" alt="image-20220824143027816"></p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>括号生成</title>
    <link href="/2022/08/19/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2022/08/19/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode-括号生成"><a href="#leetCode-括号生成" class="headerlink" title="leetCode-括号生成"></a>leetCode-括号生成</h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><h2 id="解法一（DFS）"><a href="#解法一（DFS）" class="headerlink" title="解法一（DFS）"></a>解法一（DFS）</h2><p><strong>过程：</strong></p><p><img src="/2022/08/19/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/7ec04f84e936e95782aba26c4663c5fe7aaf94a2a80986a97d81574467b0c513-LeetCode%20%E7%AC%AC%2022%20%E9%A2%98%EF%BC%9A%E2%80%9C%E6%8B%AC%E5%8F%B7%E7%94%9F%E5%87%BA%E2%80%9D%E9%A2%98%E8%A7%A3%E9%85%8D%E5%9B%BE.png" alt="LeetCode 第 22 题：“括号生出”题解配图.png"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><br>        returnList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(),n,n);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnList</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span> (left==<span class="hljs-number">0</span> &amp;&amp; right==<span class="hljs-number">0</span>)&#123;<br>            res.add(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left&gt;right)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left&gt;<span class="hljs-number">0</span>)&#123;<br>            returnList(s+<span class="hljs-string">&#x27;(&#x27;</span>,left-<span class="hljs-number">1</span>,right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right&gt;<span class="hljs-number">0</span>)&#123;<br>            returnList(s+<span class="hljs-string">&#x27;)&#x27;</span>,left,right-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二（慢慢-分析）"><a href="#解法二（慢慢-分析）" class="headerlink" title="解法二（慢慢 分析）"></a>解法二（慢慢 分析）</h2><p>回溯的灵魂就是画出数的结构图，首先先将所有的情况都列出：</p><p><img src="/2022/08/19/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/1612765058-NToQkc-image.png" alt="image.png"></p><p>观察上图就是一个满二叉树，我们只需要DFS去遍历所有的节点即可，先把最基本的实现，热后再去改进，</p><p>基本的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><br>        returnList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(),n);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnList</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">2</span>*n) &#123;<br>            res.add(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        returnList(s + <span class="hljs-string">&#x27;(&#x27;</span>,n);<br>        returnList(s + <span class="hljs-string">&#x27;)&#x27;</span>, n);<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[<span class="hljs-string">&quot;((((&quot;</span>,<span class="hljs-string">&quot;((()&quot;</span>,<span class="hljs-string">&quot;(()(&quot;</span>,<span class="hljs-string">&quot;(())&quot;</span>,<span class="hljs-string">&quot;()((&quot;</span>,<span class="hljs-string">&quot;()()&quot;</span>,<span class="hljs-string">&quot;())(&quot;</span>,<span class="hljs-string">&quot;()))&quot;</span>,<span class="hljs-string">&quot;)(((&quot;</span>,<span class="hljs-string">&quot;)(()&quot;</span>,<span class="hljs-string">&quot;)()(&quot;</span>,<span class="hljs-string">&quot;)())&quot;</span>,<span class="hljs-string">&quot;))((&quot;</span>,<span class="hljs-string">&quot;))()&quot;</span>,<span class="hljs-string">&quot;)))(&quot;</span>,<span class="hljs-string">&quot;))))&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>观察不需要的括号特点，<code>((((</code>和<code>))))</code>实际上已经超过n了，我们生成同一方向的括号只需要n个即可，在生成的时候我们要限制住左括号与右括号生成的数量</p><p>这时我增加了left与right参数，分别代表左括号与右括号的数量，每生成一个我就增加一个。</p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><br>        returnList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(),<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,n);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnList</span><span class="hljs-params">(String s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left&gt;n || right&gt;n) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (right&gt;left) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">2</span>*n) &#123;<br>            res.add(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        returnList(s + <span class="hljs-string">&#x27;(&#x27;</span>, left+<span class="hljs-number">1</span>,right,n);<br>        returnList(s + <span class="hljs-string">&#x27;)&#x27;</span>, left,right+<span class="hljs-number">1</span>,n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>后台管理端-订单明细</title>
    <link href="/2022/08/19/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%AB%AF-%E8%AE%A2%E5%8D%95%E6%98%8E%E7%BB%86/"/>
    <url>/2022/08/19/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%AB%AF-%E8%AE%A2%E5%8D%95%E6%98%8E%E7%BB%86/</url>
    
    <content type="html"><![CDATA[<h1 id="订单明细展示"><a href="#订单明细展示" class="headerlink" title="订单明细展示"></a>订单明细展示</h1><h2 id="发送的需求"><a href="#发送的需求" class="headerlink" title="发送的需求"></a>发送的需求</h2><p><img src="/2022/08/19/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%AB%AF-%E8%AE%A2%E5%8D%95%E6%98%8E%E7%BB%86/image-20220819090218439.png" alt="image-20220819090218439"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 后台展示订单明细</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> number</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> beginTime</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> endTime</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br>   <span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page, <span class="hljs-type">int</span> pageSize, String number, String beginTime, String endTime )</span>&#123;<br><br>       <span class="hljs-comment">//获取分页构造器</span><br>       Page&lt;Orders&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(page, pageSize);<br><br>       <span class="hljs-comment">//由于Orders中没有用户名称，因此要使用OrderDto</span><br>       Page&lt;OrderDto&gt; dtoPage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;();<br><br>       <span class="hljs-comment">//根据条件查询订单</span><br>       LambdaQueryWrapper&lt;Orders&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>       lambdaQueryWrapper.eq(number!=<span class="hljs-literal">null</span>,Orders::getNumber,number);<br><br>       <span class="hljs-keyword">if</span>(beginTime!=<span class="hljs-literal">null</span>&amp;&amp;endTime!=<span class="hljs-literal">null</span>)&#123;<br>           lambdaQueryWrapper.ge(Orders::getOrderTime,beginTime);<br>           lambdaQueryWrapper.le(Orders::getOrderTime,endTime);<br>       &#125;<br>       lambdaQueryWrapper.orderByDesc(Orders::getOrderTime);<br><br>       <span class="hljs-comment">//执行分页查询</span><br>       orderService.page(pageInfo,lambdaQueryWrapper);<br><br>       <span class="hljs-comment">//拷贝属性，并更改records</span><br>       BeanUtils.copyProperties(pageInfo,dtoPage,<span class="hljs-string">&quot;records&quot;</span>);<br><br>       <span class="hljs-comment">//获取records</span><br>       List&lt;Orders&gt; orders = pageInfo.getRecords();<br>       <span class="hljs-comment">//更改records中的用户名称</span><br>       List&lt;OrderDto&gt; dtoList = orders.stream().map((item)-&gt;&#123;<br>           <span class="hljs-comment">//新建orderDto</span><br>           <span class="hljs-type">OrderDto</span> <span class="hljs-variable">orderDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDto</span>();<br>           <span class="hljs-comment">//将订单中的每一项拷贝到orderDto中</span><br>           BeanUtils.copyProperties(item,orderDto);<br>           String name=<span class="hljs-string">&quot;用户&quot;</span>+item.getUserId();<br>           <span class="hljs-comment">//设置orderDto中的名字</span><br>           orderDto.setUserName(name);<br>           <span class="hljs-keyword">return</span> orderDto;<br>       &#125;).collect(Collectors.toList());<br>       <span class="hljs-comment">//设置dtoPage中的记录</span><br>       dtoPage.setRecords(dtoList);<br>       <span class="hljs-keyword">return</span> R.success(dtoPage);<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="发起派送"><a href="#发起派送" class="headerlink" title="发起派送"></a>发起派送</h1><h2 id="发送的请求"><a href="#发送的请求" class="headerlink" title="发送的请求"></a>发送的请求</h2><p><img src="/2022/08/19/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%AB%AF-%E8%AE%A2%E5%8D%95%E6%98%8E%E7%BB%86/image-20220819090417890.png" alt="image-20220819090417890"></p><p>请求体为：</p><p><img src="/2022/08/19/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%AB%AF-%E8%AE%A2%E5%8D%95%E6%98%8E%E7%BB%86/image-20220819090608365.png" alt="image-20220819090608365"></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 派送</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">updateStatus</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Orders orders)</span>&#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> orders.getId();<br>        LambdaQueryWrapper&lt;Orders&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(Orders::getId,id);<br>        <span class="hljs-comment">//获取查询的订单</span><br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> orderService.getOne(lambdaQueryWrapper);<br>        <span class="hljs-comment">//改变订单的状态</span><br>        one.setStatus(orders.getStatus());<br>        <span class="hljs-comment">//更新这条数据</span><br>        orderService.updateById(one);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;派送成功&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java与mysql类型对应</title>
    <link href="/2022/08/18/java%E4%B8%8Emysql%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94/"/>
    <url>/2022/08/18/java%E4%B8%8Emysql%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/08/18/java%E4%B8%8Emysql%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94/image-20220818213854371.png" alt="image-20220818213854371"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖-移动端用户下单</title>
    <link href="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/"/>
    <url>/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="用户下单"><a href="#用户下单" class="headerlink" title="用户下单"></a>用户下单</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/image-20220818100327671.png" alt="image-20220818100327671"></p><h2 id="代码的交互过程"><a href="#代码的交互过程" class="headerlink" title="代码的交互过程"></a>代码的交互过程</h2><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/image-20220818101000799.png" alt="image-20220818101000799"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/image-20220818101241566.png" alt="image-20220818101241566"></p><h2 id="去支付"><a href="#去支付" class="headerlink" title="去支付"></a>去支付</h2><p><strong>发送的请求：</strong></p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/image-20220818102037249.png" alt="image-20220818102037249"></p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/image-20220818102048544.png" alt="image-20220818102048544"></p><p><strong>流程：</strong></p><ul><li>获取当前用户ID</li><li>查询当前用户的购物车数据</li><li>像订单插入数据，一条数据</li><li>像订单明细表插入数据，多条数据（订单里面可能有多条商品）</li><li>清空购物车数据</li><li>因为要操作两个表，因此要加入事务注解</li></ul><p><strong>OrderServiceImpl.java的代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;OrderMapper, Orders&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ShoppingCartService shoppingCartService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AddressBookService addressBookService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderDetailService orderDetailService;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">submit</span><span class="hljs-params">(Orders orders)</span>&#123;<br>        <span class="hljs-comment">//获取用户ID</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getId();<br><br><br>        <span class="hljs-comment">//查询当前用户的购物车数据</span><br>        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(ShoppingCart::getUserId,userId);<br>        List&lt;ShoppingCart&gt; shoppingCarts = shoppingCartService.list(lambdaQueryWrapper);<br>        <span class="hljs-comment">//判断购物车是否为空</span><br>        <span class="hljs-keyword">if</span> (shoppingCarts==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomException</span>(<span class="hljs-string">&quot;购物车为空，不能下单&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//查询地址信息</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">addressBookId</span> <span class="hljs-operator">=</span> orders.getAddressBookId();<br>        <span class="hljs-type">AddressBook</span> <span class="hljs-variable">addressBook</span> <span class="hljs-operator">=</span> addressBookService.getById(addressBookId);<br>        <span class="hljs-keyword">if</span> (addressBook==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomException</span>(<span class="hljs-string">&quot;地址信息为空，不能下单&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//查询用户信息</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(userId);<br><br>        <span class="hljs-comment">//通过IdWork生成订单号</span><br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> IdWorker.getId();<br><br>        <span class="hljs-comment">//计算总金额</span><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<span class="hljs-comment">//具有原子性</span><br><br>        <span class="hljs-comment">//通过获取购物车中商品的信息来保存订单明细</span><br>        List&lt;OrderDetail&gt; orderDetails = shoppingCarts.stream().map((item)-&gt;&#123;<br>            <span class="hljs-type">OrderDetail</span> <span class="hljs-variable">orderDetail</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDetail</span>();<br>            orderDetail.setOrderId(orderId);<span class="hljs-comment">//设置订单编号</span><br>            orderDetail.setNumber(item.getNumber());<span class="hljs-comment">//设置数量</span><br>            orderDetail.setImage(item.getImage());<br>            orderDetail.setName(item.getName());<br>            orderDetail.setDishId(item.getDishId());<br>            orderDetail.setSetmealId(item.getSetmealId());<br>            orderDetail.setDishFlavor(item.getDishFlavor());<br>            orderDetail.setAmount(item.getAmount());<br>            amount.addAndGet(item.getAmount().multiply(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(item.getNumber())).intValue());<span class="hljs-comment">//数量*金额</span><br>            <span class="hljs-keyword">return</span> orderDetail;<br>        &#125;).collect(Collectors.toList());<br><br>        <span class="hljs-comment">//保存订单信息</span><br>        orders.setNumber(String.valueOf(orderId));<br>        orders.setStatus(<span class="hljs-number">2</span>);<br>        orders.setUserId(userId);<br>        orders.setOrderTime(LocalDateTime.now());<br>        orders.setCheckoutTime(LocalDateTime.now());<br>        orders.setAmount(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(amount.get()));<br>        orders.setUserName(user.getName());<br>        orders.setConsignee(addressBook.getConsignee());<br>        orders.setPhone(addressBook.getPhone());<br>        orders.setAddress((addressBook.getProvinceName()==<span class="hljs-literal">null</span>?<span class="hljs-string">&quot;&quot;</span>:addressBook.getProvinceName())<br>                +(addressBook.getCityName()==<span class="hljs-literal">null</span>?<span class="hljs-string">&quot;&quot;</span>:addressBook.getCityName())<br>                +(addressBook.getDistrictName()==<span class="hljs-literal">null</span>?<span class="hljs-string">&quot;&quot;</span>:addressBook.getDistrictName())<br>                +(addressBook.getDetail()==<span class="hljs-literal">null</span>?<span class="hljs-string">&quot;&quot;</span>:addressBook.getDetail()));<br><br><br>        <span class="hljs-comment">//插入订单数据，一条数据</span><br>        orderService.save(orders);<br><br>        <span class="hljs-comment">//插入订单明细数据，多条数据</span><br>        orderDetailService.saveBatch(orderDetails);<br><br>        <span class="hljs-comment">//清空购物车</span><br>        shoppingCartService.remove(lambdaQueryWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>OrderController.java代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submit&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Orders orders)</span>&#123;<br>        orderService.submit(orders);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;支付成功&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="查看订单"><a href="#查看订单" class="headerlink" title="查看订单"></a>查看订单</h1><h2 id="发送的请求"><a href="#发送的请求" class="headerlink" title="发送的请求"></a>发送的请求</h2><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/image-20220818203847751.png" alt="image-20220818203847751"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><code>OrderController.java:</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/userPage&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page,<span class="hljs-type">int</span> pageSize)</span>&#123;<br>        <span class="hljs-comment">//构造分页构造器</span><br>        <span class="hljs-type">Page</span> <span class="hljs-variable">pageInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(page,pageSize);<br>        <span class="hljs-comment">//构造条件构造器</span><br>        LambdaQueryWrapper&lt;Orders&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.orderByDesc(Orders::getOrderTime);<br>        orderService.page(pageInfo,lambdaQueryWrapper);<br><br>        <span class="hljs-keyword">return</span> R.success(pageInfo);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="用户退出登录"><a href="#用户退出登录" class="headerlink" title="用户退出登录"></a>用户退出登录</h1><h2 id="发送的请求-1"><a href="#发送的请求-1" class="headerlink" title="发送的请求"></a>发送的请求</h2><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/image-20220818204116522.png" alt="image-20220818204116522"></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>UserController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/loginout&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">loginout</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>        request.getSession().removeAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;退出成功&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="当订单完成时，再来一单"><a href="#当订单完成时，再来一单" class="headerlink" title="当订单完成时，再来一单"></a>当订单完成时，再来一单</h1><h2 id="发送的请求-2"><a href="#发送的请求-2" class="headerlink" title="发送的请求"></a>发送的请求</h2><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%94%A8%E6%88%B7%E4%B8%8B%E5%8D%95/image-20220818211327177.png" alt="image-20220818211327177"></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 再来一单</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/again&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">again</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Orders orders)</span>&#123;<br>        <span class="hljs-comment">//获取该订单</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> orders.getId();<br>        <span class="hljs-type">Orders</span> <span class="hljs-variable">orderNew</span> <span class="hljs-operator">=</span> orderService.getById(id);<br>        <span class="hljs-comment">//设置订单号</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">id1</span> <span class="hljs-operator">=</span> IdWorker.getId();<br>        orderNew.setNumber(String.valueOf(id1));<br>        orderNew.setId(IdWorker.getId());<br>        orderNew.setStatus(<span class="hljs-number">2</span>);;<br>        orderNew.setOrderTime(LocalDateTime.now());<br>        orderNew.setCheckoutTime(LocalDateTime.now());<br>        orderService.save(orderNew);<br>        <span class="hljs-comment">//修改订单明细表</span><br>        LambdaQueryWrapper&lt;OrderDetail&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(OrderDetail::getOrderId,id);<br>        List&lt;OrderDetail&gt; list = orderDetailService.list(lambdaQueryWrapper);<br>        list.stream().map((item)-&gt;&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">id2</span> <span class="hljs-operator">=</span> IdWorker.getId();<br>            item.setOrderId(id1);<br>            item.setImage(String.valueOf(id2));<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;).collect(Collectors.toList());<br>        orderDetailService.saveBatch(list);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;再来一单&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖-移动端验证码和菜品展示</title>
    <link href="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    <url>/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><h2 id="短信发送"><a href="#短信发送" class="headerlink" title="短信发送"></a>短信发送</h2><p>在阿里云申请</p><p><strong>代码实现为：</strong></p><p>添加以下两个依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>          &lt;groupId&gt;com.aliyun&lt;/groupId&gt;<br>          &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;<br>          &lt;version&gt;<span class="hljs-number">4.5</span><span class="hljs-number">.16</span>&lt;/version&gt;<br>      &lt;/dependency&gt;<br><br>      &lt;dependency&gt;<br>          &lt;groupId&gt;com.aliyun&lt;/groupId&gt;<br>          &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt;<br>          &lt;version&gt;<span class="hljs-number">2.1</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>      &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>短信发送工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 短信发送工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SMSUtils</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送短信</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> signName 签名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> templateCode 模板</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> phoneNumbers 手机号</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> param 参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(String signName, String templateCode,String phoneNumbers,String param)</span>&#123;<br><span class="hljs-type">DefaultProfile</span> <span class="hljs-variable">profile</span> <span class="hljs-operator">=</span> DefaultProfile.getProfile(<span class="hljs-string">&quot;cn-hangzhou&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-type">IAcsClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultAcsClient</span>(profile);<br><br><span class="hljs-type">SendSmsRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendSmsRequest</span>();<br>request.setSysRegionId(<span class="hljs-string">&quot;cn-hangzhou&quot;</span>);<br>request.setPhoneNumbers(phoneNumbers);<br>request.setSignName(signName);<br>request.setTemplateCode(templateCode);<br>request.setTemplateParam(<span class="hljs-string">&quot;&#123;\&quot;code\&quot;:\&quot;&quot;</span>+param+<span class="hljs-string">&quot;\&quot;&#125;&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">SendSmsResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.getAcsResponse(request);<br>System.out.println(<span class="hljs-string">&quot;短信发送成功&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (ClientException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>随机生成验证码工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zlw.reggie.utils;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 随机生成验证码工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidateCodeUtils</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 随机生成验证码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> length 长度为4位或者6位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">generateValidateCode</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span>&#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span><span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(length == <span class="hljs-number">4</span>)&#123;<br>            code = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">9999</span>);<span class="hljs-comment">//生成随机数，最大为9999</span><br>            <span class="hljs-keyword">if</span>(code &lt; <span class="hljs-number">1000</span>)&#123;<br>                code = code + <span class="hljs-number">1000</span>;<span class="hljs-comment">//保证随机数为4位数字</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(length == <span class="hljs-number">6</span>)&#123;<br>            code = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">999999</span>);<span class="hljs-comment">//生成随机数，最大为999999</span><br>            <span class="hljs-keyword">if</span>(code &lt; <span class="hljs-number">100000</span>)&#123;<br>                code = code + <span class="hljs-number">100000</span>;<span class="hljs-comment">//保证随机数为6位数字</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;只能生成4位或6位数字验证码&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 随机生成指定长度字符串验证码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> length 长度</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateValidateCode4String</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span>&#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">rdm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">hash1</span> <span class="hljs-operator">=</span> Integer.toHexString(rdm.nextInt());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">capstr</span> <span class="hljs-operator">=</span> hash1.substring(<span class="hljs-number">0</span>, length);<br>        <span class="hljs-keyword">return</span> capstr;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="手机验证码登录"><a href="#手机验证码登录" class="headerlink" title="手机验证码登录"></a>手机验证码登录</h2><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220816214823174.png" alt="image-20220816214823174"></p><p><strong>准备工作：</strong></p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220816214856763.png" alt="image-20220816214856763"></p><p>准备之后，查看发送验证码和登录的url，为</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;/user/sendMsg&quot;</span>,<br><span class="hljs-string">&quot;/user/login&quot;</span><br></code></pre></td></tr></table></figure><p>因此要在过滤器中添加这两个地址，为了不进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置那些请求不拦截,,不拦截的是访问的uri，而不是静态js</span><br>        String [] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>                <span class="hljs-string">&quot;/employee/login&quot;</span>,<br>                <span class="hljs-string">&quot;/employee/logout&quot;</span>,<br>                <span class="hljs-string">&quot;/backend/**&quot;</span>,<br>                <span class="hljs-string">&quot;/front/**&quot;</span>,<br>                <span class="hljs-string">&quot;/common/upload&quot;</span>,<br>                <span class="hljs-string">&quot;/common/download&quot;</span>,<br>                <span class="hljs-string">&quot;/user/sendMsg&quot;</span>,<br>                <span class="hljs-string">&quot;/user/login&quot;</span><br><br>        &#125;;<br></code></pre></td></tr></table></figure><p>如果需要进行拦截，与则需要和之前一样的判断，判断是否已经登录，如果登录则放行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断移动端的用户：根据userid进行判断是否放行</span><br>        <span class="hljs-keyword">if</span> (request.getSession().getAttribute(<span class="hljs-string">&quot;user&quot;</span>)!=<span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;是拦截路径，用户已经登录，id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="hljs-string">&quot;user&quot;</span>));<br>            <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) request.getSession().getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br><br>            BaseContext.setCurrentId(userId);<br><br>            filterChain.doFilter(request,response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>UserController.java的代码为：</strong></p><p>发送验证码的url：</p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817111919962.png" alt="image-20220817111919962"></p><p>登录的url：</p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817111939040.png" alt="image-20220817111939040"></p><p>根据以上两个url进行编写Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移动端发送验证码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/sendMsg&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user, HttpSession httpSession)</span>&#123;<br>        <span class="hljs-comment">//获取手机号</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> user.getPhone();<br>        <span class="hljs-comment">//判断手机号是否为空</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(phone))&#123;<br>            <span class="hljs-comment">//随机生成4为验证码,通过工具类</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> ValidateCodeUtils.generateValidateCode(<span class="hljs-number">4</span>).toString();<br>            log.info(<span class="hljs-string">&quot;code=&#123;&#125;&quot;</span>,code);<br>            <span class="hljs-comment">//使用阿里云提供的短信服务API完成发送短信</span><br><span class="hljs-comment">//            SMSUtils.sendMessage(&quot;瑞吉外卖&quot;,&quot;&quot;,phone,integer);</span><br><br>            <span class="hljs-comment">//将生成的验证码保存到session中</span><br>            httpSession.setAttribute(phone,code);<br><br>            <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;手机验证码短信发送成功&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;短信发送失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移动端进行登录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;User&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Map map,HttpSession httpSession)</span>&#123;<br><br>        <span class="hljs-comment">//获取手机号</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;phone&quot;</span>).toString();<br><br>        <span class="hljs-comment">//获取验证码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> map.gset(<span class="hljs-string">&quot;code&quot;</span>).toString();<br><br>        <span class="hljs-comment">//获取session里面的验证码</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">codeInSession</span> <span class="hljs-operator">=</span> httpSession.getAttribute(phone);<br>        <span class="hljs-comment">//比较是否相等</span><br>        <span class="hljs-keyword">if</span> (codeInSession!=<span class="hljs-literal">null</span> &amp;&amp; codeInSession.equals(code))&#123;<br>            <span class="hljs-comment">//如果相等则登录成功，从数据库中查询user，如果能查询到则是老用户已经注册，直接返回user，如果没有查到则要进行注册</span><br>            LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>            lambdaQueryWrapper.eq(User::getPhone,phone);<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getOne(lambdaQueryWrapper);<br><br>            <span class="hljs-comment">//判断当前手机号对应的用户是否为新用户，如果是新用户则注册。</span><br>            <span class="hljs-keyword">if</span> (user==<span class="hljs-literal">null</span>)&#123;<br>                user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                user.setPhone(phone);<br>                user.setStatus(<span class="hljs-number">1</span>);<br>                userService.save(user);<br>            &#125;<br>            <span class="hljs-comment">//登录成功，将用户的id加入到session中</span><br>            httpSession.setAttribute(<span class="hljs-string">&quot;user&quot;</span>,user.getId());<br>            <span class="hljs-keyword">return</span> R.success(user);<br>        &#125;<br>        <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;登陆失败&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="导入用户地址薄相关功能代码"><a href="#导入用户地址薄相关功能代码" class="headerlink" title="导入用户地址薄相关功能代码"></a>导入用户地址薄相关功能代码</h1><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817141604384.png" alt="image-20220817141604384"></p><p><code>AddressBookController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zlw.reggie.controller;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;<br><span class="hljs-keyword">import</span> com.zlw.reggie.common.BaseContext;<br><span class="hljs-keyword">import</span> com.zlw.reggie.common.R;<br><span class="hljs-keyword">import</span> com.zlw.reggie.entity.AddressBook;<br><span class="hljs-keyword">import</span> com.zlw.reggie.service.AddressBookService;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.util.CollectionUtils;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 地址簿管理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/addressBook&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddressBookController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AddressBookService addressBookService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> R&lt;AddressBook&gt; <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> AddressBook addressBook)</span> &#123;<br>        addressBook.setUserId(BaseContext.getId());<br>        log.info(<span class="hljs-string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);<br>        addressBookService.save(addressBook);<br>        <span class="hljs-keyword">return</span> R.success(addressBook);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置默认地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping(&quot;default&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;AddressBook&gt; <span class="hljs-title function_">setDefault</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> AddressBook addressBook)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);<br>        LambdaUpdateWrapper&lt;AddressBook&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaUpdateWrapper</span>&lt;&gt;();<br>        wrapper.eq(AddressBook::getUserId, BaseContext.getId());<br>        <span class="hljs-comment">//因为一个用户只能有一个默认地址，下面这个操作是将该用户下的所有地址全部设置为：不是默认地址</span><br>        wrapper.set(AddressBook::getIsDefault, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//SQL:update address_book set is_default = 0 where user_id = ?</span><br>        addressBookService.update(wrapper);<br><br>        <span class="hljs-comment">//再将该地址设置为默认地址</span><br>        addressBook.setIsDefault(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//SQL:update address_book set is_default = 1 where id = ?</span><br>        addressBookService.updateById(addressBook);<br>        <span class="hljs-keyword">return</span> R.success(addressBook);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>        <span class="hljs-type">AddressBook</span> <span class="hljs-variable">addressBook</span> <span class="hljs-operator">=</span> addressBookService.getById(id);<br>        <span class="hljs-keyword">if</span> (addressBook != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> R.success(addressBook);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;没有找到该对象&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询默认地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;default&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;AddressBook&gt; <span class="hljs-title function_">getDefault</span><span class="hljs-params">()</span> &#123;<br>        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        queryWrapper.eq(AddressBook::getUserId, BaseContext.getId());<br>        queryWrapper.eq(AddressBook::getIsDefault, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//SQL:select * from address_book where user_id = ? and is_default = 1</span><br>        <span class="hljs-type">AddressBook</span> <span class="hljs-variable">addressBook</span> <span class="hljs-operator">=</span> addressBookService.getOne(queryWrapper);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == addressBook) &#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;没有找到该对象&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> R.success(addressBook);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询指定用户的全部地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;List&lt;AddressBook&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(AddressBook addressBook)</span> &#123;<br>        addressBook.setUserId(BaseContext.getId());<br>        log.info(<span class="hljs-string">&quot;addressBook:&#123;&#125;&quot;</span>, addressBook);<br><br>        <span class="hljs-comment">//条件构造器</span><br>        LambdaQueryWrapper&lt;AddressBook&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        queryWrapper.eq(<span class="hljs-literal">null</span> != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId());<br>        queryWrapper.orderByDesc(AddressBook::getUpdateTime);<br><br>        <span class="hljs-comment">//SQL:select * from address_book where user_id = ? order by update_time desc</span><br>        <span class="hljs-keyword">return</span> R.success(addressBookService.list(queryWrapper));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817150645464.png" alt="image-20220817150645464"></p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817150700003.png" alt="image-20220817150700003"></p><h1 id="菜品展示"><a href="#菜品展示" class="headerlink" title="菜品展示"></a>菜品展示</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817150942789.png" alt="image-20220817150942789"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="手动修改展示菜品所发送的请求"><a href="#手动修改展示菜品所发送的请求" class="headerlink" title="手动修改展示菜品所发送的请求"></a>手动修改展示菜品所发送的请求</h3><p>访问主页时，显示404，不展示菜品，但我们显示菜品的功能已经实现完成，为什么还不能展示呢，</p><p>因为前端发送了两次请求分别是categoryListApi和cartListApi</p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817161708673.png" alt="image-20220817161708673"></p><p>其中categoryListApi的访问地址如下，功能已经实现完成，</p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817161737768.png" alt="image-20220817161737768"></p><p>但另一个cartListApi（访问购物车内的商品）的访问地址如下。其中<code>/shoppingCart/list</code>还没有实现</p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817161906429.png" alt="image-20220817161906429"></p><p>因此手动写一个静态的<code>json</code>，先进行展示，先实现页面的展示功能，之后再实现购物车的功能。</p><p><code>cartData.json</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;data&quot;</span>:[],<span class="hljs-string">&quot;map&quot;</span>:&#123;&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="套餐中菜品的显示"><a href="#套餐中菜品的显示" class="headerlink" title="套餐中菜品的显示"></a>套餐中菜品的显示</h3><p>改变后，则可以展示出菜品（但套餐中的套餐菜品不能展示，通过查看url的访问地址，发现没有实现功能）：</p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817162216889.png" alt="image-20220817162216889"></p><p>根据url，进行功能实现：</p><p><code>SetmealController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移动端展示套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmeal</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;List&lt;Setmeal&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Setmeal setmeal)</span>&#123;<br>        LambdaQueryWrapper&lt;Setmeal&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(setmeal.getCategoryId()!=<span class="hljs-literal">null</span>,Setmeal::getCategoryId,setmeal.getCategoryId());<br>        lambdaQueryWrapper.orderByDesc(Setmeal::getUpdateTime);<br>        lambdaQueryWrapper.eq(Setmeal::getStatus,<span class="hljs-number">1</span>);<br>        List&lt;Setmeal&gt; list = setmealService.list(lambdaQueryWrapper);<br><br>        <span class="hljs-keyword">return</span> R.success(list);<br>    &#125;<br></code></pre></td></tr></table></figure><p>以上所有的菜品已经展示成功，</p><h3 id="显示口味"><a href="#显示口味" class="headerlink" title="显示口味"></a>显示口味</h3><p>但每个菜品都有口味的选择，所以如果选择某个菜品时，要进行口味的选择，应该显示选择规格进行选择，如下。</p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817162417361.png" alt="image-20220817162417361"></p><p>如果没有口味则显示+号</p><p><img src="/2022/08/18/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%A7%BB%E5%8A%A8%E7%AB%AF/image-20220817162452821.png" alt="image-20220817162452821"></p><p>因此实现上述的功能，展示口味：</p><p><code>DishController.java</code>修改其中list方法的代码，将口味加入进去，运用DishDto</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;List&lt;DishDto&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Dish dish)</span>&#123;<br><br>        LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-comment">//根据分类id查询dish表中都有哪些菜品</span><br>        lambdaQueryWrapper.eq(dish.getCategoryId()!=<span class="hljs-literal">null</span>,Dish::getCategoryId,dish.getCategoryId());<br>        lambdaQueryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);<br><br>        <span class="hljs-comment">//添加状态，查询状态为1的,1表示起售</span><br>        lambdaQueryWrapper.eq(Dish::getStatus,<span class="hljs-number">1</span>);<br>        List&lt;Dish&gt; list = dishService.list(lambdaQueryWrapper);<br><br>        <span class="hljs-comment">//将口味加入进去</span><br>        List&lt;DishDto&gt; dishDtoList = list.stream().map(((item)-&gt;&#123;<br>            <span class="hljs-type">DishDto</span> <span class="hljs-variable">dishDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DishDto</span>();<br>            BeanUtils.copyProperties(item,dishDto);<br>            <span class="hljs-comment">//获取菜品的ID</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> item.getId();<br>            LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>            lambdaQueryWrapper1.eq(DishFlavor::getDishId,id);<br>            List&lt;DishFlavor&gt; list1 = dishFlavorService.list(lambdaQueryWrapper1);<br>            dishDto.setFlavors(list1);<br>            <span class="hljs-keyword">return</span> dishDto;<br>        &#125;)).collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> R.success(dishDtoList);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖-移动端购物车功能</title>
    <link href="/2022/08/17/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day05/"/>
    <url>/2022/08/17/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day05/</url>
    
    <content type="html"><![CDATA[<h1 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><img src="/2022/08/17/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day05/image-20220817163444795.png" alt="image-20220817163444795"></p><h2 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a>交互过程</h2><p><img src="/2022/08/17/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day05/image-20220817165222123.png" alt="image-20220817165222123"></p><h2 id="代码开发-准备工作"><a href="#代码开发-准备工作" class="headerlink" title="代码开发-准备工作"></a>代码开发-准备工作</h2><p><img src="/2022/08/17/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day05/image-20220817165249842.png" alt="image-20220817165249842"></p><h2 id="添加购物车"><a href="#添加购物车" class="headerlink" title="添加购物车"></a>添加购物车</h2><p><strong>流程：</strong></p><ul><li>根据前端发送过来的json数据可以发现，用户id并没有传送过来，所以<strong>先获取用户的id，并设置userid</strong></li><li>查询添加购物车的数据是菜品还是套餐</li><li>判断购物车中是否已经存在目前要加入的菜品或菜单<ul><li>如果已经存在，则在购物车中，在原来商品的基础上，数量+1</li><li>如果不存在，则保存到购物车数据库中。</li></ul></li></ul><p><strong>请求方式：</strong></p><p><img src="/2022/08/17/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day05/image-20220818095409805.png" alt="image-20220818095409805"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加购物车</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shoppingCart</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/add&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;ShoppingCart&gt; <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ShoppingCart shoppingCart)</span>&#123;<br><br>        <span class="hljs-comment">//设置用户id，指定当前哪个用户的购物车数据</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getId();<br>        shoppingCart.setUserId(userId);<br><br>        <span class="hljs-comment">//查询当前要添加的是菜品还是套餐</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">dishId</span> <span class="hljs-operator">=</span> shoppingCart.getDishId();<br>        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(ShoppingCart::getUserId,userId);<br>        <span class="hljs-keyword">if</span> (dishId!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//添加到购物车的是菜品</span><br>            lambdaQueryWrapper.eq(ShoppingCart::getDishId,shoppingCart.getDishId());<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//添加到购物车的套餐</span><br>            lambdaQueryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());<br>        &#125;<br><br>        <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">shoppingCartServiceOne</span> <span class="hljs-operator">=</span> shoppingCartService.getOne(lambdaQueryWrapper);<br>        <span class="hljs-comment">//判断购物车中是否有菜品或套餐</span><br>        <span class="hljs-keyword">if</span> (shoppingCartServiceOne!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//如果有，则数量+1</span><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> shoppingCartServiceOne.getNumber();<br>            shoppingCartServiceOne.setNumber(number+<span class="hljs-number">1</span>);<br>            shoppingCartService.updateById(shoppingCartServiceOne);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果没有，则添加购物车</span><br>            shoppingCart.setNumber(<span class="hljs-number">1</span>);<br>            shoppingCartService.save(shoppingCart);<br>            <span class="hljs-comment">//因为数据库中该菜品或套餐，所以shoppingCartServiceOne为null，为了方便返回，可以将shoppingCart赋值给shoppingCartServiceOne</span><br>            shoppingCartServiceOne = shoppingCart;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> R.success(shoppingCartServiceOne);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="查看购物车"><a href="#查看购物车" class="headerlink" title="查看购物车"></a>查看购物车</h2><p>添加购物车功能已经实现完成，所以将之前手写的哪个<code>cartData.json</code>改回原来的访问地址，进行功能的实现</p><p><img src="/2022/08/17/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day05/image-20220818091346849.png" alt="image-20220818091346849"></p><p><strong>ShoppingCartController.java代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;List&lt;ShoppingCart&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//获取用户ID</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getId();<br>        <span class="hljs-comment">//根据用户ID查询购物车数据</span><br>        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(ShoppingCart::getUserId,userId);<br>        List&lt;ShoppingCart&gt; list = shoppingCartService.list(lambdaQueryWrapper);<br>        <span class="hljs-keyword">return</span> R.success(list);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="减少购物车中商品的数量"><a href="#减少购物车中商品的数量" class="headerlink" title="减少购物车中商品的数量"></a>减少购物车中商品的数量</h2><p><strong>减少购物车中商品的数量所发出的请求为：</strong></p><p><img src="/2022/08/17/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day05/image-20220818094805125.png" alt="image-20220818094805125"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 减少购物车数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/sub&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> ShoppingCart shoppingCart)</span>&#123;<br>        <span class="hljs-comment">//获取用户id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getId();<br>        <span class="hljs-comment">//判断减少的是菜品还是套餐</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">dishId</span> <span class="hljs-operator">=</span> shoppingCart.getDishId();<br>        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(ShoppingCart::getUserId,userId);<br>        <span class="hljs-keyword">if</span> (dishId!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//如果是菜品</span><br>            lambdaQueryWrapper.eq(ShoppingCart::getDishId,dishId);<br><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果是套餐</span><br>            lambdaQueryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());<br>        &#125;<br>        <span class="hljs-type">ShoppingCart</span> <span class="hljs-variable">shoppingCartServiceOne</span> <span class="hljs-operator">=</span> shoppingCartService.getOne(lambdaQueryWrapper);<br><br>        <span class="hljs-comment">//判断菜品或套餐的数量</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> shoppingCartServiceOne.getNumber();<br>        <span class="hljs-keyword">if</span> (number&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//如果大于1，则数量-1</span><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">number1</span> <span class="hljs-operator">=</span> shoppingCartServiceOne.getNumber();<br>            shoppingCartServiceOne.setNumber(number1-<span class="hljs-number">1</span>);<br>            shoppingCartService.updateById(shoppingCartServiceOne);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果是1，则从购物车中删除，</span><br>            shoppingCartService.removeById(shoppingCartServiceOne);<br>        &#125;<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;删除成功&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="清空购物车"><a href="#清空购物车" class="headerlink" title="清空购物车"></a>清空购物车</h2><p><strong>清空购物车发出的请求为：</strong></p><p><img src="/2022/08/17/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day05/image-20220818092525048.png" alt="image-20220818092525048"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping(&quot;/clean&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">clean</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> BaseContext.getId();<br>        LambdaQueryWrapper&lt;ShoppingCart&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(ShoppingCart::getUserId,userId);<br>        <span class="hljs-comment">//delete from shoppingcart where userid = ?;</span><br>        shoppingCartService.remove(lambdaQueryWrapper);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;购物车已清空&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除链表的倒数第N个结点</title>
    <link href="/2022/08/16/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2022/08/16/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode-19（删除链表的倒数第N个结点）"><a href="#leetCode-19（删除链表的倒数第N个结点）" class="headerlink" title="leetCode-19（删除链表的倒数第N个结点）"></a>leetCode-19（删除链表的倒数第N个结点）</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="/2022/08/16/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/remove_ex1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><h2 id="解法一，自己瞎写"><a href="#解法一，自己瞎写" class="headerlink" title="解法一，自己瞎写"></a>解法一，自己瞎写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//计算链表中所有节点的数量</span><br>        <span class="hljs-keyword">while</span> (node!=<span class="hljs-literal">null</span>)&#123;<br>            node = node.next;<br>            count++;<br>        &#125;<br>        <span class="hljs-comment">//特殊情况的判断</span><br>        <span class="hljs-keyword">if</span> (count==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">if</span> (count==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        node = head;<br>        <span class="hljs-comment">//如果删除的节点是倒数第count个节点，则直接删除第一个即可</span><br>        <span class="hljs-keyword">if</span> (count-n==<span class="hljs-number">0</span>) &#123;<br>            head = head.next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//定位到倒数第几个节点的前一个节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;count-n;i++)&#123;<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-comment">//删除节点操作</span><br>        node.next = node.next.next;<br>        node = head;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：栈"><a href="#解法二：栈" class="headerlink" title="解法二：栈"></a>解法二：栈</h2><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<span class="hljs-comment">//定义辅助节点，防止删除头结点</span><br>        Stack&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">while</span> (node!=<span class="hljs-literal">null</span>)&#123;<br>            stack.push(node);<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            stack.pop();<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> stack.peek();<br>        pre.next = pre.next.next;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不用辅助节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        Stack&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (node!=<span class="hljs-literal">null</span>)&#123;<br>            stack.push(node);<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            stack.pop();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (stack.size()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> head.next;<span class="hljs-comment">//判断一下是否删除的是头结点</span><br>        node = stack.pop();<br>        node.next = node.next.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h2><ul><li>定义两个指针，一个first，一个second。</li><li>first指针先走n步</li><li>再将first和second两个指针，同时后移，直到first为null。</li><li>则second指向的是倒是n+1个节点。</li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            first = first.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (first!=<span class="hljs-literal">null</span>)&#123;<br>            first = first.next;<br>            second = second.next;<br>        &#125;<br>        second.next = second.next.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> dummy.next;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>不用辅助节点时：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            first = first.next;<span class="hljs-comment">//使得first与second之间间隔n-1个节点</span><br>        &#125;<br>        <span class="hljs-comment">//判断是否删除的是头结点</span><br>        <span class="hljs-keyword">if</span> (first==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head.next;<br>        <span class="hljs-keyword">while</span> (first.next!=<span class="hljs-literal">null</span>)&#123;<span class="hljs-comment">//将index2移至最后一个节点</span><br>            first = first.next;<br>            second = second.next;<br>        &#125;<br>        second.next = second.next.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖-套餐管理、短信、验证码</title>
    <link href="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/"/>
    <url>/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/</url>
    
    <content type="html"><![CDATA[<h1 id="套餐管理"><a href="#套餐管理" class="headerlink" title="套餐管理"></a>套餐管理</h1><h2 id="新增套餐"><a href="#新增套餐" class="headerlink" title="新增套餐"></a>新增套餐</h2><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20220816094904638.png" alt="image-20220816094904638"></p><p><strong>代码准备：</strong></p><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20220816100013442.png" alt="image-20220816100013442"></p><p><strong>代码的交互过程：</strong></p><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20220816100551172.png" alt="image-20220816100551172"></p><p><strong>步骤一，已经在新增菜品中实现完成。</strong></p><p><strong>步骤二：</strong></p><p>添加菜品时，所发送的请求：</p><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20220816105907365.png" alt="image-20220816105907365"></p><p><code>DishController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加套餐时，显示套餐中所对应的菜品</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;List&lt;Dish&gt;&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Dish dish)</span>&#123;<br><br>        LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        <span class="hljs-comment">//根据分类id查询dish表中都有哪些菜品</span><br>        lambdaQueryWrapper.eq(dish.getCategoryId()!=<span class="hljs-literal">null</span>,Dish::getCategoryId,dish.getCategoryId());<br>        lambdaQueryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);<br><br>        <span class="hljs-comment">//添加状态，查询状态为1的,1表示起售</span><br>        lambdaQueryWrapper.eq(Dish::getStatus,<span class="hljs-number">1</span>);<br>        List&lt;Dish&gt; list = dishService.list(lambdaQueryWrapper);<br><br>        <span class="hljs-keyword">return</span> R.success(list);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>显示成功：</strong></p><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20220816105947613.png" alt="image-20220816105947613"></p><p><strong>步骤四和五，已经实现完成，</strong></p><p><strong>步骤六：</strong></p><p>点击保存时发送的请求为：</p><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20220816110048198.png" alt="image-20220816110048198"></p><p>在这个保存套餐的过程中，不是普通的保存，所以不能用自带的方法，因为要同时保存两个表：setmeal和setmeal_dish两个表，因此在SermealService中重写一个保存的方法为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetmealServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;SetmealMapper, Setmeal&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SetmealService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealDishService setmealDishService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveWithDish</span><span class="hljs-params">(SetmealDto setmealDto)</span> &#123;<br>        <span class="hljs-comment">//保存到套餐列表</span><br>        <span class="hljs-built_in">this</span>.save(setmealDto);<br>        <span class="hljs-comment">//保存套餐和菜品对应关系的列表:setmeal_dish</span><br>        <span class="hljs-comment">//获取套餐中的菜品</span><br>        List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();<br>        <span class="hljs-comment">//设置套餐中菜品的套餐id</span><br>        setmealDishes.stream().map((item)-&gt;&#123;<br>            item.setSetmealId(setmealDto.getId());<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;).collect(Collectors.toList());<br>        <span class="hljs-comment">//保存到setmeal-dish表中</span><br>        setmealDishService.saveBatch(setmealDishes);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SetmealController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 套餐管理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/setmeal&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetmealController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealService setmealService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealDishService setmealDishService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增套餐</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> SetmealDto setmealDto)</span>&#123;<br>        setmealService.saveWithDish(setmealDto);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;成功添加套餐&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="套餐信息分页查询"><a href="#套餐信息分页查询" class="headerlink" title="套餐信息分页查询"></a>套餐信息分页查询</h2><p><strong>与菜品管理中的分页查询一致</strong></p><p>代码为：</p><p><code>SetmealController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 分页</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br>   <span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page,<span class="hljs-type">int</span> pageSize,String name)</span>&#123;<br><br>       <span class="hljs-comment">//构造分页构造器</span><br>       Page&lt;Setmeal&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;();<br><br>       <span class="hljs-comment">//由于setmeal中有分类id，但是页面上要展示分类名称，所以要用setmealDto</span><br>       Page&lt;SetmealDto&gt; setmealDtoPage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;();<br><br>       <span class="hljs-comment">//条件查询，根据名字查询套餐</span><br>       LambdaQueryWrapper&lt;Setmeal&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>       lambdaQueryWrapper.eq(name!=<span class="hljs-literal">null</span>,Setmeal::getName,name);<br>       lambdaQueryWrapper.orderByDesc(Setmeal::getCreateTime);<br><br>       <span class="hljs-comment">//执行分页查询</span><br>       setmealService.page(pageInfo,lambdaQueryWrapper);<br><br>       <span class="hljs-comment">//属性复制，忽略records属性，因为records是所有的套餐的数据链表，先不拷贝过去，因为要修改里面的套餐id为套餐名称</span><br>       BeanUtils.copyProperties(pageInfo,setmealDtoPage,<span class="hljs-string">&quot;records&quot;</span>);<br>       <span class="hljs-comment">//获取records以便修改</span><br>       List&lt;Setmeal&gt; records = pageInfo.getRecords();<br><br><br>       List&lt;SetmealDto&gt; setmealDtoList = records.stream().map((item)-&gt;&#123;<br>           <span class="hljs-comment">///新建setmealDto对象</span><br>           <span class="hljs-type">SetmealDto</span> <span class="hljs-variable">setmealDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetmealDto</span>();<br>           <span class="hljs-comment">//将每个套餐项拷贝</span><br>           BeanUtils.copyProperties(item,setmealDto);<br>           <span class="hljs-comment">//通过分类id获取分类名称</span><br>           <span class="hljs-type">Long</span> <span class="hljs-variable">categoryId</span> <span class="hljs-operator">=</span> item.getCategoryId();<br>           <span class="hljs-type">Category</span> <span class="hljs-variable">category</span> <span class="hljs-operator">=</span> categoryService.getById(categoryId);<br>           <span class="hljs-keyword">if</span> (category!=<span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-type">String</span> <span class="hljs-variable">categoryName</span> <span class="hljs-operator">=</span> category.getName();<br>               <span class="hljs-comment">//设置分类名称</span><br>               setmealDto.setCategoryName(categoryName);<br>           &#125;<br>           <span class="hljs-keyword">return</span> setmealDto;<br>       &#125;).collect(Collectors.toList());<br><br>       setmealDtoPage.setRecords(setmealDtoList);<br><br>       <span class="hljs-keyword">return</span> R.success(setmealDtoPage);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="删除套餐"><a href="#删除套餐" class="headerlink" title="删除套餐"></a>删除套餐</h2><p><strong>需求分析：</strong></p><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20220816135731833.png" alt="image-20220816135731833"></p><p>由于删除套餐前要确定商品是否是停售，因此在解决删除功能之前要先解决停售和启售的代码。</p><p><strong>停售（批量停售）和启售（批量启售）的代码：</strong></p><p><code>SetmealController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 停售和启售</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PostMapping(&quot;/status/&#123;status&#125;&quot;)</span><br>   <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">sale</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;status&quot;)</span> Integer status,<span class="hljs-meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;<br>       <span class="hljs-keyword">for</span> (Long id:ids)&#123;<br>           <span class="hljs-comment">//获取套餐</span><br>           <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> setmealService.getById(id);<br>           <span class="hljs-comment">//设置状态</span><br>           setmeal.setStatus(status);<br>           <span class="hljs-comment">//将新状态更新数据库</span><br>           setmealService.updateById(setmeal);<br>       &#125;<br>       <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;修改成功&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>删除和批量删除的代码：</strong></p><p><code>SetmealServiceimpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除套餐和套餐菜品关联的表</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteWithDish</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> &#123;<br>    <span class="hljs-comment">//select count(*) from setmeal where id in (1,23) and status = 1;</span><br>    <span class="hljs-comment">//判断该套餐是否可以删除，也就是是否停售</span><br>    LambdaQueryWrapper&lt;Setmeal&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    lambdaQueryWrapper.in(Setmeal::getId,ids);<br>    lambdaQueryWrapper.eq(Setmeal::getStatus,<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.count(lambdaQueryWrapper);<br>    <span class="hljs-keyword">if</span> (count&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//如果不是停售，则不能删除,抛出业务异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomException</span>(<span class="hljs-string">&quot;该套餐是启售状态，不能删除&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//可以删除，删除套餐</span><br>        <span class="hljs-built_in">this</span>.removeByIds(ids);<br>        <span class="hljs-comment">//删除套餐菜品关联表</span><br>        <span class="hljs-comment">//delete from setmeal_dish where setmeal_id in ?;</span><br>        LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper1.in(SetmealDish::getSetmealId,ids);<br>        setmealDishService.remove(lambdaQueryWrapper1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SetmealController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 删除套餐</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@DeleteMapping</span><br>  <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;Long&gt; ids)</span>&#123;<br>      setmealService.deleteWithDish(ids);<br>      <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;删除套餐成功&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="修改套餐"><a href="#修改套餐" class="headerlink" title="修改套餐"></a>修改套餐</h2><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>在套餐管理列表页面点击修改按钮，跳转到修改套餐页面，在修改页面回显套餐相关信息并进行修改，最后点击确定按钮完成修改操作</p><h4 id="代码开发-梳理交互过程"><a href="#代码开发-梳理交互过程" class="headerlink" title="代码开发-梳理交互过程"></a>代码开发-梳理交互过程</h4><p>在开发代码之前，需要梳理一下修改套餐时前端页面（ add.html)和服务端的交互过程:</p><p>1、页面发送ajax请求，请求服务端获取分类数据，用于套餐分类下拉框中数据展示</p><p>2、页面发送ajax请求，请求服务端，根据id查询当前套餐信息，用于套餐信息回显</p><p><strong>SetmealController处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据Id查询套餐信息</span><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> R&lt;SetmealDto&gt; <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span>&#123;<br>    SetmealDto setmealDto=setmealService.getByIdWithDish(id);<br><br>    <span class="hljs-keyword">return</span> R.success(setmealDto);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>SetmealServiceImpl添加getByIdWithDish方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SetmealDto <span class="hljs-title function_">getByIdWithDish</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">//查询套餐基本信息</span><br>    <span class="hljs-type">Setmeal</span> <span class="hljs-variable">setmeal</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getById(id);<br>    <span class="hljs-type">SetmealDto</span> <span class="hljs-variable">setmealDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetmealDto</span>();<br>    BeanUtils.copyProperties(setmeal, setmealDto);<br><br>    <span class="hljs-comment">//查询套餐菜品信息</span><br>    LambdaQueryWrapper&lt;SetmealDish&gt; queryWrapper=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    queryWrapper.eq(SetmealDish::getSetmealId,setmeal.getId());<br>    List&lt;SetmealDish&gt; list = setmealDishService.list(queryWrapper);<br><br>    setmealDto.setSetmealDishes(list);<br>    <span class="hljs-keyword">return</span> setmealDto;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>以上进行了回显：</strong></p><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20221010131822976.png" alt="image-20221010131822976"></p><p><strong>点击保存：</strong></p><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20221010131900053.png" alt="image-20221010131900053"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 套餐修改后点击保存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PutMapping</span><br><span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> SetmealDto setmealDto)</span>&#123;<br>    setmealService.updateWithDish(setmealDto);<br>    <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;修改成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改套餐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> setmealDto</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateWithDish</span><span class="hljs-params">(SetmealDto setmealDto)</span>&#123;<br>        <span class="hljs-comment">//更新setmeal表的基本信息</span><br>        <span class="hljs-built_in">this</span>.updateById(setmealDto);<br><br>        <span class="hljs-comment">//更新套餐和菜品关联表</span><br>        <span class="hljs-comment">//先清楚套餐关联的菜品</span><br>        LambdaQueryWrapper&lt;SetmealDish&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(SetmealDish::getSetmealId,setmealDto.getId());<br>        setmealDishService.remove(lambdaQueryWrapper);<br><br>        List&lt;SetmealDish&gt; setmealDishes = setmealDto.getSetmealDishes();<br><br>        <span class="hljs-comment">//再重新加入修改后的菜品</span><br>        setmealDishes.stream().map((item)-&gt;&#123;<br>            item.setSetmealId(setmealDto.getId());<br>            <span class="hljs-keyword">return</span> item;<br>        &#125;).collect(Collectors.toList());<br><br>        <span class="hljs-comment">//保存到关联表中</span><br>        setmealDishService.saveBatch(setmealDishes);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="订单明细"><a href="#订单明细" class="headerlink" title="订单明细"></a>订单明细</h1><h2 id="发送的请求"><a href="#发送的请求" class="headerlink" title="发送的请求"></a>发送的请求</h2><p><img src="/2022/08/16/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day04/image-20220818221900343.png" alt="image-20220818221900343"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后台展示订单明细</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> orderId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beginTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> endTime</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page, <span class="hljs-type">int</span> pageSize, String orderId, String beginTime, String endTime )</span>&#123;<br><br>        <span class="hljs-comment">//构造分页构造器</span><br>        Page&lt;Orders&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(page, pageSize);<br>        <span class="hljs-comment">//由于要显示用户所以使用OrderDto显示用户名字</span><br>        Page&lt;OrderDto&gt; dtoPage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;();<br>        <span class="hljs-comment">//查询订单</span><br>        LambdaQueryWrapper&lt;Orders&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        lambdaQueryWrapper.eq(orderId!=<span class="hljs-literal">null</span>,Orders::getNumber,orderId);<br>        <span class="hljs-keyword">if</span>(beginTime!=<span class="hljs-literal">null</span>&amp;&amp;endTime!=<span class="hljs-literal">null</span>)&#123;<br>            lambdaQueryWrapper.ge(Orders::getOrderTime,beginTime);<br>            lambdaQueryWrapper.le(Orders::getOrderTime,endTime);<br>        &#125;<br>        lambdaQueryWrapper.orderByDesc(Orders::getOrderTime);<br>        <span class="hljs-comment">//执行查询</span><br>        orderService.page(pageInfo,lambdaQueryWrapper);<br>        <span class="hljs-comment">//复制</span><br>        BeanUtils.copyProperties(pageInfo,dtoPage,<span class="hljs-string">&quot;records&quot;</span>);<br>        List&lt;Orders&gt; orders = pageInfo.getRecords();<br>        List&lt;OrderDto&gt; dtoList = orders.stream().map((item)-&gt;&#123;<br>            <span class="hljs-type">OrderDto</span> <span class="hljs-variable">orderDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDto</span>();<br>            BeanUtils.copyProperties(item,orderDto);<br>            String name=<span class="hljs-string">&quot;用户&quot;</span>+item.getUserId();<br>            orderDto.setUserName(name);<br><br>            <span class="hljs-keyword">return</span> orderDto;<br>        &#125;).collect(Collectors.toList());<br>        dtoPage.setRecords(dtoList);<br>        <span class="hljs-keyword">return</span> R.success(dtoPage);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="/2022/08/12/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>/2022/08/12/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode-17（电话号码的字母组合问题）"><a href="#leetCode-17（电话号码的字母组合问题）" class="headerlink" title="leetCode-17（电话号码的字母组合问题）"></a>leetCode-17（电话号码的字母组合问题）</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="/2022/08/12/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/200px-telephone-keypad2svg.png" alt="img"></p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：digits = <span class="hljs-string">&quot;23&quot;</span><br>输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：digits = <span class="hljs-string">&quot;&quot;</span><br>输出：[]<br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：digits = <span class="hljs-string">&quot;2&quot;</span><br>输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-keyword">if</span> (digits.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> list;<br>        Map&lt;Character,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        map.put(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&quot; &quot;</span>);<br>        map.put(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>);<br>        map.put(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>);<br>        map.put(<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>);<br>        map.put(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>);<br>        map.put(<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>);<br>        map.put(<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>);<br>        map.put(<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>);<br>        map.put(<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>);<br>        select(digits,map,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(),<span class="hljs-number">0</span>,list);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">(String digits,Map&lt;Character,String&gt; map,StringBuffer stringBuffer,<span class="hljs-type">int</span> index,List&lt;String&gt; list)</span>&#123;<br>        <span class="hljs-keyword">if</span> (index==digits.length())&#123;<br>            list.add(stringBuffer.toString());<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> digits.charAt(index);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> map.get(c);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>                stringBuffer.append(s.charAt(i));<br>                select(digits,map,stringBuffer,index+<span class="hljs-number">1</span>,list);<br>                stringBuffer.deleteCharAt(index);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>会回来的~~</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三数之和</title>
    <link href="/2022/08/11/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/08/11/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode-15（三数之和）"><a href="#leetCode-15（三数之和）" class="headerlink" title="leetCode-15（三数之和）"></a>leetCode-15（三数之和）</h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">4</span>]<br>输出：[[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = []<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：nums = [<span class="hljs-number">0</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><h2 id="解法一：排序-双指针-去重"><a href="#解法一：排序-双指针-去重" class="headerlink" title="解法一：排序+双指针+去重"></a>解法一：排序+双指针+去重</h2><ul><li><p>先对数组进行排序</p></li><li><p>遍历排序的数组，固定第一个值，设置左右指针，</p></li><li><p><img src="/2022/08/11/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/image-20220811105320802.png" alt="image-20220811105320802"></p></li><li><p>去重</p></li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (nums==<span class="hljs-literal">null</span> || nums.length&lt;<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">//排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">//固定一个值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//固定的值，如果大于0，则直接continue</span><br>            <span class="hljs-keyword">if</span> (nums[i]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span> (sum==<span class="hljs-number">0</span>)&#123;<br>                    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    list.add(nums[i]);<br>                    list.add(nums[l]);<br>                    list.add(nums[r]);<br>                    <span class="hljs-comment">//去重</span><br>                    <span class="hljs-keyword">if</span> (!res.contains(list)) res.add(list);<br>                    l++;<br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&lt;<span class="hljs-number">0</span>)&#123;<br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&gt;<span class="hljs-number">0</span>)&#123;<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：优化"><a href="#解法二：优化" class="headerlink" title="解法二：优化"></a>解法二：优化</h2><p>在循环的时候，就判断是否重复</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (nums==<span class="hljs-literal">null</span> || nums.length&lt;<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">//排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">//固定一个值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//固定的值，如果大于0，则直接continue</span><br>            <span class="hljs-keyword">if</span> (nums[i]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//如果和前一个固定的值相等，则直接continue</span><br>            <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; <span class="hljs-comment">//左指针</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;  <span class="hljs-comment">//右指针</span><br>            <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span> (sum==<span class="hljs-number">0</span>)&#123;<br>                    res.add(Arrays.asList(nums[i],nums[l],nums[r]));   <span class="hljs-comment">//将数组转化为list集合</span><br>                    <span class="hljs-keyword">while</span> (l+<span class="hljs-number">1</span>&lt;n &amp;&amp; nums[l]==nums[l+<span class="hljs-number">1</span>]) l++;  <span class="hljs-comment">//如果和上一个指针的数相等，则跳过</span><br>                    <span class="hljs-keyword">while</span> (r-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[r]==nums[r-<span class="hljs-number">1</span>]) r--;   <span class="hljs-comment">//如果和上一个指针的数相等，则跳过</span><br>                    l++;<br>                    r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&lt;<span class="hljs-number">0</span>)&#123;<br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum&gt;<span class="hljs-number">0</span>)&#123;<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><h2 id="解法二：暴力"><a href="#解法二：暴力" class="headerlink" title="解法二：暴力"></a>解法二：暴力</h2><p>两个for循环</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span>  <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span> (nums[i]+nums[j]==target)&#123;<br>                    res[<span class="hljs-number">0</span>] = i;<br>                    res[<span class="hljs-number">1</span>] = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：map"><a href="#解法二：map" class="headerlink" title="解法二：map"></a>解法二：map</h2><p>遍历数组，将数存储到map中，遍历中判断map是否有（target-该数），如果有则找到。直接返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer,Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(target-nums[i]))&#123;<br>                res[<span class="hljs-number">0</span>] = map.get(target-nums[i]);<br>                res[<span class="hljs-number">1</span>] = i;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                map.put(nums[i],i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-comment">//这里要定义两个数组，因为如果进行排序后，原数据所对应的下标改变了，所以要定义二维数组存储坐标位置</span><br>        <span class="hljs-type">int</span> a[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][<span class="hljs-number">2</span>];  <br>        <span class="hljs-comment">//将数据和坐标放入二维坐标中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            a[i][<span class="hljs-number">0</span>] = nums[i];<br>            a[i][<span class="hljs-number">1</span>] = i;<br>        &#125;<br>        <span class="hljs-comment">//根据数据值进行排序</span><br>        Arrays.sort(a, (a1,b1) -&gt; a1[<span class="hljs-number">0</span>]-b1[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span> (a[l][<span class="hljs-number">0</span>]+a[r][<span class="hljs-number">0</span>]!=target)&#123;<br>            <span class="hljs-keyword">if</span> (a[l][<span class="hljs-number">0</span>]+a[r][<span class="hljs-number">0</span>]&lt;target) l++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[l][<span class="hljs-number">0</span>]+a[r][<span class="hljs-number">0</span>]&gt;target) r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;a[l][<span class="hljs-number">1</span>], a[r][<span class="hljs-number">1</span>]&#125;;  <span class="hljs-comment">//返回原数据的位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>盛最多水的容器</title>
    <link href="/2022/08/11/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/08/11/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode-11（盛最多水的容器）"><a href="#leetCode-11（盛最多水的容器）" class="headerlink" title="leetCode-11（盛最多水的容器）"></a>leetCode-11（盛最多水的容器）</h1><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="/2022/08/11/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/question_11.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h1><p>首先定义两个指针，分别指向第一个和最后一个。盛水的计算公式为：<code>Math.min(height[l],height[r])*(r-l);</code></p><p>每次移动<code>height[l]和height[r]</code>中较小的一个，因为，如果移动较大的，则一定比之前那个数小，因为距离<code>（r-l）</code>变小了，<code>Math.min(height[l],height[r])</code>中的最小值不变。</p><p>移动之后，说明那个较小的值就在这个数组中删除，不会再用到。此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。可以继续像之前 <strong>考虑第一步</strong> 那样考虑</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> height.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.min(height[l],height[r])*(r-l);<br>            max = Math.max(max,res);<br>            <span class="hljs-keyword">if</span> (height[l]&lt;height[r]) ++l;<br>            <span class="hljs-keyword">else</span> --r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>中等题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖-菜品管理</title>
    <link href="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/"/>
    <url>/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/</url>
    
    <content type="html"><![CDATA[<h1 id="菜品管理"><a href="#菜品管理" class="headerlink" title="菜品管理"></a>菜品管理</h1><h2 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h2><h3 id="文件上传的介绍："><a href="#文件上传的介绍：" class="headerlink" title="文件上传的介绍："></a><strong>文件上传的介绍：</strong></h3><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220722162919393.png" alt="image-20220722162919393"></p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220722163109156.png" alt="image-20220722163109156"></p><p><strong>文件上传的代码实现：</strong></p><p>首先将文件上传的upload.html页面复制到page目录下的demo目录中。</p><p>访问upload.html，上传文件时请求路径为：</p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220722164859836.png" alt="image-20220722164859836"></p><p>因此新建一个CommonController进行文件上传和下载。</p><p><strong>CommonController中文件上传的代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件上传和下载</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/common&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;reggie.path&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String basePath;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件上传</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file)</span>&#123;<br>        <span class="hljs-comment">//file是个临时文件，需要转存，否则本次请求完之后的临时文件将删除</span><br>        log.info(file.toString());<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+suffix;<br>        <span class="hljs-comment">//新键目录</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(basePath);<br>        <span class="hljs-keyword">if</span> (!dir.exists())&#123;  <span class="hljs-comment">//如果目录不存在，则创建目录</span><br>            dir.mkdirs();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//将文件转移到指定的目录中</span><br>            file.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(basePath+fileName));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> R.success(fileName);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中application.yml文件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">reggie:<br>  path: D:\img\      #设置图片下载下来后存储的位置<br></code></pre></td></tr></table></figure><h3 id="文件下载的介绍："><a href="#文件下载的介绍：" class="headerlink" title="文件下载的介绍："></a><strong>文件下载的介绍：</strong></h3><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220722163226124.png" alt="image-20220722163226124"></p><p>根据浏览器发出的响应，所以应该为：<code>@GetMapping(&quot;/download&quot;)</code>：</p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220809091310266.png" alt="image-20220809091310266"></p><p><strong>文件下载的代码：（下面这个代码将本机电脑作为服务器进行传输）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件下载</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/download&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">download</span><span class="hljs-params">(String name, HttpServletResponse response)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//输入流,通过输入流读取文件</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(basePath+name));<br>        <span class="hljs-comment">//获取响应体的输出流，通过输出流将文件写回浏览器，在浏览器展示图片</span><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        <span class="hljs-comment">//设置响应给客户端的文件格式，格式为图片</span><br>        response.setContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//将读到的内容放入到bytes中去</span><br>        <span class="hljs-keyword">while</span> ((len = fileInputStream.read(bytes))!=-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//通过输出流向浏览器写</span><br>            outputStream.write(bytes,<span class="hljs-number">0</span>,len);<br>            outputStream.flush();<br>        &#125;<br>        fileInputStream.close();<br>        outputStream.close();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h2><p><strong>分析</strong></p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220809215512022.png" alt="image-20220809215512022"></p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220809220732856.png" alt="image-20220809220732856"></p><p><strong>第一步：根据条件动态查询分类数据：</strong></p><p>点击菜品分类时，所发出的请求为：</p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220809220843612.png" alt="image-20220809220843612"></p><p>因此<code>CategoryController.java</code>的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据类型查询的食品种类数据</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@RequestMapping(&quot;/list&quot;)</span><br>   <span class="hljs-keyword">public</span>  R&lt;List&lt;Category&gt;&gt; <span class="hljs-title function_">getCategory</span><span class="hljs-params">(Category category)</span>&#123;<br>       <span class="hljs-comment">//构造条件构造器</span><br>       LambdaQueryWrapper&lt;Category&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>       <span class="hljs-comment">//查询条件，从数据库中找到相同类型的菜品</span><br>       lambdaQueryWrapper.eq(category.getType()!=<span class="hljs-literal">null</span>,Category::getType,category.getType());<br>       <span class="hljs-comment">//排序顺序</span><br>       lambdaQueryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime);<br>       List&lt;Category&gt; list = categoryService.list(lambdaQueryWrapper);<br>       <span class="hljs-keyword">return</span> R.success(list);<br>   &#125;<br></code></pre></td></tr></table></figure><p>补充知识：</p><blockquote><p>DTO:（Data Transfer Object 数据传输对象）当实体中的属性不能够进行作为参数传输时，<strong>也就是浏览器发送过来的数据中的参数，实体类中不包含时进行使用。</strong></p></blockquote><p><strong>新增菜品的代码为：</strong></p><p>因为新增菜品时，操作的是两个表，一个是菜品表，一个是口味表，所以不能用普通的save方法，因此自己写一个保存口味和菜品的方法：</p><p><code>DishServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 新增菜品，同时保存对应的口味</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> dishDto</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-meta">@Transactional</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveWithFlavor</span><span class="hljs-params">(DishDto dishDto)</span> &#123;<br><br>     <span class="hljs-comment">//保存到菜单中</span><br>     <span class="hljs-built_in">this</span>.save(dishDto);<br>     <span class="hljs-comment">//获取菜品的id，因为保存到口味表中时会用到</span><br>     <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> dishDto.getId();<br>     <br>     <span class="hljs-comment">//获取所有的口味列表</span><br>     List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();<br>     <br>     <span class="hljs-comment">//将所有的口味添加菜品id，并转化为list</span><br>     flavors = flavors.stream().map((item)-&gt;&#123;<br>        item.setDishId(id);<br>        <span class="hljs-keyword">return</span> item;<br>     &#125;).collect(Collectors.toList());<br>      <span class="hljs-comment">//保存到口味中</span><br>     dishFlavorService.saveBatch(flavors);<br><br> &#125;<br></code></pre></td></tr></table></figure><p><code>DishController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *菜品管理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/dish&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DishController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishService dishService;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> DishDto dishDto)</span>&#123;<br>        log.info(dishDto.toString());<br>        dishService.saveWithFlavor(dishDto);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;添加菜品成功&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="菜品信息分页查询"><a href="#菜品信息分页查询" class="headerlink" title="菜品信息分页查询"></a><strong>菜品信息分页查询</strong></h2><p>菜品的分页展示，比之前的两个分页要难一些，因为要展示图片，和菜品分类的名称（因为菜品里面没有菜品名称的属性，有的是菜品的id，因此要对照菜品的分类来进行显示）</p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220810163605767.png" alt="image-20220810163605767"></p><p><strong>分析：</strong></p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220810163900469.png" alt="image-20220810163900469"></p><p><strong>前端发送的请求：</strong></p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220810170247219.png" alt="image-20220810170247219"></p><p><strong>代码为：</strong>（相对复杂，因为页面要展示菜品的名称而不是id，所以不能使用Dish，要使用DishDto）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 分页</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span>    <br><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br>   <span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page,<span class="hljs-type">int</span> pageSize,String name)</span>&#123;<br>       <span class="hljs-comment">//构造分页构造器</span><br>       Page&lt;Dish&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(page,pageSize);<br>       <span class="hljs-comment">//因为Dish中没有菜品分类名称，只有菜品分类id，而DishDTO中又分类名称，所以，要将查询的结果拷贝到DishDTO中</span><br>       Page&lt;DishDto&gt; dishDtoPage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;();<br><br>       <span class="hljs-comment">//构造条件构造器</span><br>       LambdaQueryWrapper&lt;Dish&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>       lambdaQueryWrapper.like(name!=<span class="hljs-literal">null</span>,Dish::getName,name);<br>       lambdaQueryWrapper.orderByDesc(Dish::getUpdateTime);<br>       <span class="hljs-comment">//执行分页查询</span><br>       dishService.page(pageInfo,lambdaQueryWrapper);<br>       <span class="hljs-comment">//对象拷贝,忽略records属性(records就是所有菜品的列表项)，因为我们要自己定义records，将id变为name</span><br>       BeanUtils.copyProperties(pageInfo,dishDtoPage,<span class="hljs-string">&quot;records&quot;</span>);<br><br>       <span class="hljs-comment">//获取dish中菜单的每一项</span><br>       List&lt;Dish&gt; records = pageInfo.getRecords();<br><br>       <span class="hljs-comment">//将菜单的每一项拷贝到dishDto中，并重新设置菜品分类的名称，自己设置忽略的records</span><br>       List&lt;DishDto&gt; dishDtoList = records.stream().map((item)-&gt;&#123;<br>           <span class="hljs-type">DishDto</span> <span class="hljs-variable">dishDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DishDto</span>();<br><br>           <span class="hljs-comment">//对象拷贝，因为dishDto，是新建的，要将dish中的record拷贝到dishDto中</span><br>           BeanUtils.copyProperties(item,dishDto);<br><br>           <span class="hljs-comment">//获取分类id</span><br>           <span class="hljs-type">Long</span> <span class="hljs-variable">categoryId</span> <span class="hljs-operator">=</span> item.getCategoryId();<br>           <span class="hljs-comment">//根据分类id获取分类</span><br>           <span class="hljs-type">Category</span> <span class="hljs-variable">category</span> <span class="hljs-operator">=</span> categoryService.getById(categoryId);<br>           <span class="hljs-keyword">if</span> (category!=<span class="hljs-literal">null</span>)&#123;<br>               <span class="hljs-comment">//通过分类获取分类名称</span><br>               <span class="hljs-type">String</span> <span class="hljs-variable">categoryName</span> <span class="hljs-operator">=</span> category.getName();<br>               <span class="hljs-comment">//设置dishDto的分类名称</span><br>               dishDto.setCategoryName(categoryName);<br>           &#125;<br>           <span class="hljs-keyword">return</span> dishDto;<br><br>       &#125;).collect(Collectors.toList());<br><br>       <span class="hljs-comment">//将修改完的records设置给dishDtoPage</span><br>       dishDtoPage.setRecords(dishDtoList);<br>       <br>       <span class="hljs-keyword">return</span> R.success(dishDtoPage);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="修改菜品"><a href="#修改菜品" class="headerlink" title="修改菜品"></a>修改菜品</h2><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220811213647314.png" alt="image-20220811213647314"></p><p><strong>第一步：首先,要将菜品信息进行回显</strong></p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220811214704864.png" alt="image-20220811214704864"></p><p><strong>代码为：</strong></p><p>首先要根据页面发送请求中的id查询，以上这些菜品的基本的信息以及口味。</p><p>编写DishService代码，写根据id获取信息的代码，因为不仅要获取基本的Dish信息还要获取口味信息。</p><p><strong>DishServiceImpl.java:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据id获取菜品基本信息和口味</span><br><span class="hljs-comment">    * 回显</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> DishDto <span class="hljs-title function_">getByIdWithFlavor</span><span class="hljs-params">(Long id)</span> &#123;<br><br>       <span class="hljs-type">Dish</span> <span class="hljs-variable">dish</span> <span class="hljs-operator">=</span> dishService.getById(id);<br><br>       <span class="hljs-type">DishDto</span> <span class="hljs-variable">dishDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DishDto</span>();<br><br>       <span class="hljs-comment">//将基本的信息copy过去</span><br>       BeanUtils.copyProperties(dish,dishDto);<br><br>       LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>       <span class="hljs-comment">//根据id查询口味</span><br>       lambdaQueryWrapper.eq(DishFlavor::getDishId,dish.getId());<br>       <span class="hljs-comment">//以列表的形式展示</span><br>       List&lt;DishFlavor&gt; list = dishFlavorService.list(lambdaQueryWrapper);<br>       <span class="hljs-comment">//设置口味</span><br>       dishDto.setFlavors(list);<br>       <span class="hljs-keyword">return</span> dishDto;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>DishController.java:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 修改菜品时，将菜品信息进行回显</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>   <span class="hljs-keyword">public</span> R&lt;DishDto&gt; <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span>&#123;<br>       <span class="hljs-type">DishDto</span> <span class="hljs-variable">dishDto</span> <span class="hljs-operator">=</span> dishService.getByIdWithFlavor(id);<br>       <span class="hljs-keyword">return</span> R.success(dishDto);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>回显成功：</strong></p><p><img src="/2022/08/11/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day03/image-20220811220005154.png" alt="image-20220811220005154"></p><p><strong>第二步：点击保存，修改成功：</strong></p><p>修改也不能用系统给的普通修改，因为要修改两个表，菜品表和口味表。因此要重写更新方法</p><p><strong>DishServiceImpl.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 更新菜品信息和口味</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateWithFlavor</span><span class="hljs-params">(DishDto dishDto)</span> &#123;<br>       <span class="hljs-comment">//更新菜单信息</span><br>       <span class="hljs-built_in">this</span>.updateById(dishDto);<br><br>       <span class="hljs-comment">//清理当前菜品的口味数据</span><br>       LambdaQueryWrapper&lt;DishFlavor&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>       lambdaQueryWrapper.eq(DishFlavor::getDishId,dishDto.getId());<br>       dishFlavorService.remove(lambdaQueryWrapper);<br><br>       <span class="hljs-comment">//添加更新后的口味数据</span><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> dishDto.getId();<br>       <span class="hljs-comment">//获取新更新的口味</span><br>       List&lt;DishFlavor&gt; flavors = dishDto.getFlavors();<br>       <span class="hljs-comment">//设置口味的id</span><br>       flavors = flavors.stream().map((item)-&gt;&#123;<br>           item.setDishId(id);<br>           <span class="hljs-keyword">return</span> item;<br>       &#125;).collect(Collectors.toList());<br>       dishFlavorService.saveBatch(flavors);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>DishController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 修改菜品，点击保存</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@PutMapping</span><br>   <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> DishDto dishDto)</span>&#123;<br>       dishService.updateWithFlavor(dishDto);<br>       <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;修改菜品成功&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>成功~~</p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>office中的一些操作</title>
    <link href="/2022/08/01/office/"/>
    <url>/2022/08/01/office/</url>
    
    <content type="html"><![CDATA[<h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><h2 id="选中数据"><a href="#选中数据" class="headerlink" title="选中数据"></a>选中数据</h2><ul><li><p>方法一：<code>ctrl+shif+上下左右键</code>：用来选中数据</p></li><li><p>方法二：<code>shif+双击四条边</code></p></li></ul><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><p>将上面方法选中的数据，进行一下操作，计算金额求和。</p><p>选中的区域，右键：</p><p><img src="/2022/08/01/office/image-20220801093317369.png" alt="image-20220801093317369"></p><p>选择运算的乘：</p><p><img src="/2022/08/01/office/image-20220801093209028.png" alt="image-20220801093209028"></p><p><img src="/2022/08/01/office/image-20220801093404927.png" alt="image-20220801093404927"></p><h2 id="录入当前日期"><a href="#录入当前日期" class="headerlink" title="录入当前日期"></a>录入当前日期</h2><p>日期：快捷键：<code>ctrl+；</code></p><p><img src="/2022/08/01/office/image-20220801093702219.png" alt="image-20220801093702219"></p><p>时间：快捷键：<code>ctrl+shif+；</code></p><p><img src="/2022/08/01/office/image-20220801093736536.png" alt="image-20220801093736536"></p><p>日期和时间：快捷键：<code>ctrl+；+空格+ctrl+shif+；</code></p><p><img src="/2022/08/01/office/image-20220801093852671.png" alt="image-20220801093852671"></p><h3 id="修改日期格式"><a href="#修改日期格式" class="headerlink" title="修改日期格式"></a>修改日期格式</h3><p>点击数据+–分列</p><p><img src="/2022/08/01/office/image-20220801094744264.png" alt="image-20220801094744264"></p><p>一直下一步，到不能按为止：</p><p><img src="/2022/08/01/office/image-20220801094731471.png" alt="image-20220801094731471"></p><p>设置单元格，日期对齐，类型填写以下：</p><p><img src="/2022/08/01/office/image-20220801094936645.png" alt="image-20220801094936645"></p><h3 id="计算两个时间的差值："><a href="#计算两个时间的差值：" class="headerlink" title="计算两个时间的差值："></a>计算两个时间的差值：</h3><p><img src="/2022/08/01/office/image-20220801095420692.png" alt="image-20220801095420692"></p><p>以小时进行汇总：</p><p><img src="/2022/08/01/office/image-20220801095346106.png" alt="image-20220801095346106"></p><h3 id="填充日期"><a href="#填充日期" class="headerlink" title="填充日期"></a>填充日期</h3><p><img src="/2022/08/01/office/image-20220801095859835.png" alt="image-20220801095859835"></p><p><img src="/2022/08/01/office/image-20220801095945981.png" alt="image-20220801095945981"></p><p>列与列的接缝处，双击，自适应行的长度</p><p><img src="/2022/08/01/office/image-20220801100135012.png" alt="image-20220801100135012"></p><p><code>shif+上下左右键</code>：对当前选区进行扩展和减少选区的</p><p><code>ctrl+d</code>：向下填充</p><h3 id="设置星期："><a href="#设置星期：" class="headerlink" title="设置星期："></a>设置星期：</h3><p><img src="/2022/08/01/office/image-20220801100639916.png" alt="image-20220801100639916"></p><p><img src="/2022/08/01/office/image-20220801100655326.png" alt="image-20220801100655326"></p><h2 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h2><p><strong>汇总三年，金额比较：</strong></p><p><img src="/2022/08/01/office/image-20220801103003121.png" alt="image-20220801103003121"></p><p><img src="/2022/08/01/office/image-20220801103012018.png" alt="image-20220801103012018"></p><p><img src="/2022/08/01/office/image-20220801102858593.png" alt="image-20220801102858593"></p><h2 id="表格中数据的填写"><a href="#表格中数据的填写" class="headerlink" title="表格中数据的填写"></a>表格中数据的填写</h2><p><strong><code>Alt+下</code>：</strong></p><p><img src="/2022/08/01/office/image-20220801104646855.png" alt="image-20220801104646855"></p><p><strong>按tab键，右移表格</strong></p><h2 id="数据的一致性问题"><a href="#数据的一致性问题" class="headerlink" title="数据的一致性问题"></a>数据的一致性问题</h2><blockquote><p> ALT+下：也可以检查数据是否是一致性的问题</p></blockquote><p><img src="/2022/08/01/office/image-20220801105141709.png" alt="image-20220801105141709"></p><p>其中有两个神州行，说明两个神州行是不一样的格式</p><p><strong>处理方法：</strong></p><blockquote><p> 将空格全部替换掉 ：<code>ctrl+h</code></p></blockquote><h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><p><img src="/2022/08/01/office/image-20220801105609852.png" alt="image-20220801105609852"></p><p><strong>选中右键：</strong></p><p><img src="/2022/08/01/office/image-20220801105631602.png" alt="image-20220801105631602"></p><p><strong>设置如下的对齐方式：</strong></p><p><img src="/2022/08/01/office/image-20220801105717571.png" alt="image-20220801105717571"></p><p><strong>结果：</strong></p><p><img src="/2022/08/01/office/image-20220801105731330.png" alt="image-20220801105731330"></p><h2 id="删除重复值"><a href="#删除重复值" class="headerlink" title="删除重复值"></a>删除重复值</h2><p><img src="/2022/08/01/office/image-20220801110147549.png" alt="image-20220801110147549"></p><p><img src="/2022/08/01/office/image-20220801110152914.png" alt="image-20220801110152914"></p><h2 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h2><p><img src="/2022/08/01/office/image-20220801110728924.png" alt="image-20220801110728924"></p><p><img src="/2022/08/01/office/image-20220801110740485.png" alt="image-20220801110740485"></p><p><img src="/2022/08/01/office/image-20220801110707990.png" alt="image-20220801110707990"></p><h2 id="选取一部分数据的时候：A10-D20"><a href="#选取一部分数据的时候：A10-D20" class="headerlink" title="选取一部分数据的时候：A10:D20"></a><strong>选取一部分数据的时候：<code>A10:D20</code></strong></h2><p><img src="/2022/08/01/office/image-20220801135443735.png" alt="image-20220801135443735"></p><h2 id="换列"><a href="#换列" class="headerlink" title="换列"></a>换列</h2><p><img src="/2022/08/01/office/image-20220801135903541.png" alt="image-20220801135903541"></p><h2 id="日期改为星期"><a href="#日期改为星期" class="headerlink" title="日期改为星期"></a>日期改为星期</h2><blockquote><p> 格式里面的自定义改为aaaa</p></blockquote><blockquote><p> 英文的星期将格式的自定义改为：dddd（其中ddd为缩写）</p></blockquote><h2 id="高级筛选"><a href="#高级筛选" class="headerlink" title="高级筛选"></a>高级筛选</h2><p><img src="/2022/08/01/office/image-20220801140400035.png" alt="image-20220801140400035"></p><p><img src="/2022/08/01/office/image-20220801140409797.png" alt="image-20220801140409797"></p><p><strong>并条件：</strong></p><p><img src="/2022/08/01/office/image-20220801140456758.png" alt="image-20220801140456758"></p><p><strong>或条件：</strong></p><p><img src="/2022/08/01/office/image-20220801140538157.png" alt="image-20220801140538157"></p><p><strong>不同的条件可以随意抓取，需要录制宏</strong></p><p><img src="/2022/08/01/office/image-20220801140645198.png" alt="image-20220801140645198"></p><p><img src="/2022/08/01/office/image-20220801140655441.png" alt="image-20220801140655441"></p><p><strong>重新抓取条件，后结束录制，这样以下，可以通过不同的条件进行查询</strong></p><p><img src="/2022/08/01/office/image-20220801140702838.png" alt="image-20220801140702838"></p><h2 id="统计计算"><a href="#统计计算" class="headerlink" title="统计计算"></a>统计计算</h2><h3 id="对查询出来的数据进行统计"><a href="#对查询出来的数据进行统计" class="headerlink" title="对查询出来的数据进行统计"></a>对查询出来的数据进行统计</h3><p><img src="/2022/08/01/office/image-20220801142459688.png" alt="image-20220801142459688"></p><p><strong>名称公式：</strong></p><p><img src="/2022/08/01/office/image-20220801142848453.png" alt="image-20220801142848453"></p><p>乘法表：</p><p><img src="/2022/08/01/office/image-20220801144640852.png" alt="image-20220801144640852"></p><p>F4的功能键进行切换：</p><table><thead><tr><th>相对引用</th><th>列号行号(A1)</th><th>拷到哪变到哪</th></tr></thead><tbody><tr><td><strong>绝对引用</strong></td><td><strong>$列号$行号($A$1)</strong></td><td><strong>拷到哪都不变的引用</strong></td></tr><tr><td><strong>混合引用</strong></td><td><strong>列号$行号(A$1)</strong></td><td><strong>锁什么就在什么上取值</strong></td></tr><tr><td><strong>混合引用</strong></td><td><strong>$列号行号($A1)</strong></td><td><strong>要在什么上取值就把什么锁定</strong></td></tr></tbody></table><p><strong>乘法表：</strong></p><blockquote><p> &#x3D;IF(R$21&gt;&#x3D;S$20,$R21&amp;”x”&amp;S$20&amp;”&#x3D;”&amp;$R21*S$20,” “)</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="多条件求和：sumifs-把什么求和，1在哪里找，1找什么。。。N在哪里找，n找什么"><a href="#多条件求和：sumifs-把什么求和，1在哪里找，1找什么。。。N在哪里找，n找什么" class="headerlink" title="多条件求和：sumifs(把什么求和，1在哪里找，1找什么。。。N在哪里找，n找什么)"></a>多条件求和：sumifs(把什么求和，1在哪里找，1找什么。。。N在哪里找，n找什么)</h3><p><img src="/2022/08/01/office/image-20220801153315665.png" alt="image-20220801153315665"></p><p><strong>二维统计：</strong></p><p><img src="/2022/08/01/office/image-20220801154146393.png" alt="image-20220801154146393"></p><h3 id="多条件计数：countifs（1在哪找，2找什么。。。n在哪找，n找什么）"><a href="#多条件计数：countifs（1在哪找，2找什么。。。n在哪找，n找什么）" class="headerlink" title="多条件计数：countifs（1在哪找，2找什么。。。n在哪找，n找什么）"></a>多条件计数：countifs（1在哪找，2找什么。。。n在哪找，n找什么）</h3><p><img src="/2022/08/01/office/image-20220801161930239.png" alt="image-20220801161930239"></p><p><strong>numberstring：</strong>将数字转换为人民币数的大写</p><p><img src="/2022/08/01/office/image-20220801161941434.png" alt="image-20220801161941434"></p><p><img src="/2022/08/01/office/image-20220801161950887.png" alt="image-20220801161950887"></p><p><strong>计算年龄：</strong></p><p><img src="/2022/08/01/office/image-20220801162742208.png" alt="image-20220801162742208"></p><p><img src="/2022/08/01/office/image-20220801163151726.png" alt="image-20220801163151726"></p><p><img src="/2022/08/01/office/image-20220801163219988.png" alt="image-20220801163219988"></p><p>yd：除去整年余下的天数</p><h2 id="vlookup-找什么，在哪个范围找，要这个范围中第几列的值，精确查找（0）"><a href="#vlookup-找什么，在哪个范围找，要这个范围中第几列的值，精确查找（0）" class="headerlink" title="vlookup(找什么，在哪个范围找，要这个范围中第几列的值，精确查找（0）)"></a>vlookup(找什么，在哪个范围找，要这个范围中第几列的值，精确查找（0）)</h2><p><strong>注意事项：</strong></p><ul><li><p>被找对象，在查找范围中，要唯一</p></li><li><p>查找范围的第一列要是被找对象，</p></li><li><p>格式要一致</p></li></ul><p><img src="/2022/08/01/office/image-20220801173230344.png" alt="image-20220801173230344"></p><h1 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h1><h2 id="幻灯片的大纲"><a href="#幻灯片的大纲" class="headerlink" title="幻灯片的大纲"></a>幻灯片的大纲</h2><p><img src="/2022/08/01/office/image-20220802090835021.png" alt="image-20220802090835021"></p><blockquote><p>tab：降级</p></blockquote><blockquote><p>shift+tab：升级</p></blockquote><h2 id="引入word文档"><a href="#引入word文档" class="headerlink" title="引入word文档"></a>引入word文档</h2><p><img src="/2022/08/01/office/image-20220802091251679.png" alt="image-20220802091251679"></p><h2 id="套入主题"><a href="#套入主题" class="headerlink" title="套入主题"></a>套入主题</h2><p><img src="/2022/08/01/office/image-20220802102214969.png" alt="image-20220802102214969"></p><h2 id="将第一页设置为标题页"><a href="#将第一页设置为标题页" class="headerlink" title="将第一页设置为标题页"></a>将第一页设置为标题页</h2><p><img src="/2022/08/01/office/image-20220802102256911.png" alt="image-20220802102256911"></p><h2 id="擅长利用版式"><a href="#擅长利用版式" class="headerlink" title="擅长利用版式"></a>擅长利用版式</h2><p><img src="/2022/08/01/office/image-20220802102700605.png" alt="image-20220802102700605"></p><p><code>ctrl+y</code>：重复上一条命令</p><h2 id="图标符号"><a href="#图标符号" class="headerlink" title="图标符号"></a>图标符号</h2><p><img src="/2022/08/01/office/image-20220802154727235.png" alt="image-20220802154727235"></p><h1 id="word"><a href="#word" class="headerlink" title="word"></a>word</h1><h2 id="标题排版"><a href="#标题排版" class="headerlink" title="标题排版"></a>标题排版</h2><p><code>ctrl+h:</code></p><p><img src="/2022/08/01/office/image-20220802094158081.png" alt="image-20220802094158081"></p><p>？：表示一个字符</p><p>*：表示一串字符</p><p><strong>四级标题：</strong></p><p><img src="/2022/08/01/office/image-20220802095552339.png" alt="image-20220802095552339"></p><h2 id="随机生成文本"><a href="#随机生成文本" class="headerlink" title="随机生成文本"></a>随机生成文本</h2><p><code>=rand(5,10)</code>（5：是段数，10：是每段几行）</p><h2 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h2><p>右键选择段落：</p><p><img src="/2022/08/01/office/image-20220802165830333.png" alt="image-20220802165830333"></p><h2 id="落款"><a href="#落款" class="headerlink" title="落款"></a>落款</h2><p>居中对齐，版面不会乱：</p><p><img src="/2022/08/01/office/image-20220802171246612.png" alt="image-20220802171246612"></p><h2 id="更新标题格式"><a href="#更新标题格式" class="headerlink" title="更新标题格式"></a>更新标题格式</h2><p>根据最近更新的标题格式，统一后面全部标题的格式：</p><p><img src="/2022/08/01/office/image-20220802171616681.png" alt="image-20220802171616681"></p><h2 id="对于多个段落的文章，进行段落的首行缩进"><a href="#对于多个段落的文章，进行段落的首行缩进" class="headerlink" title="对于多个段落的文章，进行段落的首行缩进"></a>对于多个段落的文章，进行段落的首行缩进</h2><p>如果段落要缩进，则不要全部选择，选择要进行缩进的某段中几个文字，进行以下操作。</p><p><img src="/2022/08/01/office/image-20220802171741707.png" alt="image-20220802171741707"></p>]]></content>
    
    
    <categories>
      
      <category>office</category>
      
    </categories>
    
    
    <tags>
      
      <tag>office</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础学习</title>
    <link href="/2022/07/26/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/07/26/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-IP协议栈"><a href="#TCP-x2F-IP协议栈" class="headerlink" title="TCP&#x2F;IP协议栈"></a>TCP&#x2F;IP协议栈</h1><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p>应用层—表示层–会话层–传输层–网络层–数据链路层–物理层</p><h2 id="TCP-x2F-IP模型"><a href="#TCP-x2F-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h2><p>应用层–传输层–网路层–数据链路层–物理层</p><ul><li>应用层：（HTTP、Telnet、FTP、TFTP、Ping）:主要用来提供应用程序网络接口</li><li>传输层：（TCP&#x2F;UDP）：建立端到端的连接</li><li>网络层：（IP）寻址和路由选择</li><li>数据链路层：（Ethernet）：物理介质访问</li><li>物理层：（接口和线缆）：二进制数据流传输</li></ul><h2 id="TCP-x2F-IP模型的层间通信与数据封装"><a href="#TCP-x2F-IP模型的层间通信与数据封装" class="headerlink" title="TCP&#x2F;IP模型的层间通信与数据封装"></a>TCP&#x2F;IP模型的层间通信与数据封装</h2><p>TCP&#x2F;IP中层与层之间的通信使用PDU（协议数据单元）来彼此交换信息，确保网络之间可以通信。不同层的PDU包含不同的信息。</p><p>其中，这种添加报文和报尾的过程称为封装。</p><ul><li>传输层在上层数据中加入了TCP报文后得到的PDU被称为Segment（数据段）。</li><li>数据段传递给网络层之后，添加IP不报文得到的PDU称为Packet（数据包）。</li><li>数据包传递给数据链路层，封装数据链路层报文得到的PDU称为Frame（数据帧）</li><li>最后帧被转换为比特，通过网络介质传输</li></ul><p>接受设备将删除添加的信息，根据报头中的信息决定如何将数据沿协议栈上传给合适的应用程序，这个过程称为解封装。</p><p><strong>不同的设备对等层之间依靠封装和解封装来实现相互间的通信</strong></p><h2 id="物理层的主要功能（传输数据所需要的机械、电气、功能特性及过程等手段）"><a href="#物理层的主要功能（传输数据所需要的机械、电气、功能特性及过程等手段）" class="headerlink" title="物理层的主要功能（传输数据所需要的机械、电气、功能特性及过程等手段）"></a>物理层的主要功能（传输数据所需要的机械、电气、功能特性及过程等手段）</h2><p><strong>功能：</strong></p><ul><li>规定介质类型，接口类型，信令类型</li><li>规范在终端系统之间激活，维护和关闭物理链路的电气等</li><li>规范电平，数据速率，最大传输距离和物理接头等特征</li></ul><p>物理层标准规定了物理介质和用于将设备与物理介质相连的接头。</p><p><strong>物理层介质：</strong></p><ul><li>同轴电缆：分为粗（距离长、可靠性高，安装时不需要切断电缆，但必须安装收发器电缆）和细（简单，造价低，安装时要切断电缆，两头需要安装网络连接头），</li><li>双绞线：常用的电缆线分为屏蔽双绞线（很强的抗电磁干扰和无线电干扰，昂贵）和非屏蔽双绞线（价格便宜相对来说抗干扰能力较弱）</li><li>光纤：不受信号干扰，传输速率高，距离长，昂贵</li><li>无线电波：可以实现两地之间不设置物理线路也能够迅速通信，无线电波指的时自由空间传播的电磁波</li></ul><p>物理层设备：</p><ul><li>中继器、集线器（很少使用，不作描述）</li></ul><h2 id="数据链路层的功能（提供对物理层的控制，纠正可能出现的错误）"><a href="#数据链路层的功能（提供对物理层的控制，纠正可能出现的错误）" class="headerlink" title="数据链路层的功能（提供对物理层的控制，纠正可能出现的错误）"></a>数据链路层的功能（提供对物理层的控制，纠正可能出现的错误）</h2><p><strong>分为两个子层：</strong></p><p>MAC子层：数据如何通过物理线路进行传输，并与物理层进行通信</p><p>LLC子层（位于MAC层和网络层之间）：识别协议类型，并对数据进行封装通过网络进行传输。</p><p><strong>数据链路层的协议（规定了数据链路层的封装方式）：</strong></p><p>局域网和广域网协议</p><p><strong>数据链路层地址：</strong></p><p>MAC地址：有48位。（每一台网络设备都用物理地址来标识自己，是全球唯一的，）</p><blockquote><p> RAM(random acess memory) 随机存储器，可读可写，存储速度快，但是容易丢失数据，断电后数据就会丢失，一般用来存储用户正在运行的程序</p></blockquote><blockquote><p>ROM(read only memory) 只读存储器，仅仅能读取内容而不能写入的存储器，但是不易丢失数据，一般系统程序都存储在ROM中，一般硬盘，U盘，存储卡都是ROM类的</p></blockquote><h2 id="网络层功能与设备（检查网络拓扑，决定传输报文的最佳路由）"><a href="#网络层功能与设备（检查网络拓扑，决定传输报文的最佳路由）" class="headerlink" title="网络层功能与设备（检查网络拓扑，决定传输报文的最佳路由）"></a>网络层功能与设备（检查网络拓扑，决定传输报文的最佳路由）</h2><p><strong>功能：</strong></p><p>在不同的网络之间转发数据包</p><p>可以总结位两条：</p><ul><li>提供逻辑寻址：如果数据跨网络传递，则需要使用逻辑地址来寻址</li><li>路由：将数据报文从一个网络转发到另一个网络</li></ul><p><strong>设备：</strong></p><p>路由器（最常见）、三层交换机、</p><p><strong>网络层协议：</strong></p><p>IP、ICMP、ARP、RARP</p><p>IP：最主要的协议，功能是网络层的主要功能（提供逻辑地址，提供路由功能，报文的封装和解封），寻找传送到目的端的最优路径，不关心报文的内容，无连接，不可靠的服务。</p><p>ICMP：管理协议，为IP提供信息服务，定义了网络层控制和传递消息的功能，可以获取网络中问题的反馈</p><p>ARP：实现IP地址到硬件地址的映射</p><p>RARP：实现硬件地址和IP地址的映射</p><p><strong>网络层地址：</strong></p><p>IP地址包含两部分：网络ID和主机ID。（长度是4个字节）</p><h2 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h2><p><strong>功能：</strong></p><ul><li>分段上层数据（应用层到网络层的数据进行分段，网络层发往应用层的数据进行合并）</li><li>建立端到端的连接</li><li>将数据从一端主机传送到另一端主机</li><li>保证数据按序、可靠、正确传输。</li></ul><p><strong>协议：</strong></p><p>TCP、UDP</p><h2 id="应用层功能（为应用程序提供网络服务）"><a href="#应用层功能（为应用程序提供网络服务）" class="headerlink" title="应用层功能（为应用程序提供网络服务）"></a>应用层功能（为应用程序提供网络服务）</h2><p>功能：</p><ul><li>为用户提供接口、处理特定的应用</li><li>数据加密、解密、压缩、解压缩</li><li>定义数据表示的标准</li></ul><h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p>TCP数据段由TCP头部和TCP数据组成。</p><p>TCP Head：</p><ul><li>Source Port：源端口号</li><li>Destination Port：目的端口号</li><li>Sequence Number：序列号：标识发送端到接收端发送的数据字节流</li><li>Ack Num：确认序列号，上次是成功收到的数据序列号+1</li><li>Option：选项字段</li></ul><h2 id="IP报文"><a href="#IP报文" class="headerlink" title="IP报文"></a>IP报文</h2><ul><li>版本号：4&#x2F;6</li><li>报文长度</li><li>服务类型</li><li>总长度：IP数据包的长度，包含数据部分</li><li>标识符：唯一的标识主机发送的每一份数据包，每发送一份数据报文就+1</li><li>生存时间：数据包可以经过的路由数目，经过一个-1，当为0时丢弃</li><li>协议：TCP（6）&#x2F;UDP（17）</li><li>报头检验和：检查头部的完整性</li><li>源IP地址</li><li>目的IP地址</li></ul><h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧-"></a>数据帧-</h2><ul><li>DMAC：目的的终端MAC地址</li><li>SMAC：源端MAC地址</li><li>LENGTH&#x2F;TYPE：根据值的不同有不同的含义<ul><li>大于1500时表示类型，</li><li>小于1500时表示数据帧的长度</li></ul></li></ul><h1 id="MAC地址和IP地址的区别"><a href="#MAC地址和IP地址的区别" class="headerlink" title="MAC地址和IP地址的区别"></a>MAC地址和IP地址的区别</h1><p>mac地址：是固化在设备硬件上的物理地址，不能修改</p><p>ip地址：存在于网络层，可以修改，分为公共地址（全球唯一）和私有地址（局域网内可以重复使用）</p><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>IP地址分为两部分：网络地址（表示 一个网段）和主机地址部分（表示网段中的一台设备）</p><p>主机地址部分也可以划分为子网部分和主机部分。</p><h1 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h1><p>子网掩码中1的部分表示网络ID，0的部分表示主机ID。</p><p>子网掩码的CIDR反斜杠表示方法：IP地址&#x2F;网络ID的位数，比如192.168.23.35&#x2F;21，其中用21位表示网络ID。</p><p>网络号：表示的是网络中的一个子网</p><p>主机号：子网中的某台主机</p><p><strong>IP地址和网络地址：</strong></p><p>IP地址是指主机的地址，网络地址是网络中的地址。</p><p>IP地址与子网掩码相与得到了网络地址。</p><h1 id="主机数的计算"><a href="#主机数的计算" class="headerlink" title="主机数的计算"></a>主机数的计算</h1><p>主机数的计算：子网掩码中0的个数为N，则主机数为2的N次幂-2.其中的2值得是全为0的网络地址和全为1的广播地址。</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="路由器的作用"><a href="#路由器的作用" class="headerlink" title="路由器的作用"></a>路由器的作用</h2><p>运行在网络层，实现网路的连接</p><p>主要作用是：将不同的网络互连为一个整体。</p><ul><li>数据转发：根据目的网络的地址转发分组</li><li>路由寻址：建立，刷新路由表，根据路由表转发数据包</li><li>备份和流量流控：保证网络可靠运行</li><li>速率适配：可以利用自己的缓存来适配不同接口的速率</li><li>隔离网络：隔离广播网络，防止广播风暴</li><li>异种网络互连：实现不同网络协议之间的互连</li></ul><h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><p>所有的报文转发都要通过查找路由表从相应端口发送</p><p><strong>内容：</strong></p><ul><li>目的地址</li><li>网络掩码：与目的地址与得到网段的地址</li><li>输出接口：从路由器的哪个接口转发</li><li>下一跳：下一个路由器的接口地址</li></ul><h2 id="CIDR（无类域间路由）"><a href="#CIDR（无类域间路由）" class="headerlink" title="CIDR（无类域间路由）"></a>CIDR（无类域间路由）</h2><p>使用VLSM（可变长子网掩码）技术，将路由器表中的若干条路汇聚一条路由，减少路由表的规模，提高可扩展性。</p><h2 id="Ping和Tracert的区别"><a href="#Ping和Tracert的区别" class="headerlink" title="Ping和Tracert的区别"></a>Ping和Tracert的区别</h2><p>都可以用于测试网络的连通性，</p><ul><li><p>ping：可以提供选项来满足不同的测试需求，如：发出报文的源ip和源端口，</p></li><li><p>Tracert：更多的是获取数据包的转发途径，通过Tracert可以初步的判断故障。</p></li></ul><h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><p>是路由器之间交互信息的一种语言，路由器之间通过协议可以共享网络状态和网络中的一些可达路由信息，只有使用同种语言的路由器才可以交互信息，不同种语言的路由器也可以通过某些方式来获取其他路由器的信息。</p><h2 id="自治系统（AS）"><a href="#自治系统（AS）" class="headerlink" title="自治系统（AS）"></a>自治系统（AS）</h2><p>是被统一管理的一组网路</p><h1 id="PON网络"><a href="#PON网络" class="headerlink" title="PON网络"></a>PON网络</h1><p>PON网络包含：OLT、ODN、ONU</p><p>OLT：光线路终端，终结PON协议的汇聚设备。</p><p>ODN：是由一个或多个<strong>无源分光器</strong>组成，在OLT火绒ONU 之间提供光通道，起着连接OLT和ONU的作用。</p><p>ONU：位于客户端的给用户提供各种接口的用户o侧单元或终端，</p><p>OLT和ONU通过中间的无源光网络ODN连接起来进行互相通信，</p><h2 id="数据复用原理"><a href="#数据复用原理" class="headerlink" title="数据复用原理"></a>数据复用原理</h2><p>10G GPON运用波分复用技术（WDM），实现一根光纤传输上行和下行。</p><p>一根光纤上多个用户的信号：</p><ul><li>下行数据采用广播技术</li><li>上行数据采用TDMA技术</li></ul><p>TDMA：时分多址</p><h1 id="GPON"><a href="#GPON" class="headerlink" title="GPON"></a>GPON</h1><p><img src="/2022/07/26/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20220728143943958.png" alt="image-20220728143943958"></p><h2 id="下行数据和上行数据"><a href="#下行数据和上行数据" class="headerlink" title="下行数据和上行数据"></a>下行数据和上行数据</h2><p>下行数据（发送给用户）：使用广播方式，将网络上的数据发送给ONU（用户），也就是客户端，ONU收到下行的数据，根据GEM Port-ID识别是否接受此数据。</p><p>上行数据（用户发出的数据）：TDMA方式时分多址，根据不同的时隙（解决上行传输不冲突）来向服务器请求和确认，不能使用广播的方式，因为这样服务器将不知道处理哪个。</p><h2 id="T-CONT"><a href="#T-CONT" class="headerlink" title="T-CONT"></a>T-CONT</h2><p>上行方向承载业务的载体，所有的GEM Port都要映射到T-CONT中，T-CONT是10G GPON系统上业务最基本的控制单元。</p><h2 id="DBA"><a href="#DBA" class="headerlink" title="DBA"></a>DBA</h2><p>DBA（Dynamic Bandwidth Assignment）：动态带宽分配</p><p>DBA能在微妙或毫秒的时间内完成对上行带宽的动态分配</p><p><strong>为什么使用DBA：</strong></p><p>可以提高PON端口的上行线路带宽利用率</p>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>国企</category>
      
      <category>中国移动</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal的使用</title>
    <link href="/2022/07/22/%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/22/%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal（day02中）"><a href="#ThreadLocal（day02中）" class="headerlink" title="ThreadLocal（day02中）"></a>ThreadLocal（day02中）</h1><p>在新增过程中，需要设置以下四个字段，在更新的过程中需要设置后两个字段，每次新增（新增员工，菜单等等）时就需要设置。而这些代码属于重复部分，可以拿出来，不用反复重写。在mybatisplus中提供了一种方法，<strong>公共字段自动填充功能</strong></p><p><img src="/2022/07/22/%E6%96%B9%E6%B3%95/image-20220722124156125.png" alt="image-20220722124156125"></p><p>​<strong>元数据对象处理的代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义元数据对象处理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMateObjectandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增时，自动填充</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metaObject</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br><br>        <span class="hljs-comment">//设置创建时间，在实体类中可以看到时间的类型为：LocalDateTime</span><br>        metaObject.setValue(<span class="hljs-string">&quot;createTime&quot;</span>, LocalDateTime.now());<br><br>        <span class="hljs-comment">//设置更新时间</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime.now());<br><br>        <span class="hljs-comment">//设置创建者</span><br>        metaObject.setValue(<span class="hljs-string">&quot;createUser&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//设置更新者</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateUser&quot;</span>,  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(<span class="hljs-number">1</span>));<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新时，自动填充</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metaObject</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        <span class="hljs-comment">//设置更新时间</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime.now());<br>        <span class="hljs-comment">//设置更新者</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateUser&quot;</span>,  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(<span class="hljs-number">1</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码有问题，就是修改用户的id是写死的，<strong>因为不能定义HttpServletRequest，因此这里使用ThreadLocal的方法解决</strong></p><p><strong>因为每发送一次http请求，调用方法的线程都是同一个线程，</strong></p><p><strong>使用ThreadLocal：</strong></p><blockquote><p>ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。</p><p>可以通过 ThreadLocal<T> value &#x3D; new ThreadLocal<T>(); 来使用。</T></T></p><p><strong>会自动在每一个线程上创建一个 T 的副本，副本之间彼此独立，互不影响，可以用 ThreadLocal 存储一些参数，以便在线程中多个方法中使用，用以代替方法传参的做法。</strong></p></blockquote><p><img src="/2022/07/22/%E6%96%B9%E6%B3%95/image-20220722135352428.png" alt="image-20220722135352428"></p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
      <category>方法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖-分类管理</title>
    <link href="/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/"/>
    <url>/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/</url>
    
    <content type="html"><![CDATA[<h1 id="公共字段填充"><a href="#公共字段填充" class="headerlink" title="公共字段填充"></a>公共字段填充</h1><p>在新增过程中，需要设置以下四个字段，在更新的过程中需要设置后两个字段，每次新增（新增员工，菜单等等）时就需要设置。</p><p><img src="/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/image-20220722123847207.png" alt="image-20220722123847207"></p><p>而这些代码属于重复部分，可以拿出来，不用反复重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置创建时间，在实体类中可以看到时间的类型为：LocalDateTime</span><br>        employee.setCreateTime(LocalDateTime.now());<br><br>        <span class="hljs-comment">//设置更新时间</span><br>        employee.setUpdateTime(LocalDateTime.now());<br>        <span class="hljs-comment">//设置创建者</span><br>        <span class="hljs-comment">//获取目前登录用户的ID，也就是在session中的id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> (Long)request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>);<br>        employee.setCreateUser(userID);<br>        <span class="hljs-comment">//设置更新者</span><br>        employee.setUpdateUser(userID);<br></code></pre></td></tr></table></figure><p>在mybatisplus中提供了一种方法，<strong>公共字段自动填充功能</strong></p><p><img src="/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/image-20220722124156125.png" alt="image-20220722124156125"></p><p>实体的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> LocalDateTime createTime;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.UPDATE)</span><br><span class="hljs-keyword">private</span> LocalDateTime updateTime;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br><span class="hljs-keyword">private</span> Long createUser;<br><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> Long updateUser;<br></code></pre></td></tr></table></figure><p>元数据对象处理器的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义元数据对象处理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMateObjectandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增时，自动填充</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metaObject</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br><br>        <span class="hljs-comment">//设置创建时间，在实体类中可以看到时间的类型为：LocalDateTime</span><br>        metaObject.setValue(<span class="hljs-string">&quot;createTime&quot;</span>, LocalDateTime.now());<br><br>        <span class="hljs-comment">//设置更新时间</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime.now());<br><br>        <span class="hljs-comment">//设置创建者</span><br>        metaObject.setValue(<span class="hljs-string">&quot;createUser&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//设置更新者</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateUser&quot;</span>,  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(<span class="hljs-number">1</span>));<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新时，自动填充</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metaObject</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        <span class="hljs-comment">//设置更新时间</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime.now());<br>        <span class="hljs-comment">//设置更新者</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateUser&quot;</span>,  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(<span class="hljs-number">1</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码有问题，就是修改用户的id是写死的，<strong>因为不能定义HttpServletRequest，因此这里使用ThreadLocal的方法解决</strong></p><p><strong>因为每发送一次http请求，调用方法的线程都是同一个线程，</strong></p><p><img src="/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/image-20220722132157000.png" alt="image-20220722132157000"></p><p><strong>使用ThreadLocal：</strong></p><blockquote><p>ThreadLocal 是 Java 里一种特殊变量，它是一个线程级别变量，每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞态条件被彻底消除了，在并发模式下是绝对安全的变量。</p><p>可以通过 ThreadLocal<T> value &#x3D; new ThreadLocal<T>(); 来使用。</T></T></p><p>会自动在每一个线程上创建一个 T 的副本，副本之间彼此独立，互不影响，可以用 ThreadLocal 存储一些参数，以便在线程中多个方法中使用，用以代替方法传参的做法。</p></blockquote><p><img src="/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/image-20220722132809091.png" alt="image-20220722132809091"></p><p><img src="/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/image-20220722133003977.png" alt="image-20220722133003977"></p><p><strong>1、BaseContext.java:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zlw.reggie.common;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于ThreadLocal封装的工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseContext</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCurrentId</span><span class="hljs-params">(Long id)</span>&#123;<br>        threadLocal.set(id);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Long <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> threadLocal.get();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、LoginCheckFilter.java中设置登录用户id为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果是需要拦截的URI，则判断用户是否登录</span><br>        <span class="hljs-comment">//1、用户名不为空，证明已经登录，不需要拦截</span><br>        <span class="hljs-keyword">if</span> (request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>)!=<span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;是拦截路径，用户已经登录，id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>));<br>            <span class="hljs-type">long</span> <span class="hljs-variable">empId</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>) request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>);<br><br>            BaseContext.setCurrentId(empId);<br><br>            filterChain.doFilter(request,response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>3、在MyMetaObjectHandler中获取id为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zlw.reggie.common;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;<br><span class="hljs-keyword">import</span> org.apache.ibatis.reflection.MetaObject;<br><span class="hljs-keyword">import</span> org.apache.tomcat.jni.Local;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义元数据对象处理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMateObjectandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增时，自动填充</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metaObject</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br><br>        <span class="hljs-comment">//设置创建时间，在实体类中可以看到时间的类型为：LocalDateTime</span><br>        metaObject.setValue(<span class="hljs-string">&quot;createTime&quot;</span>, LocalDateTime.now());<br><br>        <span class="hljs-comment">//设置更新时间</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime.now());<br><br>        <span class="hljs-comment">//设置创建者</span><br>        metaObject.setValue(<span class="hljs-string">&quot;createUser&quot;</span>, BaseContext.getId());<br>        <span class="hljs-comment">//设置更新者</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateUser&quot;</span>, BaseContext.getId());<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新时，自动填充</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metaObject</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        <span class="hljs-comment">//设置更新时间</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateTime&quot;</span>, LocalDateTime.now());<br>        <span class="hljs-comment">//设置更新者</span><br>        metaObject.setValue(<span class="hljs-string">&quot;updateUser&quot;</span>, BaseContext.getId());<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="分类管理"><a href="#分类管理" class="headerlink" title="分类管理"></a>分类管理</h1><h2 id="新增分类"><a href="#新增分类" class="headerlink" title="新增分类"></a>新增分类</h2><p>将分类的基本框架搭建好：</p><p><img src="/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/image-20220722140120670.png" alt="image-20220722140120670"></p><p>搭建好之后，梳理一下执行的过程：</p><p><img src="/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/image-20220722140755401.png" alt="image-20220722140755401"></p><p><strong>新增分类的代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/category&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CategoryController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CategoryService categoryService;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Category category)</span>&#123;<br>        categoryService.save(category);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;新增菜品类成功&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分类的分页管理"><a href="#分类的分页管理" class="headerlink" title="分类的分页管理"></a>分类的分页管理</h2><p>分类的分页与员工管理页面的分页一样，代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span> (<span class="hljs-string">&quot;/page&quot;</span>)<br><span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page, <span class="hljs-type">int</span> pageSize)</span>&#123;<br>    Page&lt;Category&gt; pageInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(page, pageSize);<br><br>    LambdaQueryWrapper&lt;Category&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    queryWrapper.orderByAsc(Category::getSort);<br><br>    categoryService.page(pageInfo,queryWrapper);<br><br>    <span class="hljs-keyword">return</span> R.success(pageInfo);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除分类"><a href="#删除分类" class="headerlink" title="删除分类"></a>删除分类</h2><p>这里面的删除分类，与普通的删除不同，因为分类或套餐里面包含有很多菜品，所以不能直接删除，要判断里面是否包含菜品，如果里面没有菜品则可以正常删除，。但里面如果有菜品，则要进行判断，因此对删除分类要进行完善。</p><p><img src="/2022/07/22/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-day02/image-20220722151107997.png" alt="image-20220722151107997"></p><p><strong>重写删除方法，不能用IService中所提供的方法，代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CategoryServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;CategoryMapper, Category&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CategoryService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DishService dishService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SetmealService setmealService;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>        LambdaQueryWrapper&lt;Dish&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        queryWrapper.eq(Dish::getCategoryId,id);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> dishService.count(queryWrapper);<br>        <span class="hljs-comment">//判断菜品中是否有该类，</span><br>        <span class="hljs-keyword">if</span> (count&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//说明有该菜品，抛出一个业务异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomException</span>(<span class="hljs-string">&quot;菜品中有该分类，不能删除&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//判断套餐中是否有该菜类</span><br>        LambdaQueryWrapper&lt;Setmeal&gt; queryWrapper1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        queryWrapper1.eq(Setmeal::getCategoryId,id);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> setmealService.count(queryWrapper1);<br>        <span class="hljs-comment">//如果都没有，则删除</span><br>        <span class="hljs-keyword">if</span> (count1&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//说明套餐中有该菜品，抛出一个业务异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomException</span>(<span class="hljs-string">&quot;套餐中有该分类，不能删除&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">super</span>.removeById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义业务异常类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义业务异常类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomException</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-built_in">super</span>(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在全局异常捕获中加入捕获自定义业务异常类的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(CustomException.class)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">exceptionHandler</span><span class="hljs-params">(CustomException e)</span>&#123;<br>        <span class="hljs-keyword">return</span> R.error(e.getMessage());<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="修改分类"><a href="#修改分类" class="headerlink" title="修改分类"></a>修改分类</h2><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分类管理的修改功能</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Category category)</span>&#123;<br>        categoryService.updateById(category);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;修改成功&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis面试题</title>
    <link href="/2022/07/21/redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/07/21/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>题</title>
    <link href="/2022/07/15/%E9%A2%98/"/>
    <url>/2022/07/15/%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试官，上午好，我叫张露文，来自辽宁鞍山，现就读于东北大学软件学院，研究生二年级，下面通过两个方面来介绍一下自己，学习方面，在研一的时候获取了学习奖学金，并发表了一篇论文，<strong>考虑防护和隔离的传染病传播建模与分析</strong>，第二篇论文正在投稿中，性格方面，如果要用三个词来形容的话，那就是自信，乐观，有趣，并且向往着稳定的生活。中国移动是我最佳的选择，是值得信赖的大公司，具有广阔的发展平台，如果可以进入中国移动，我将为中国移动贡献一份微薄之力，让更多的人享受中国移动带来的遍历。</p><h2 id="选择一词进行描述"><a href="#选择一词进行描述" class="headerlink" title="选择一词进行描述"></a>选择一词进行描述</h2><p><strong>交通拥堵、富二代炫富、自主创业、投资理财、节能减排</strong></p><ul><li><p><strong>交通拥堵：</strong>先说说为什么选择这个词语，因为真的是亲身体验过呀。但相信我们每个人或多或少的都会经历到交通堵塞，由于一些不规范停车，节假日等等问题。但我经历了一次非常难忘的堵车之旅。刚上大学的时候，想和室友去棋盘山爬山，结果国庆节的时候去，座直达的公交车，这一路简直就是堵堵堵。看的那个地图的路线好多都是红色的，来去路程一共花了8个小时左右的时间，到那已经下午的，不让去上山了，所以到哪买了根烤肠就回来了，哈哈还算有收获把。在去的路上心情还是挺煎熬的，但回来的路上心情确实很愉快的，因为看着车缓慢的移动，看看窗外的风景，何尝不是另一种收获。</p></li><li><p><strong>自主创业</strong>：我本身是非常钦佩自主创业的人的，无论是成功和失败都值得我们学习和尊敬，首先自主创业，需要依靠自己的资本、资源、信息、已经能力，如果自主创业，也就证明了她们有这些方面的能力，并且他们有承担失败的勇气。目前，由于就业形势的压力，学生创业的也有很多，但在创业之前一定要仔细了解本行业的模式，制订计划，沉稳的能力。</p></li></ul><h2 id="为什么要应聘中国移动"><a href="#为什么要应聘中国移动" class="headerlink" title="为什么要应聘中国移动"></a>为什么要应聘中国移动</h2><p>两个方面：</p><ul><li><p>N年前我们可以在任何时间和地点去和像通话的人通话 ，是中国移动完成了这个伟大的梦想。现在我想让更多的人享受中国移动带来的便利。</p></li><li><p>中国移动是全球电信的第一品牌，当我初中接触到手机那一刻时，我就知道 了中国移动，这种值得信赖的大公司会有广阔的发展平台，如果可以进入中国移动，将为移动贡献一份微薄之力。</p></li><li><p>工作待很好也很稳定，适合我这种积极向上，并且自信的人，我想中国移动一定不缺少自信的人，因为中国移动值得自信。</p></li></ul><h2 id="如何管理一个团队"><a href="#如何管理一个团队" class="headerlink" title="如何管理一个团队"></a>如何管理一个团队</h2><ul><li><p>首先要管理好自己，自己要有优良的工作作风，自己都做不好，还让别人怎么信服。</p></li><li><p>我觉得最重要的一点就是团结，成功的秘诀就是从一个人到一群人。</p></li><li><p>善于观察，了解每个人的优缺点，最大的发挥自己的能力，有充分施展的空间，。</p></li><li><p>对事不对人的化解矛盾冲突</p></li></ul><h2 id="怎样和同事相处"><a href="#怎样和同事相处" class="headerlink" title="怎样和同事相处"></a>怎样和同事相处</h2><ul><li><p>互相尊重，多听他人意见和建议</p></li><li><p>真诚相待，自己问心无愧就好，“路遥知马力，日久见人心”</p></li><li><p>自信，轻松自在的交流，正能量，不要带给其他人负能量。</p></li><li><p>多换位思考</p></li></ul><h2 id="同事之间出现矛盾"><a href="#同事之间出现矛盾" class="headerlink" title="同事之间出现矛盾"></a>同事之间出现矛盾</h2><ul><li>首先要理清楚原因，哪方面产生的争执</li><li>先试着站在对方的角度思考，会有不一样的结果</li><li>主动发起沟通</li><li>平常心对待，化解矛盾，不要揪着不放，记性不好点也很好的，</li></ul><h2 id="为什么选择这个岗位"><a href="#为什么选择这个岗位" class="headerlink" title="为什么选择这个岗位"></a>为什么选择这个岗位</h2><h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h2><p>对于实习阶段，我会了解岗位的业务和所需要的技术进行全面统一的学习，并虚心请教前辈们解决问题的方式，积累经验，稳步提升，最后到可以自己独立解决的能力。最后争取有可以转正的机会。</p><h2 id="最大的优点和缺点"><a href="#最大的优点和缺点" class="headerlink" title="最大的优点和缺点"></a>最大的优点和缺点</h2><p><strong>优点：</strong>  合作意识强，可以很快的适应新的环境</p><p><strong>缺点：</strong> 社会经验不足</p><h2 id="你对我们企业了解多少"><a href="#你对我们企业了解多少" class="headerlink" title="你对我们企业了解多少"></a>你对我们企业了解多少</h2>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>国企</category>
      
      <category>中国移动</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>表达式求值</title>
    <link href="/2022/06/23/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2022/06/23/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><p>给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p><p><strong>注意：</strong></p><ul><li>数据保证给定的表达式合法。</li><li>题目保证符号 <code>-</code> 只作为减号出现，不会作为负号出现，例如，<code>-1+2</code>,<code>(2+2)*(-(1+1)+2)</code> 之类表达式均不会出现。</li><li>题目保证表达式中所有数字均为正整数。</li><li>题目保证表达式在中间计算过程以及结果中，均不超过 231−1231−1。</li><li>题目中的整除是指向 00 取整，也就是说对于大于 00 的结果向下取整，例如 5&#x2F;3&#x3D;15&#x2F;3&#x3D;1，对于小于 00 的结果向上取整，例如 5&#x2F;(1−4)&#x3D;−15&#x2F;(1−4)&#x3D;−1。</li><li>C++和Java中的整除默认是向零取整；Python中的整除<code>//</code>默认向下取整，因此Python的<code>eval()</code>函数中的整除也是向下取整，在本题中不能直接使用。</li></ul><p><strong>输入格式</strong></p><p>共一行，为给定表达式。</p><p><strong>输出格式</strong></p><p>共一行，为表达式的结果。</p><p><strong>数据范围</strong></p><p>表达式的长度不超过 105105。</p><p><strong>输入样例：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(2+2)</span>*<span class="hljs-comment">(1+1)</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h2 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h2><p>关键点：设置两个栈：<strong>操作数栈和运算符栈。</strong></p><p>之后通过<strong>4种情况进行判断：</strong></p><p>（1）如果是操作数的话：将数加入到操作数栈种。</p><p>（2）如果是<code>（</code>：直接加入到运算符栈种。</p><p>（3）如果是  <code>）</code>: 将进行计算，直到遇见左括号，就是相当于计算括号中的值。（具体来说就是运算数栈出栈两个数，运算符栈出栈一个运算符，将运算结果入运算数栈。最后将左括号出栈）</p><p>（4）如果是运算符：判断运算符的优先级，分以下两种情况</p><ul><li><p>如果运算符栈顶的优先级大于该运算符，则进行出栈计算，新值入栈，直到运算符栈为空或者优先级大于运算符栈的栈顶元素</p></li><li><p>否则，新运算符直接入栈。</p></li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> Stack&lt;Integer&gt; num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> Stack&lt;Character&gt; op = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-comment">//计算</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eval</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> num.pop();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> num.pop();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> op.pop();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (o==<span class="hljs-string">&#x27;+&#x27;</span>) res = b+a;<br>        <span class="hljs-keyword">if</span> (o==<span class="hljs-string">&#x27;-&#x27;</span>) res = b-a;<br>        <span class="hljs-keyword">if</span> (o==<span class="hljs-string">&#x27;*&#x27;</span>) res = b*a;<br>        <span class="hljs-keyword">if</span> (o==<span class="hljs-string">&#x27;/&#x27;</span>) res = b/a;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-number">2</span>);<br>        map.put(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = i;<br>            <span class="hljs-keyword">if</span> (Character.isDigit(a)) &#123;<br>                <span class="hljs-comment">//因为a取的是一位字符，指的是一位整数，下面这个循环是解决，两位数或多位数的情况：43/567.。</span><br>                <span class="hljs-keyword">while</span> (j &lt; len &amp;&amp; Character.isDigit(s.charAt(j))) x = x * <span class="hljs-number">10</span> + s.charAt(j++) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                <span class="hljs-comment">//将x加入数值栈中</span><br>                num.push(x);<br>                i = j - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//左括号没有优先级，直接入栈</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i)==<span class="hljs-string">&#x27;(&#x27;</span>) op.push(s.charAt(i));<br>            <span class="hljs-comment">//遇到有括号，计算括号里面的数值，也就是遇到左括号时结束。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.charAt(i)==<span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">while</span> (op.peek()!=<span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">eval</span> <span class="hljs-operator">=</span> eval();<br>                    num.push(eval);<br>                &#125;<br>                op.pop();<br>            &#125;<br>            <span class="hljs-comment">//判断入栈运算符的优先级</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (op.size()!=<span class="hljs-number">0</span> &amp;&amp; op.peek()!=<span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; map.get(op.peek())&gt;=map.get(s.charAt(i))) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> eval();<br>                    num.push(e);<br>                &#125;<br>                op.push(s.charAt(i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (op.size()&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> eval();<br>            num.push(e);<br>        &#125;<br>        System.out.println(num.peek());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题-java基础</title>
    <link href="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="常见字符集"><a href="#常见字符集" class="headerlink" title="常见字符集"></a>常见字符集</h1><h2 id="ASII"><a href="#ASII" class="headerlink" title="ASII"></a>ASII</h2><p>美国人发明的数据集，用于输入到电脑中的代码，包括了英文和符号等。</p><p>标准的ASCII使用一个字节存储一个字符，首位是0，总共可以表示128个字符，对美国人来说完全够用。</p><p>但是对于中国人来说，还不够，则中国人也开发了一个自己的字符集，就是GBK</p><h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>汉字占两个字节，英文占一个字节。</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125202941749.png" alt="image-20221125202941749"></p><p><strong>GBK规定个汉字的第一个字节的第一位必须为1</strong></p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125203408796.png" alt="image-20221125203408796"></p><p>因为还有其他国家使用，所以如果其他国家也开发一个自己国家语言的字符集，就会出现好多字符集，当各个国家进行通信的时候就会出现乱码问题。因此国家开发组织就定义了一个标准编码：Unicode</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125203905637.png" alt="image-20221125203905637"></p><p><strong>UTF-8</strong></p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204141153.png" alt="image-20221125204141153"></p><p>编码的时候可以根据汉字占3个字节进行编码，。但是解吗的时候怎么知道是3个字节代表的汉字呢，则下面utf-8提出了编码方式：</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204341276.png" alt="image-20221125204341276"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204623833.png" alt="image-20221125204623833"></p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204642815.png" alt="image-20221125204642815"></p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204648335.png" alt="image-20221125204648335"></p><h2 id="Java代码对字符进行编码和解码"><a href="#Java代码对字符进行编码和解码" class="headerlink" title="Java代码对字符进行编码和解码"></a>Java代码对字符进行编码和解码</h2><p>String提供的方法：</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125205109693.png" alt="image-20221125205109693"></p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125205136562.png" alt="image-20221125205136562"></p><h1 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h1><ul><li>面向过程是把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题</li><li>面向对象开发的程序一般更易维护，易复用，易扩展。</li></ul><h1 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h1><p>​<strong>在程序中定义的引用所指向的具体类型和通过该引用调用的方法在编译时期不能确定，而是在程序运行时期才能确定。由于是程序运行时才确定具体的类，这样不用修改源代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</strong></p><p>多态：同一个方法，通过不同的对象调用产生不同的结果</p><p>多态的三个必要条件：</p><ul><li><p>有继承</p></li><li><p>有重写</p></li><li><p>父类引用指向子类对象</p></li></ul><p><strong>继承链中对象调用方法的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</strong></p><p><strong>注意！！！！：</strong></p><p>​<strong>指向子类的父类引用，由于向上转型了，它只能访问子类中重写父类的方法和属性，而对于父类中不存在的方法，该引用不能调用。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）</strong></p><p><strong>经典的例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(D obj)</span> &#123;  <br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and D&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(A obj)</span> &#123;  <br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and A&quot;</span>);  <br>    &#125;   <br>  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(B obj)</span>&#123;  <br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and B&quot;</span>);  <br>    &#125;  <br>      <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(A obj)</span>&#123;  <br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and A&quot;</span>);  <br>    &#125;   <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&#123;  &#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&#123;  &#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();  <br>        <span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();  <br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();  <br>        <span class="hljs-type">C</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();  <br>        <span class="hljs-type">D</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">D</span>();  <br>          <br>        System.out.println(<span class="hljs-string">&quot;1--&quot;</span> + a1.show(b));  <span class="hljs-comment">//A and A</span><br>        System.out.println(<span class="hljs-string">&quot;2--&quot;</span> + a1.show(c));  <span class="hljs-comment">//A and A</span><br>        System.out.println(<span class="hljs-string">&quot;3--&quot;</span> + a1.show(d));  <span class="hljs-comment">//A and D</span><br>        System.out.println(<span class="hljs-string">&quot;4--&quot;</span> + a2.show(b));  <span class="hljs-comment">//4--B and A .首先a2是A引用，B实例，调用show（B b）方法，此方法在父类A中没有定义，所以B中方法show(B b)不会调用（多态必须父类中已定义该方法），再按优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)，即先查this对象的父类，没有重头再查参数的父类。查找super.show((super)O)时，B中没有，再向上，找到A中show(A a),因此执行。</span><br> <br>        System.out.println(<span class="hljs-string">&quot;5--&quot;</span> + a2.show(c));  <span class="hljs-comment">//同上</span><br>        System.out.println(<span class="hljs-string">&quot;6--&quot;</span> + a2.show(d));  <span class="hljs-comment">//A and D .查找B中没有show(D d)方法，再查A中，有，执行。</span><br>        System.out.println(<span class="hljs-string">&quot;7--&quot;</span> + b.show(b));   <span class="hljs-comment">//B and B</span><br>        System.out.println(<span class="hljs-string">&quot;8--&quot;</span> + b.show(c));  <span class="hljs-comment">//B and B .</span><br>        System.out.println(<span class="hljs-string">&quot;9--&quot;</span> + b.show(d));  <span class="hljs-comment">//A and D      </span><br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h1 id="抽象类和接口的区别？"><a href="#抽象类和接口的区别？" class="headerlink" title="抽象类和接口的区别？"></a>抽象类和接口的区别？</h1><p><strong>抽象类：</strong></p><ul><li>抽象类里面的全部方法，必须让子类全部实现，如果没有全部实现，则该子类也为抽象类，同样的接口也一样，如果子类没有全部实现接口中的方法，则该子类也为抽象类。</li><li>抽象类中可以有普通方法，也可以有抽象方法，而抽象方法的个数可以是0个，也可以是多个。</li><li>子类继承父类，必须重写全部的抽象方法，除非这个类也变成了抽象类。</li></ul><p><strong>接口：</strong></p><ul><li>接口中所有方法都必须是抽象的</li><li>接口中方法定义默认为public abstract类型，成员变量默认为public static final 类型。</li></ul><p><strong>主要区别：</strong></p><ul><li>抽象类可以有构造方法，接口中不能有构造方法。（接口中所有的方法都是抽象的，不存在抽象的构造方法）</li><li>抽象类中可以有普通方法，接口中所有方法都必须是抽象的。</li><li>抽象类中抽象方法的访问类型可以是public，protected，但接口中抽象方法的访问类型只能是public，并且默认为public <a href="https://so.csdn.net/so/search?q=abstract&spm=1001.2101.3001.7020">abstract</a></li><li>抽象类中可以有静态方法（不能有静态抽象方法），接口中不能有静态方法。（因为接口不能被实例化，也就是不能分配内存空间，而static方法在实例化之前就已经分配了内存空间，所以矛盾了。）<strong>静态和抽象不能共存在一个方法上，静态不需要实例就可以运行，而抽象方法没有方法体，运行没有意义，所以不能共存。</strong></li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><p><strong>（1）重载：</strong>发生在同一个类中，方法名相同，参数类型不同、个数不同、顺序不同，返回值和访问修饰符可以不同。<strong>就是同一个方法能够根据输入数据的不同，做出不同的处理</strong></p><p><strong>（2）重写：</strong>发生在运行期，子类对父类的允许访问的方法实现过程进行重写。（抛出异常的范围小于等于父类，访问修饰符范围大于等于父类），其中构造方法不能被重写，⽗类⽅法访问修饰符为 private&#x2F;final&#x2F;static 则⼦类就不能重写该⽅法，但是被 static 修饰的⽅法能够被再次声明  </p><h1 id="JAVA中的泛型"><a href="#JAVA中的泛型" class="headerlink" title="JAVA中的泛型"></a>JAVA中的泛型</h1><p>使用泛型参数，编译器可以对泛型参数进行检测，并通过泛型参数可以指定传入的对象类型，是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。<br>也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，而这种参数类型可以用在类、方法和接口中，</p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//测试一下泛型的经典案例</span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">arrayList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        arrayList.add(<span class="hljs-string">&quot;helloWorld&quot;</span>);<br>        arrayList.add(<span class="hljs-string">&quot;taiziyenezha&quot;</span>);<br>        arrayList.add(<span class="hljs-number">88</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) &#123;<br>            <span class="hljs-comment">//需求：打印每个字符串的长度,就要把对象转成String类型</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) arrayList.get(i);<br>            System.out.println(str.length());<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>由于<code>ArrayList</code>可以存放任意类型的元素。例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，导致取出时强制转换为String类型后，引发了<code>ClassCastException</code>，因此程序崩溃了。</p><p>这显然不是我们所期望的，如果程序有潜在的错误，我们<code>更期望在编译时被告知错误</code>，而不是在运行时报异常。在jdk1.5后，泛型应运而生。让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>arrayList.add(<span class="hljs-string">&quot;helloWorld&quot;</span>);<br>arrayList.add(<span class="hljs-string">&quot;taiziyenezha&quot;</span>);<br>arrayList.add(<span class="hljs-number">88</span>);<span class="hljs-comment">// 在编译阶段，编译器就会报错</span><br></code></pre></td></tr></table></figure><p><strong>这样可以避免了我们类型强转时出现异常。</strong></p><p><strong>使用泛型的好处</strong></p><ul><li>避免了类型强转的麻烦。</li><li>它提供了编译期的<strong>类型安全</strong>，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException。</li></ul><h1 id="JAVA的跨平台"><a href="#JAVA的跨平台" class="headerlink" title="JAVA的跨平台"></a>JAVA的跨平台</h1><p><a href="https://www.jb51.net/article/216499.htm">https://www.jb51.net/article/216499.htm</a></p><p>跨平台，是指java语言编写的程序，<strong>一次编译</strong>后，可以在<strong>多个系统平台上运行</strong>。</p><p>实现跨平台：Java程序是<strong>通过java虚拟机</strong>在系统平台上运行的，只要该系统可以安装相应的java<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>，该系统就可以运行java程序。（注意不是能在所有的平台上运行，关键是该平台是否能安装相应的虚拟机）</p><p>Java跨平台原理：<br>由源文件(.java)—&gt;字节码文件(.class)(二进制文件)—–&gt; 解释—-&gt;Unix,Win,Linux等机器。</p><p><strong>简单的来说</strong>，<br>就是当你需要执行某个Java程序时，会牵扯到JVM。具体就是我们编写的Java源码，编译后会生成一种.class文件，称为字节码文件。而Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码，然后运行。</p><p><strong>如下图</strong></p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/7ae2aead01a946c183a01073915ee9bd.png" alt="在这里插入图片描述"></p><p>由此可知，JAVA的编译和执行与JVM有关，与平台无关。</p><p>而JVM分为很多个系统的版本，如Windows，Linux，macOS等等，都有其对应的JVM。</p><p><strong>因此，</strong><br>如果我们想要编译和执行编写好的Java程序，只需要在不同平台上安装其对应的JVM就行了。</p><p><strong>如下图</strong><br><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/ce87cd35649245a1846f8340bee417c6.png" alt="在这里插入图片描述"></p><h1 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h1><ul><li>包装类不赋值就是null，而基本类型有默认值，不是null。</li><li>包装类可用作泛型，而基本类不可以。</li><li>基本数据类型，如果是局部成员变量存放在Java虚拟机栈中，如果是成员变量存放在堆中，包装类对象属于对象类型存放在堆中。</li><li>相比于对象类型，基本数据类型占用的空间非常小</li></ul><h1 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h1><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer i1 <span class="hljs-operator">=</span> <span class="hljs-number">33</span><span class="hljs-comment">;</span><br>Integer i2 <span class="hljs-operator">=</span> <span class="hljs-number">33</span><span class="hljs-comment">;</span><br>System.out.println(i1 <span class="hljs-operator">=</span><span class="hljs-operator">=</span> i2)<span class="hljs-comment">;// 输出 true</span><br><br>Float i11 <span class="hljs-operator">=</span> <span class="hljs-number">333</span>f<span class="hljs-comment">;</span><br>Float i22 <span class="hljs-operator">=</span> <span class="hljs-number">333</span>f<span class="hljs-comment">;</span><br>System.out.println(i11 <span class="hljs-operator">=</span><span class="hljs-operator">=</span> i22)<span class="hljs-comment">;// 输出 false</span><br><br>Double i3 <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br>Double i4 <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br>System.out.println(i3 <span class="hljs-operator">=</span><span class="hljs-operator">=</span> i4)<span class="hljs-comment">;// 输出 false</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer i1 <span class="hljs-operator">=</span> <span class="hljs-number">40</span><span class="hljs-comment">;</span><br>Integer i2 <span class="hljs-operator">=</span> new Integer(<span class="hljs-number">40</span>)<span class="hljs-comment">;</span><br>System.out.println(i1<span class="hljs-operator">=</span><span class="hljs-operator">=</span>i2)<span class="hljs-comment">;   //输出false</span><br></code></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003103940342.png" alt="image-20221003103940342"></p><h1 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h1><p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p><p>因此，</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><h1 id="为什么浮点数运算会有精度丢失的风险"><a href="#为什么浮点数运算会有精度丢失的风险" class="headerlink" title="为什么浮点数运算会有精度丢失的风险"></a>为什么浮点数运算会有精度丢失的风险</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">由于计算机保存浮点数时是使用二进制进行存储的，而对于一些小数，不能准确的使用二进制存储，<br>因为可能无法消灭小数部分，导致无限循环下去，而又因为超过了其范围，所以就会导致精度丢失。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span><br><span class="hljs-comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span><br><span class="hljs-number">0.2</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.4</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">0.4</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.8</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">0.8</span> * <span class="hljs-number">2</span> = <span class="hljs-number">1.6</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-number">0.6</span> * <span class="hljs-number">2</span> = <span class="hljs-number">1.2</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-number">0.2</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.4</span> -&gt; <span class="hljs-number">0</span>（发生循环）<br>...<br><br></code></pre></td></tr></table></figure><h1 id="解决浮点数运算精度丢失问题"><a href="#解决浮点数运算精度丢失问题" class="headerlink" title="解决浮点数运算精度丢失问题"></a>解决浮点数运算精度丢失问题</h1><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.9&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a.subtract(b);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b.subtract(c);<br><br>System.out.println(x); <span class="hljs-comment">/* 0.1 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.1 */</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* true */</span><br><br></code></pre></td></tr></table></figure><p><strong><code>BigDecimal</code>进行等值比较的时候，要使用compareTo()方法，这是因为 <code>equals()</code> 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 <code>compareTo()</code> 方法比较的时候会忽略精度。</strong></p><blockquote><p>1.0 的 scale 是 1，1 的 scale 是 0，因此 <code>a.equals(b)</code> 的结果是 false。</p></blockquote><p><strong>加减乘除的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.9&quot;</span>);<br>System.out.println(a.add(b));<span class="hljs-comment">// 1.9</span><br>System.out.println(a.subtract(b));<span class="hljs-comment">// 0.1</span><br>System.out.println(a.multiply(b));<span class="hljs-comment">// 0.90</span><br>System.out.println(a.divide(b));<span class="hljs-comment">// 无法除尽，抛出 ArithmeticException 异常</span><br>System.out.println(a.divide(b, <span class="hljs-number">2</span>, RoundingMode.HALF_UP));<span class="hljs-comment">// 1.11</span><br></code></pre></td></tr></table></figure><p><strong>保留几位小数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.255433&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> m.setScale(<span class="hljs-number">3</span>,RoundingMode.HALF_DOWN);<br>System.out.println(n);<span class="hljs-comment">// 1.255</span><br></code></pre></td></tr></table></figure><h1 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h1><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>System.out.println(l + <span class="hljs-number">1</span>); <span class="hljs-comment">// -9223372036854775808</span><br>System.out.println(l + <span class="hljs-number">1</span> == Long.MIN_VALUE); <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</strong></p><blockquote><p> （就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。）</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>不同类型的对象，相互之间经常有一定数量的共同点。将这些共同点定义为一个类，不同类型去继承这个类，</p><p><strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</strong></p><p><strong>注意三点：</strong></p><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</strong></p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><ul><li><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，<strong>也就是说拷贝对象和原对象共用同一个内部对象。</strong>新旧对象还是共用一个内存块。</p><blockquote><p>若是想要彻底的深拷贝，就要保证该对象的所有引用对象的类型都要去实现<code>Cloneable</code>接口，实现<code>clone</code>方法。 </p></blockquote></li><li><p><strong>深拷贝</strong>：是新建一个一模一样的对象，该对象与原对象不共享内存，修改新对象也不会影响原对象。</p></li></ul><p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221129200824038.png" alt="image-20221129200824038"></p><p>obj2是对obj1的浅拷贝，obj3是对obj1的深拷贝</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003135131615.png" alt="image-20221003135131615"></p><p>阅读：<a href="https://blog.csdn.net/crystal_hhj/article/details/119740469">https://blog.csdn.net/crystal_hhj/article/details/119740469</a></p><h1 id="x3D-x3D-和equals-的区别"><a href="#x3D-x3D-和equals-的区别" class="headerlink" title="&#x3D;&#x3D;和equals()的区别"></a>&#x3D;&#x3D;和equals()的区别</h1><p>&#x3D;&#x3D;：对于基本数据类型比较的是值，对于引用类型比较的是两个的地址</p><p>equals()：如果没有重写，则于&#x3D;&#x3D;一样，如果重写了则比较的是内容。</p><h1 id="字符串中intern-方法有什么作用"><a href="#字符串中intern-方法有什么作用" class="headerlink" title="字符串中intern 方法有什么作用?"></a>字符串中intern 方法有什么作用?</h1><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”Java“</span><br><span class="hljs-comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br><span class="hljs-comment">// 会在堆中在单独创建一个字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s3.intern();<br><span class="hljs-comment">// s1 和 s2 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// s3 和 s4 指向的是堆中不同的对象</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// s1 和 s4 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s4); <span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure><h1 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h1><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串</p><p>🐛 修正 ： 我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p><p><strong><code>String</code> 真正不可变有下面几点原因：</strong></p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><h1 id="为什么要将String设置为不可变的"><a href="#为什么要将String设置为不可变的" class="headerlink" title="为什么要将String设置为不可变的"></a>为什么要将String设置为不可变的</h1><p>（1）字符串常量池需要String不可变，因为当创建一个String对象时，若此字符串已经存在常量池中，则不会创建一个新对象，而是引用已经存在的对象，如果允许改变的话，会影响另一个已经存在的对象。</p><p>（2）安全性，string被许多java类用来当作参数，若String可变，将会引起各种安全隐患。</p><p>（3）可以用作HashMap的key，因为通常建议把不可变的对象作为HashMap的key，以可缓存hashCode，对象一旦被创建hashCode的值也就不会改变，下次可以直接使用。</p><h1 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h1><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h1 id="JAVA-IO流"><a href="#JAVA-IO流" class="headerlink" title="JAVA IO流"></a>JAVA IO流</h1><p><strong>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。</strong>数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p><strong>字符流和字节流的使用场景：</strong></p><p>（1）字节流：主要用于处理图像、音频、视频、ppt等。它也可以处理文本文件</p><p>（2）字符流：主要用于处理纯文本的文件。不可以处理音频等文件</p><h1 id="Java-I-x2F-O模型详解"><a href="#Java-I-x2F-O模型详解" class="headerlink" title="Java I&#x2F;O模型详解"></a>Java I&#x2F;O模型详解</h1><p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003215836718.png" alt="image-20221003215836718"></p><p>用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><h1 id="java中三种常见的IO模型"><a href="#java中三种常见的IO模型" class="headerlink" title="java中三种常见的IO模型"></a>java中三种常见的IO模型</h1><p><a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html#autoid-h2-5-0-0">https://www.cnblogs.com/crazymakercircle/p/10225159.html#autoid-h2-5-0-0</a></p><h2 id="BIO（同步阻塞模型）"><a href="#BIO（同步阻塞模型）" class="headerlink" title="BIO（同步阻塞模型）"></a>BIO（同步阻塞模型）</h2><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220126506.png" alt="image-20221003220126506"></p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p><h2 id="NIO（同步非阻塞模型）"><a href="#NIO（同步非阻塞模型）" class="headerlink" title="NIO（同步非阻塞模型）"></a>NIO（同步非阻塞模型）</h2><p>对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220214067.png" alt="image-20221003220214067"></p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>这个时候，<strong>I&#x2F;O 多路复用模型</strong> 就上场了。</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220255525.png" alt="image-20221003220255525"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><h2 id="AIO（异步模型）"><a href="#AIO（异步模型）" class="headerlink" title="AIO（异步模型）"></a>AIO（异步模型）</h2><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220332681.png" alt="image-20221003220332681"></p><p>目前来说 AIO 的应用还不是很广泛。</p><h1 id="为什么Java中只有值传递"><a href="#为什么Java中只有值传递" class="headerlink" title="为什么Java中只有值传递"></a>为什么Java中只有值传递</h1><p><strong>先来介绍一下什么是值传递和引用传递：</strong></p><ul><li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li><li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li></ul><p><strong>案例一</strong></p><p>传递基本类型参数时，是将实参的值拷贝给形参，所以形参值的改变，不会影响实参值的改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    swap(num1, num2);<br>    System.out.println(<span class="hljs-string">&quot;num1 = &quot;</span> + num1);<br>    System.out.println(<span class="hljs-string">&quot;num2 = &quot;</span> + num2);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a;<br>    a = b;<br>    b = temp;<br>    System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + a);<br>    System.out.println(<span class="hljs-string">&quot;b = &quot;</span> + b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">a = 20<br>b = 10<br>num1 = 10<br>num2 = 20<br></code></pre></td></tr></table></figure><p><strong>案例二</strong></p><p>传递引用类型参数1：当传递引用类型时，是将实参中引用类型在堆中的地址拷贝给形参，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>      System.out.println(arr[<span class="hljs-number">0</span>]);<br>      change(arr);<br>      System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>      <span class="hljs-comment">// 将数组的第一个元素变为0</span><br>      array[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1<br>0<br></code></pre></td></tr></table></figure><p>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！</p><p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p><p><strong>案例三</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">xiaoZhang</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小张&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">xiaoLi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小李&quot;</span>);<br>    swap(xiaoZhang, xiaoLi);<br>    System.out.println(<span class="hljs-string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());<br>    System.out.println(<span class="hljs-string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(Person person1, Person person2)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> person1;<br>    person1 = person2;<br>    person2 = temp;<br>    System.out.println(<span class="hljs-string">&quot;person1:&quot;</span> + person1.getName());<br>    System.out.println(<span class="hljs-string">&quot;person2:&quot;</span> + person2.getName());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">person1:小李<br>person2:小张<br>xiaoZhang:小张<br>xiaoLi:小李<br></code></pre></td></tr></table></figure><p><code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p><h1 id="Java反射中的方法"><a href="#Java反射中的方法" class="headerlink" title="Java反射中的方法"></a>Java反射中的方法</h1><h2 id="获取class示例的方法"><a href="#获取class示例的方法" class="headerlink" title="获取class示例的方法"></a>获取class示例的方法</h2><p><strong>1. 知道具体类的情况下可以使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass</span> <span class="hljs-operator">=</span> TargetObject.class;<br></code></pre></td></tr></table></figure><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p><p><strong>2. 通过 <code>Class.forName()</code>传入类的全路径获取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>3. 通过对象实例<code>instance.getClass()</code>获取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TargetObject</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetObject</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass2</span> <span class="hljs-operator">=</span> o.getClass();<br></code></pre></td></tr></table></figure><p><strong>4. 通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="反射中的方法"><a href="#反射中的方法" class="headerlink" title="反射中的方法"></a>反射中的方法</h2><p><strong>获取运行时类的方法结构</strong></p><ul><li><code>getMethods()</code>:获取当前运行时类及其所有父类中声明为public权限的方法</li><li><code>getDeclaredMethods()</code>:获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</li><li><code>getAnnotations()</code>：获取方法声明的注解</li><li><code>getModifiers()</code>：获取方法权限修饰符</li><li><code>getReturnType().getName()</code>：获取方法返回值类型</li><li><code>getName()</code>：获取方法名</li><li><code>public Class&lt;?&gt;[] getParameterTypes()</code>:取得全部的参数</li><li><code>public Class&lt;?&gt;[] getExceptionTypes()</code>:取得异常信息</li></ul><p><strong>获取当前运行时类的属性结构</strong></p><ul><li><code>getFields()</code>:获取当前运行时类及其父类中声明为public访问权限的属性</li><li><code>getDeclaredFields()</code>:获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</li><li><code>public int getModifiers()</code>: 以整数形式返回此Field的修饰符</li><li><code>public Class&lt;?&gt; getType()</code>: 得到Field的属性类型</li><li><code>public String getName()</code>: 返回Field的名称。</li></ul><p><strong>获取构造器结构</strong></p><ul><li>getConstructors():获取当前运行时类中声明为public的构造器</li><li>getDeclaredConstructors():获取当前运行时类中声明的所有的构造器</li></ul><p><code>getSuperclass();</code>：获取运行时类的父类</p><p><code>getGenericSuperclass()</code>：获取运行时带泛型的父类</p><p><strong>获取运行时类的带泛型的父类的泛型(重点)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    获取运行时类的带泛型的父类的泛型</span><br><span class="hljs-comment">    代码：逻辑性代码  vs 功能性代码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><br>        <span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> clazz.getGenericSuperclass();<br>        <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">paramType</span> <span class="hljs-operator">=</span> (ParameterizedType) genericSuperclass;<br>        <span class="hljs-comment">//获取泛型类型</span><br>        Type[] actualTypeArguments = paramType.getActualTypeArguments();<br><span class="hljs-comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span><br>        System.out.println(((Class)actualTypeArguments[<span class="hljs-number">0</span>]).getName());<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>如何操作运行时类中的指定的属性 – 需要掌握</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    如何操作运行时类中的指定的属性 -- 需要掌握</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testField1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><br>        <span class="hljs-comment">//创建运行时类的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) clazz.newInstance();<br><br>        <span class="hljs-comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><br>        <span class="hljs-comment">//2.保证当前属性是可访问的</span><br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//3.获取、设置指定对象的此属性值</span><br>        name.set(p,<span class="hljs-string">&quot;Tom&quot;</span>);<br><br>        System.out.println(name.get(p));<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>如何操作运行时类中的指定的方法 – 需要掌握</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    如何操作运行时类中的指定的方法 -- 需要掌握</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><br>        <span class="hljs-comment">//创建运行时类的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) clazz.newInstance();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.获取指定的某个方法</span><br><span class="hljs-comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;show&quot;</span>, String.class);<br>        <span class="hljs-comment">//2.保证当前方法是可访问的</span><br>        show.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span><br><span class="hljs-comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> show.invoke(p,<span class="hljs-string">&quot;CHN&quot;</span>); <span class="hljs-comment">//String nation = p.show(&quot;CHN&quot;);</span><br>        System.out.println(returnValue);<br><br>        System.out.println(<span class="hljs-string">&quot;*************如何调用静态方法*****************&quot;</span>);<br><br>        <span class="hljs-comment">// private static void showDesc()</span><br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">showDesc</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;showDesc&quot;</span>);<br>        showDesc.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//如果调用的运行时类中的方法没有返回值，则此invoke()返回null</span><br><span class="hljs-comment">//        Object returnVal = showDesc.invoke(null);</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnVal</span> <span class="hljs-operator">=</span> showDesc.invoke(Person.class);<br>        System.out.println(returnVal);<span class="hljs-comment">//null</span><br><br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>如何调用运行时类中的指定的构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><br>        <span class="hljs-comment">//private Person(String name)</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.获取指定的构造器</span><br><span class="hljs-comment">        getDeclaredConstructor():参数：指明构造器的参数列表</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(String.class);<br><br>        <span class="hljs-comment">//2.保证此构造器是可访问的</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">//3.调用此构造器创建运行时类的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> (Person) constructor.newInstance(<span class="hljs-string">&quot;Tom&quot;</span>);<br>        System.out.println(per);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h2><p>JDBC中的加载数据库驱动程序，Spring框架中加载bean对象，以及态代理，这些都使用到反射，因为我们要想理解一些框架的底层原理，反射是我们必须要掌握的</p><h1 id="Java-8-的新特性"><a href="#Java-8-的新特性" class="headerlink" title="Java 8 的新特性"></a>Java 8 的新特性</h1><h2 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h2><blockquote><p>概念：一个接口中的抽象方法只有一个，那么这个接口就是一个函数式接口。</p></blockquote><p>通过注解检测一个接口是否是函数式接口：<code>@FunctionallInterface</code></p><p>这是lambda表达式使用的前提。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><blockquote><p>lambda表达式是一个匿名函数，java 8允许把函数作为参数进行传递进方法中，（前提这个函数是函数式接口）</p></blockquote><h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>在对数据进行操作的时候，认为该数据一定有其他线程对它进行修改，因此在获取数据的时候会加锁，确保数据不会被其他线程修改，常见的使用悲观锁的机制为：<code>sychronized</code>和<code>lock</code></p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>在操作数据的时候 ，认为该数据不会被其他线程所修改，所以不会加锁，<strong>而是在更新的时候判断数据有没有被其他线程更新</strong>，如果数据没有被更新则成功写入，否则进行重试或抛出错误。常见的乐观锁是<code>CAS</code>和<code>版本控制</code></p><p><strong>CAS介绍：</strong></p><ul><li>CAS算法涉及到3个操作数：1、需要读写的内存值V；2、进行比较的值A；3、要写入的新值B。</li><li>当且仅当V的值等于A的值，CAS通过原子方式用B来更新V的值（<strong>比较+更新</strong>是一个原子操作）。否则不会执行。</li></ul><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220716231720069.png" alt="image-20220716231720069"></p><p><strong>CAS存在的问题：</strong></p><ul><li><p><strong>ABA问题</strong>：一个线程把数据A变成了B，然后又重新变成了A，此时另一个线程读取该数据的时候，发现A没有变化，就误认为是原来的那个A，但是此时A的一些属性或状态已经发生过变化。</p><blockquote><p>解决办法：可以增加版本号（AtomicStampedReference对象），内存值每次修改后，版本号+1。<a href="https://blog.csdn.net/weixin_42671172/article/details/108340791%E3%80%82%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8AtomicMarkableReference%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%88%A4%E6%96%AD%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4%E3%80%82">https://blog.csdn.net/weixin_42671172/article/details/108340791。或者使用AtomicMarkableReference对象，判断修改状态是否一致。</a></p></blockquote></li><li><p><strong>循环时间长开销大问题：</strong> CAS如果长时间不成功，就会导致一直自旋，给CPU带来很大的消耗。</p></li><li><p><strong>只能保证一个共享变量的原子操作：</strong> 对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p></li></ul><p><strong>两个锁适用的场景：</strong></p><ul><li>悲观锁<strong>适合写多的操作</strong>，先加锁可以确保数据写操作时的准确性</li><li>乐观锁<strong>适合读多的操作</strong>，不加锁的特点能够使读操作的性能得到提升</li></ul><h2 id="自旋锁和适应性自旋锁"><a href="#自旋锁和适应性自旋锁" class="headerlink" title="自旋锁和适应性自旋锁"></a>自旋锁和适应性自旋锁</h2><p><strong>自旋锁：</strong>就是让后面请求锁的线程不放弃CPU的时间，进行自旋等待，等前面的线程释放了锁，当前线程就可以获取锁了，这种省略了CPU对线程状态的转变，避免切换线程的开销。</p><pre><code class="hljs">因为唤醒和阻塞一个Java线程需要操作系统切换CPU的状态来完成。如果同步资源的锁定时间过短，为了这一小段的时间切换线程，线程挂起和恢复会让系统得不偿失。如果让两个或两个以上的线程同时并发执行，我们可以让后面那个请求锁的线程不放弃CPU执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</code></pre><p><strong>自旋锁执行流程：</strong><br>某个线程尝试获取同步资源锁失败，资源被占用—&gt;自旋锁—&gt;不放弃CPU时间片，通过自旋进行等待—&gt;再次尝试获取锁，获取成功—&gt;获取同步资源。<br><strong>非自旋锁的执行流程：</strong><br>某个线程尝试获取同步资源锁失败，资源被占用—&gt;非自旋锁—&gt;CPU切换状态,使当前线程进行休眠—&gt;CPU切换线程执行其他操作—&gt;占用同步资源的线程释放了的锁—&gt;恢复现场—&gt;再次尝试获取锁。</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/other-bukfsdjavassmtjstd-be0964a8-856a-45c9-ab75-ce9505c2e237.png" alt="img"></p><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>在说sychronized优化锁之前了解一下Java对象头，</p><p>对象在内存中的布局分为三块区域：对象头，实例数据和对齐填充。</p><p>对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。</p><p><strong>MarkWord</strong>：用于存储对象自身的运行时数据，如 HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等。</p><p><strong>类型指针：</strong>虚拟机通过这个指针确定该对象是哪个类的实例。</p><p><strong>对象头的长度：</strong></p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32&#x2F;64bit</td><td>MarkWord</td><td>存储对象的hashCode或锁信息等</td></tr><tr><td>32&#x2F;64bit</td><td>Class Metadada Address</td><td>存储对象类型数据的指针</td></tr><tr><td>32&#x2F;64bit</td><td>Array Length</td><td>数组的长度(如果当前对象是数组)</td></tr></tbody></table><p>****锁升级功能主要是依赖Mark Word中**同步锁标志位**和**是否偏向锁标志位**来实现的****。</p><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221128161846036.png" alt="image-20221128161846036"></p><h2 id="Sychronized优化锁"><a href="#Sychronized优化锁" class="headerlink" title="Sychronized优化锁"></a>Sychronized优化锁</h2><p>级别从低到高依次是：</p><ol><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><p>锁可以升级，但不能降级。即：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁是单向的。</p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><table><thead><tr><th>25bit</th><th>4bit</th><th>1bit(是否是偏向锁)</th><th>2bit(锁标志位)</th></tr></thead><tbody><tr><td>对象的hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table><p>无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一资源，但同时<strong>只能有一个线程</strong>修改成功。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><table><thead><tr><th>23bit</th><th>2bit</th><th>4bit</th><th>1bit</th><th>2bit</th></tr></thead><tbody><tr><td>线程ID</td><td>epoch</td><td>对象分代年龄</td><td>1</td><td>01</td></tr></tbody></table><p><strong>含义</strong></p><p>当线程A第一次竞争到锁的时候，通过操作修改MarkWord中的偏向线程ID，锁变为偏向模式，如果不存在其他线程的竞争，那么持有偏向锁的线程将永远不需要进行同步（不需要反复的获得锁和释放锁消耗资源）</p><p><strong>主要作用</strong></p><p>不存在其他线程竞争的情况下，不需要反复的获得和释放锁，减少性能的消耗</p><p><strong>场景</strong></p><p>有且只有一个线程访问的情况</p><p><strong>注意，偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</strong></p><p>当有其他线程进行竞争的时候，才会发生释放锁，检查锁的偏向线程 D与当前线程ID是否一致，如果一致直接进入同步。</p><p><strong>如果不等</strong>，表示发生了竞争，锁已经不是总是偏向于同一个线程了，这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新线程的ID，</p><p><strong>竞争成功</strong>，表示之前的线程不存在了，MarkWord里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁:<br><strong>竞争失败</strong>，这时候可能需要升级变为轻量级锁，才能保证线程问公平竞争锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>如果线程B竞争线程A失败了，则将偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。</strong></p><p><strong>含义</strong></p><p>多线程竞争，但是任一时刻最多只有一个线程竞争（也就是两个线程在竞争同一个资源）</p><p><strong>场景</strong></p><p>有两个线程来交替访问进行竞争</p><p>**主要目的:**在没有多线程竞争的前提下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗，说白了先自旋，不行才升级阻塞</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>如果自旋多次，则升级为重量级锁。<strong>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</strong></p><p><strong>含义</strong></p><p>直接到操作系统级别，使用monitor管程</p><p><strong>场景</strong></p><p>多个线程来访问竞争</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>首先要明确一点是引入这些锁是为了提高获取锁的效率, 要明白每种锁的使用场景, 比如<strong>偏向锁适合一个线程对一个锁的多次获取的情况</strong>; <strong>轻量级锁适合锁执行体比较简单(即减少锁粒度或时间), 自旋一会儿就可以成功获取锁的情况.</strong></p>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板2-数据结构</title>
    <link href="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><strong>使用数组来进行单链表的操作、</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220620124102711.png" alt="image-20220620124102711"></p><p><strong>模板：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> e[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];  <span class="hljs-comment">//e[i]:下标为i的节点的值</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> ne[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];  <span class="hljs-comment">//ne[i]:下标为i的节点的下一个节点</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> idx;  <span class="hljs-comment">//表示当前用到了哪个节点</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> head;<span class="hljs-comment">//头节点</span><br><br>   <span class="hljs-comment">//初始化</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>       head = -<span class="hljs-number">1</span>;<br>       idx = <span class="hljs-number">0</span>;<br>   &#125;<br><br><br>   <span class="hljs-comment">//插入头节点</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHead</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>       e[idx] = a;<br>       ne[idx] = head;<br>       head = idx;<br>       idx++;<br>   &#125;<br><br>   <span class="hljs-comment">//将a插入到下标是k节点的后面</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> a)</span>&#123;<br>       e[idx] = a;<br>       ne[idx] = ne[k];<br>       ne[k] = idx;<br>       idx++;<br>       <br>   &#125;<br><br>   <span class="hljs-comment">//删除下标为k的下一个节点</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>       ne[k] = ne[ne[k]];<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220620142433328.png" alt="image-20220620142433328"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> e[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];  <span class="hljs-comment">//e[i]:下标为i的节点的值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> ne[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];  <span class="hljs-comment">//ne[i]:下标为i的节点的下一个节点</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> idx;  <span class="hljs-comment">//表示当前用到了哪个节点</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> head;<span class="hljs-comment">//头节点</span><br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        head = -<span class="hljs-number">1</span>;<br>        idx = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//插入头节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHead</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>        e[idx] = a;<br>        ne[idx] = head;<br>        head = idx;<br>        idx++;<br>    &#125;<br><br>    <span class="hljs-comment">//将a插入到下标是k节点的后面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> a)</span>&#123;<br>        e[idx] = a;<br>        ne[idx] = ne[k];<br>        ne[k] = idx;<br>        idx++;<br>    &#125;<br><br>    <span class="hljs-comment">//删除下标为k的下一个节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>        ne[k] = ne[ne[k]];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out)));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine()) ;<span class="hljs-comment">//操作次数</span><br>        init();<br>        <span class="hljs-keyword">while</span> (n--&gt;<span class="hljs-number">0</span>)&#123;<br>            String s[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> s[<span class="hljs-number">0</span>].charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (p==<span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>                addHead(a);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (k==<span class="hljs-number">0</span>) head = ne[head];<br>                <span class="hljs-keyword">else</span> remove(k-<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">2</span>]);<br>                add(k-<span class="hljs-number">1</span>,a);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> head;i!=-<span class="hljs-number">1</span>;i=ne[i])&#123;<br>            pw.print(e[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        pw.flush();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><strong>模板;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//0:表示头节点，1:表示尾节点</span><br>        r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//左端点的右边是1</span><br>        l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//右端点的左边是0</span><br>        idx = <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">//在第k位数的面右边添加节点</span><br>    <span class="hljs-comment">//在第k位数的左边添加，也可以用这个，(l[k],a),变成了，在l[k]的右边添加节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> a)</span>&#123;<br>        e[idx] = a;<br>        l[idx] = k;<br>        r[idx] = r[k];<br>        l[r[k]] = idx;<br>        r[k] = idx;<br>        idx++;<br>    &#125;<br>    <span class="hljs-comment">//删除第k个插入的数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>        l[r[k]] = l[k];<br>        r[l[k]] = r[k];<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220620161955157.png" alt="image-20220620161955157"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> e[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> l[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> r[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> idx;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//0:表示头节点，1:表示尾节点</span><br>        r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//左端点的右边是1</span><br>        l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//右端点的左边是0</span><br>        idx = <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">//在第k位数的面右边添加节点</span><br>    <span class="hljs-comment">//在第k位数的左边添加，也可以用这个，(l[k],a),变成了，在l[k]的右边添加节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> a)</span>&#123;<br>        e[idx] = a;<br>        l[idx] = k;<br>        r[idx] = r[k];<br>        l[r[k]] = idx;<br>        r[k] = idx;<br>        idx++;<br>    &#125;<br>    <span class="hljs-comment">//删除第k个插入的数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>        l[r[k]] = l[k];<br>        r[l[k]] = r[k];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out)));<br>        init();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine());<br>        <span class="hljs-keyword">while</span> (n--&gt;<span class="hljs-number">0</span>)&#123;<br>            String s[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> s[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (op.equals(<span class="hljs-string">&quot;D&quot;</span>))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>                delete(k+<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op.equals(<span class="hljs-string">&quot;IL&quot;</span>))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">2</span>]);<br>                add(l[k+<span class="hljs-number">1</span>],a);  <span class="hljs-comment">//因为初始化的时候，加了两个点，所以，第k个数的下标为 ：k+2-1=k+1</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op.equals(<span class="hljs-string">&quot;IR&quot;</span>))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">2</span>]);<br>                add(k+<span class="hljs-number">1</span>,a);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op.equals(<span class="hljs-string">&quot;L&quot;</span>))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>                add(<span class="hljs-number">0</span>,a);<span class="hljs-comment">//也就是相当于头节点的右端</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op.equals(<span class="hljs-string">&quot;R&quot;</span>))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>                add(l[<span class="hljs-number">1</span>],a);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r[<span class="hljs-number">0</span>];i!=<span class="hljs-number">1</span>;i=r[i])&#123;<br>            System.out.print(e[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><strong>数组模拟栈的插入，弹出，是否为空，查询栈顶元素、</strong></p><p><strong>模板：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//在栈中添加元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    a[++t] = x;<br>&#125;<br><span class="hljs-comment">//弹出栈顶的元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span> (t&gt;<span class="hljs-number">0</span>) &#123;<br>        --t;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//判断栈是否为空</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span> (t==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;YES&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NO&quot;</span>;<br>&#125;<br><span class="hljs-comment">//查询栈顶元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> a[t];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>表达式求值也使用了栈的数据结构，就是给出一个字符串的表达式，求出计算结果，详细的请见，表达式求值那个文章。</strong></p><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p><strong>运用的场景：</strong></p><ul><li>给定一个序列，求在这个序列中，每个数的左边（或右边），离它最近的（比它大或小）的数在什么地方。</li></ul><p><strong>模板为“：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>    <span class="hljs-comment">//如果栈不为空，并且栈顶元素大于目前遍历到的元素，则删除栈顶</span><br>    <span class="hljs-keyword">while</span> (tt!=<span class="hljs-number">0</span> &amp;&amp; a[tt]&gt;=t) tt--;<br>    <span class="hljs-comment">//如果栈不为空，说明在栈中找到了比该元素小的元素，进行输出</span><br>    <span class="hljs-keyword">if</span> (tt!=<span class="hljs-number">0</span>) System.out.print(a[tt]+<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-comment">//如果最后栈为空，说明之前没有比它小数，输出-1</span><br>    <span class="hljs-keyword">else</span> System.out.print(-<span class="hljs-number">1</span>+<span class="hljs-string">&quot; &quot;</span>);<br>    a[++tt] = t;<br>&#125;<br><span class="hljs-comment">//该元素右边离它最近比它大的数</span><br>Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> nums1.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> nums2.length;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len2-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums2[i];<br><span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peek()&lt;=t) deque.pop();<br><span class="hljs-keyword">if</span> (!deque.isEmpty()) &#123;<br>map.put(t,deque.peek());<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>map.put(t,-<span class="hljs-number">1</span>);<br>&#125;<br>deque.push(t);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220620192928874.png" alt="image-20220620192928874"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-comment">//如果栈不为空，并且栈顶元素大于目前遍历到的元素，则删除栈顶</span><br>            <span class="hljs-keyword">while</span> (tt!=<span class="hljs-number">0</span> &amp;&amp; a[tt]&gt;=t)&#123;<br>                tt--;<br>            &#125;<br>            <span class="hljs-comment">//如果栈不为空，说明在栈中找到了比该元素小的元素，进行输出</span><br>            <span class="hljs-keyword">if</span> (tt!=<span class="hljs-number">0</span>) System.out.print(a[tt]+<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-comment">//如果最后栈为空，说明之前没有比它小数，输出-1</span><br>            <span class="hljs-keyword">else</span> System.out.print(-<span class="hljs-number">1</span>+<span class="hljs-string">&quot; &quot;</span>);<br>            a[++tt] = t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>数组模拟队列</strong></p><p><strong>模板：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-type">int</span> <span class="hljs-variable">hh</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,tt = -<span class="hljs-number">1</span>;<br><span class="hljs-comment">//队尾插入</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>       q[++tt] = a;<br>   &#125;<br>   <span class="hljs-comment">//队头弹出</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>       hh++;<br>   &#125;<br>   <span class="hljs-comment">//判断是否为空</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">if</span> (hh&lt;=tt) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NO&quot;</span>;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;YES&quot;</span>;<br>   &#125;<br>   <span class="hljs-comment">//查询队头元素</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">query</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> q[hh];<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p><strong>应用场景</strong></p><ul><li>求滑动窗口里面的最大值或最小值。</li></ul><p><strong>最大值和最小值分开来做，两个for循环搞定。步骤为：</strong></p><ul><li>解决队首已经出窗口的问题;</li><li>解决队尾与当前元素a[i]不满足单调性的问题;</li><li>将当前元素下标加入队尾;</li><li>如果满足条件则输出结果;</li></ul><p><strong>模板”：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">hh</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-type">int</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">//最小值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-comment">//解决队首已经出窗口的问题</span><br>    <span class="hljs-keyword">if</span> (hh&lt;=tt &amp;&amp; i-q+<span class="hljs-number">1</span>&gt;queue[hh]) hh++;<br>    <span class="hljs-comment">//解决队尾与当前元素a[i]不满足单调性的问题，也就是要插入的元素是否小于队顶元素，如果小于，则删除队顶元素</span><br><span class="hljs-keyword">while</span> (hh&lt;=tt &amp;&amp; a[queue[tt]]&gt;=a[i]) tt--;<br>    <span class="hljs-comment">//将当前元素下标加入队尾</span><br>    queue[++tt] = i;<br>    <span class="hljs-comment">//如果满足条件则输出结果：i 必须满足滑动窗口的条件</span><br>    <span class="hljs-keyword">if</span> (i&gt;=q-<span class="hljs-number">1</span>) pw.print(a[queue[hh]]+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>pw.println();<br><br><span class="hljs-comment">//最大值</span><br>hh = <span class="hljs-number">0</span>;tt = -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span> (hh&lt;=tt &amp;&amp; i-q+<span class="hljs-number">1</span>&gt;queue[hh]) hh++;<br><span class="hljs-keyword">while</span> (hh&lt;=tt &amp;&amp; a[queue[tt]] &lt;= a[i]) tt--;<br>    queue[++tt] = i;<br>    <span class="hljs-keyword">if</span> (i&gt;=q-<span class="hljs-number">1</span>) pw.print(a[queue[hh]]+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><p>给定一个大小为 n≤10的6次幂的数组。有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 k 个数字。每次滑动窗口向右移动一个位置。求滑动窗口中的最小值和最大值：</p><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> -<span class="hljs-number">1</span> -<span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-1</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> 3 3<br>3 3 5 5 6 7<br></code></pre></td></tr></table></figure><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> queue[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out)));<br>        String s[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>        String ss[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            a[i] = Integer.parseInt(ss[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hh</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-type">int</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (hh&lt;=tt &amp;&amp; i-q+<span class="hljs-number">1</span>&gt;queue[hh])&#123;<br>                hh++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (hh&lt;=tt &amp;&amp; a[queue[tt]]&gt;=a[i]) tt--;<br>            queue[++tt] = i;<br>            <span class="hljs-keyword">if</span> (i&gt;=q-<span class="hljs-number">1</span>) pw.print(a[queue[hh]]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        pw.println();<br>        <span class="hljs-comment">//最大值</span><br>        hh = <span class="hljs-number">0</span>;tt = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (hh&lt;=tt &amp;&amp; i-q+<span class="hljs-number">1</span>&gt;queue[hh])&#123;<br>                hh++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (hh&lt;=tt &amp;&amp; a[queue[tt]] &lt;= a[i]) tt--;<br>            queue[++tt] = i;<br>            <span class="hljs-keyword">if</span> (i&gt;=q-<span class="hljs-number">1</span>) pw.print(a[queue[hh]]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        pw.flush();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p><strong>没弄懂，，背就完了</strong></p><p><strong>模板：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//模式串s，模板串p </span><br><span class="hljs-comment">//next数组</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> , j = <span class="hljs-number">0</span>; i  &lt;= pn ; i ++ )&#123;<br>     <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; p[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br>     <span class="hljs-keyword">if</span>(p[i] == p[j+<span class="hljs-number">1</span>]) j ++ ;<br>     ne[i] = j;<br> &#125;<br><br> <span class="hljs-comment">//匹配过程</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ,j = <span class="hljs-number">0</span> ; i &lt;= sm ; i ++ )&#123;<br>     <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br>     <span class="hljs-keyword">if</span>(s[i] == p[j+<span class="hljs-number">1</span>]) j++;<br>     <span class="hljs-keyword">if</span>(j == pn)&#123;<br>         pw.write((i - pn) + <span class="hljs-string">&quot; &quot;</span>);<br>         j = ne[j];<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220621141110784.png" alt="image-20220621141110784"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> ne[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> s[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[M];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> p[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out)));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pn</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine()); <span class="hljs-comment">//短</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> br.readLine();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=pn;i++)&#123;<br>            p[i] = pp.charAt(i-<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine()); <span class="hljs-comment">//长</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> br.readLine();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=sm;i++)&#123;<br>            s[i] = ss.charAt(i-<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>       <span class="hljs-comment">//next数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> , j = <span class="hljs-number">0</span>; i  &lt;= pn ; i ++ )&#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; p[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br>            <span class="hljs-keyword">if</span>(p[i] == p[j+<span class="hljs-number">1</span>]) j ++ ;<br>            ne[i] = j;<br>        &#125;<br><br><br>        <span class="hljs-comment">//匹配过程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ,j = <span class="hljs-number">0</span> ; i &lt;= sm ; i ++ )&#123;<br>            <span class="hljs-comment">//判断j是不是大于0，小于=0表示还没有前缀和后缀相等</span><br>            <span class="hljs-comment">//判断长的数组一个一个遍历比较，看看短的数组，如果不相等就让j = 上一个数的缀长度</span><br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != p[j+<span class="hljs-number">1</span>]) j = ne[j];<br>            <span class="hljs-comment">//如果相等就让j++；继续进行下一个数的比较</span><br>            <span class="hljs-keyword">if</span>(s[i] == p[j+<span class="hljs-number">1</span>]) j++;<br>            <span class="hljs-comment">//如果相等的数等于短的数组的长度，就说明该输出了</span><br>            <span class="hljs-keyword">if</span>(j == pn)&#123;<br>                pw.write((i - pn) + <span class="hljs-string">&quot; &quot;</span>);<br>                <span class="hljs-comment">//输出之后，要继续往下面遍历对比，所以让j=上一个数的缀长度，</span><br>                <span class="hljs-comment">//因为有前缀和后缀相等的部分可以重复使，并且相同的位置不止一个</span><br>                j = ne[j];<br>            &#125;<br>        &#125;<br>        pw.flush();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p><strong>Trie树又称字典树、单词查找树。是一种能够高效存储和查找字符串集合的数据结构。</strong></p><p><strong>存储字符串：</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220624123845474.png" alt="image-20220624123845474"></p><p><strong>Trie树的代码具体分析：</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220624123940608.png" alt="image-20220624123940608"></p><p><strong>模板代码“：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10010</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> son[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][<span class="hljs-number">26</span>];<span class="hljs-comment">//当前节点儿子</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> cnt[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];  <span class="hljs-comment">//cnt[p]：以p为结尾的字符串的个数</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//当前节点</span><br>   <span class="hljs-comment">//插入</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String s)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//指向当前的节点</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">//将字母转化为数字</span><br>           <span class="hljs-keyword">if</span> (son[p][u]==<span class="hljs-number">0</span>) son[p][u] = ++idx; <span class="hljs-comment">//节点不存在的时候，创建该节点，值为下一个节点的位置</span><br>           p = son[p][u]; <span class="hljs-comment">//p指向下一个节点</span><br>       &#125;<br>       cnt[p]++;<span class="hljs-comment">//结束的标记，记录以此节点结束的字符串个数</span><br>   &#125;<br>   <span class="hljs-comment">//询问</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String s)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>           <span class="hljs-keyword">if</span> (son[p][u]==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//如果为0 说明该节点不存在，直接输出0</span><br>               System.out.println(<span class="hljs-number">0</span>);<br>               <span class="hljs-keyword">return</span>;<br>           &#125;<br>           p = son[p][u];  <br>       &#125;<br>       System.out.println(cnt[p]); <span class="hljs-comment">//输出字符串出现的次数</span><br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>例题;</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220624124555972.png" alt="image-20220624124555972"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">10010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> son[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> cnt[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//插入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (son[p][u]==<span class="hljs-number">0</span>) son[p][u] = ++idx;<br>            p = son[p][u];<br>        &#125;<br>        cnt[p]++;<br>    &#125;<br>    <span class="hljs-comment">//询问</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> s.charAt(i)-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (son[p][u]==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            p = son[p][u];<br>        &#125;<br>        System.out.println(cnt[p]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine());<br>        <span class="hljs-keyword">while</span> (n--&gt;<span class="hljs-number">0</span>)&#123;<br>            String p[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;I&quot;</span>)) insert(p[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;Q&quot;</span>)) &#123;<br>                query(p[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><strong><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220624140056851.png" alt="image-20220624140056851"></strong></p><p>在上述的问题中，问题2的时间复杂度较高，因为遍历集合编号，只要是和数的高度成正比的，因此每次遍历需要很多的时间复杂度，因此可以进行优化。</p><p><strong>路径压缩优化：</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220624140553282.png" alt="image-20220624140553282"></p><p><strong>代码模板：</strong></p><p><strong>一：朴素并查集</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> p[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点   find函数重要！！！</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x]!=x) p[x] = find(p[x]);  <span class="hljs-comment">//将x的父亲置为x父亲的祖先节点,实现路径的压缩</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span>  <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;n;i++)&#123; p[i] = i;&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[find(a)] = find(b);<br></code></pre></td></tr></table></figure><p><strong>二：维护集合里面元素的个数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> p[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> size[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br><span class="hljs-comment">// 返回x的祖宗节点   find函数重要！！！</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x]!=x) p[x] = find(p[x]);  <span class="hljs-comment">//将x的父亲置为x父亲的祖先节点,实现路径的压缩</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span>  <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>p[i] = i;<br>size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br><span class="hljs-keyword">if</span>(find(a)!=find(b)) size[find(b)] += size[find(a)];<br>p[find(a)] = find(b);<br></code></pre></td></tr></table></figure><p><strong>连通块：如果可以从A走到B。并且B也可以走到A，就说明A和B在同一个连通块当中的。</strong></p><p><strong>三：维护到根节点距离的并查集</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> p[N], d[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x)<br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> find(p[x]);<br>            d[x] += d[p[x]];<br>            p[x] = u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[find(a)] = find(b);<br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220715160700613.png" alt="image-20220715160700613"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> p[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x]!=x) p[x] = find(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out)));<br>        String s[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span>  <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            p[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (m--&gt;<span class="hljs-number">0</span>)&#123;<br>            String ss[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">if</span> (ss[<span class="hljs-number">0</span>].equals(<span class="hljs-string">&quot;M&quot;</span>))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(ss[<span class="hljs-number">1</span>]);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(ss[<span class="hljs-number">2</span>]);<br>                p[find(a)] = find(b);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(ss[<span class="hljs-number">1</span>]);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(ss[<span class="hljs-number">2</span>]);<br>                <span class="hljs-keyword">if</span> (find(a)==find(b)) pw.println(<span class="hljs-string">&quot;Yes&quot;</span>);<br>                <span class="hljs-keyword">else</span> pw.println(<span class="hljs-string">&quot;No&quot;</span>);<br>            &#125;<br>        &#125;<br>        pw.flush();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题2：连通块中点的数量</strong></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220715161035681.png" alt="image-20220715161035681"></p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> p[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> size[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x]!=x) p[x] = find(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            p[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (m--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> scanner.next();<br>            <span class="hljs-keyword">if</span> (ss.equals(<span class="hljs-string">&quot;C&quot;</span>)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>                <span class="hljs-keyword">if</span> (find(a)==find(b)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    size[find(b)] = size[find(b)] + size[find(a)];<br>                    p[find(a)] = find(b);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ss.equals(<span class="hljs-string">&quot;Q1&quot;</span>))&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>                <span class="hljs-keyword">if</span> (find(a)==find(b))&#123;<br>                    System.out.println(<span class="hljs-string">&quot;Yes&quot;</span>);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;No&quot;</span>);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>                System.out.println(size[find(a)]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题3：</p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220715184742622.png" alt="image-20220715184742622"></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220715171736323.png" alt="image-20220715171736323"></p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/84401_3bdc0eab53-image-20211202210215862.png" alt="image-20211202210215862.png"></p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">50010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> p[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> d[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];  <span class="hljs-comment">//到根节点的距离</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x]!=x)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> find(p[x]);<br>            d[x] = d[x] + d[p[x]];<span class="hljs-comment">//计算到根节点的距离</span><br>            p[x] = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out)));<br>        String s[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.parseInt(s[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">//初始化p</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++) p[i] = i;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k-- &gt;<span class="hljs-number">0</span>)&#123;<br>            String s2[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Integer.parseInt(s2[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.parseInt(s2[<span class="hljs-number">1</span>]);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Integer.parseInt(s2[<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">if</span> (a&gt;n || b&gt;n) res++;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> find(a);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> find(b);<br>                <span class="hljs-keyword">if</span> (t==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果是同类的情况下</span><br>                    <span class="hljs-comment">//如果根节点相等，但不是同类则为假话</span><br>                    <span class="hljs-keyword">if</span> (pa==pb &amp;&amp; (d[a]-d[b])%<span class="hljs-number">3</span>!=<span class="hljs-number">0</span>) res++;<br>                    <span class="hljs-comment">//如果不是一个根节点 则合并，并且设置为同类</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pa!=pb)&#123;<br>                        p[pa] = pb;<br>                        <span class="hljs-comment">//(d[a] + ? - d[b]) % 3 == 0  =&gt; ? = db - da </span><br>                        d[pa]  = d[b] - d[a];<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//a吃b</span><br>                    <span class="hljs-comment">//a吃b 的条件是a比b大1，</span><br>                    <span class="hljs-keyword">if</span> (pa==pb &amp;&amp; (d[a]-d[b]-<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>!=<span class="hljs-number">0</span>) res++;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pa!=pb)&#123;<br>                        p[pa] = pb;<br>                        <span class="hljs-comment">//(da + ? - db - 1) % 3 == 0 =&gt;  ? = db - da + 1</span><br>                        d[pa]  = d[b] - d[a] + <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <br>        &#125;<br>        pw.println(res);<br>        pw.flush();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>其中堆中包含两个操作，一个是down，另一个是up。</p><p>down：当修改堆中的数字使其变大的时候，进行down操作，将该节点的根，左子树，右子树，进行比较，如果左右子节点比修改后的小，则与最小的数进行交换，。依次进行这个操作，直到又形成一个堆。</p><p>up:当变小一个堆中的数字。进行up操作，与它的根节点进行比较，如果小于根节点，则交换，依次比较。</p><p><img src="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220624164618317.png" alt="image-20220624164618317"></p><p><strong>在数组中，如果根的下标为x，则根的左儿子下标为2x，根的右儿子下标为2x+1。</strong></p><p><strong>ph[k] &#x3D; u:第k个插入的数，在堆中的下标是u；</strong><br><strong>hp[u] &#x3D; k:堆中下标为u的，是第k个插入的数；</strong></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瑞吉外卖-登录和员工管理</title>
    <link href="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/"/>
    <url>/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="瑞吉外卖项目的功能和搭建"><a href="#瑞吉外卖项目的功能和搭建" class="headerlink" title="瑞吉外卖项目的功能和搭建"></a>瑞吉外卖项目的功能和搭建</h1><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619212642130.png" alt="image-20220619212642130"></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619212559076.png" alt="image-20220619212559076"></p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619212618438.png" alt="image-20220619212618438"></p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619212532067.png" alt="image-20220619212532067"></p><h2 id="数据库表的信息"><a href="#数据库表的信息" class="headerlink" title="数据库表的信息"></a>数据库表的信息</h2><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619212711561.png" alt="image-20220619212711561"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><strong>添加 依赖（pom.xml）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;project xmlns=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br>         xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>         xsi:schemaLocation=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;<br>    &lt;modelVersion&gt;<span class="hljs-number">4.0</span><span class="hljs-number">.0</span>&lt;/modelVersion&gt;<br><br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">2.4</span><span class="hljs-number">.5</span>&lt;/version&gt;<br>        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;<br>    &lt;/parent&gt;<br><br>    &lt;groupId&gt;com.zlw.reggie&lt;/groupId&gt;<br>    &lt;artifactId&gt;reggie_take_out&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br><br>    &lt;properties&gt;<br>        &lt;maven.compiler.source&gt;<span class="hljs-number">8</span>&lt;/maven.compiler.source&gt;<br>        &lt;maven.compiler.target&gt;<span class="hljs-number">8</span>&lt;/maven.compiler.target&gt;<br>    &lt;/properties&gt;<br><br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>            &lt;scope&gt;compile&lt;/scope&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;<br>            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">3.4</span><span class="hljs-number">.2</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br><br>        <span class="hljs-comment">//简化了 JavaBean 的编写，避免了冗余和样板式代码而出现的插件，让编写的类更加简洁</span><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br>            &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">1.18</span><span class="hljs-number">.20</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br><span class="hljs-comment">//能够支持将java bean序列化成JSON字符串，也能够将JSON字符串反序列化成Java bean。</span><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">1.2</span><span class="hljs-number">.76</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;commons-lang&lt;/groupId&gt;<br>            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">2.6</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;mysql&lt;/groupId&gt;<br>            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>            &lt;scope&gt;runtime&lt;/scope&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">1.1</span><span class="hljs-number">.23</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br><br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;<span class="hljs-number">2.4</span><span class="hljs-number">.5</span>&lt;/version&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br><br>&lt;/project&gt;<br></code></pre></td></tr></table></figure><p><strong>核心配置文件（application.yml）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>  port: <span class="hljs-number">8080</span><br>spring:<br>  application:<br>    name: reggie_take_out  #应用名称<br>  datasource:<br>    druid:<br>      driver-class-name: com.mysql.cj.jdbc.Driver<br>      url: jdbc:mysql:<span class="hljs-comment">//localhost:3306/reggie?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><br>      username: root<br>      password: Zlw0502<br>mybatis-plus:<br>  configuration:<br>    #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射<br>    map-underscore-to-camel-<span class="hljs-keyword">case</span>: <span class="hljs-literal">true</span><br>    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl<br>  global-config:<br>    db-config:<br>      id-type: ASSIGN_ID #自定义主键策略<br></code></pre></td></tr></table></figure><p><strong>静态资源解析（想要通过浏览器直接访问页面生效：<a href="http://localhost:8080/backend/index.html%EF%BC%89">http://localhost:8080/backend/index.html）</a></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurationSupport</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//addResourceHandler是指你想在url请求的路径</span><br>        <span class="hljs-comment">// addResourceLocations是图片存放的真实路</span><br>        registry.addResourceHandler(<span class="hljs-string">&quot;/backend/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/backend/&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="项目搭建好的结构"><a href="#项目搭建好的结构" class="headerlink" title="项目搭建好的结构"></a>项目搭建好的结构</h2><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619213424402.png" alt="image-20220619213424402"></p><h1 id="登录和退出实现"><a href="#登录和退出实现" class="headerlink" title="登录和退出实现"></a>登录和退出实现</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619214711189.png" alt="image-20220619214711189"></p><p><strong>查看前端的页面代码，可以观察到，以下三个地方，也就是前端和后端所约定的一系列问题，就是后端所传过来的时候一定要带这三个变量，</strong></p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619214616019.png" alt="image-20220619214616019"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>EmployeeController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;/employee&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeeController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> EmployeeService employeeService;<br><br>    <span class="hljs-meta">@PostMapping</span> (<span class="hljs-string">&quot;/login&quot;</span>)<br>    <span class="hljs-keyword">public</span> R&lt;Employee&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(HttpServletRequest request, <span class="hljs-meta">@RequestBody</span> Employee employee)</span>&#123;<br><br>        <span class="hljs-comment">//1.对密码进行加密</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> employee.getPassword();<br>        password =  DigestUtils.md5DigestAsHex(password.getBytes());<br><br>        <span class="hljs-comment">//2、根据用户名查询数据库</span><br>        LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<span class="hljs-comment">//从数据库查询</span><br>        queryWrapper.eq(Employee::getUsername,employee.getUsername());<span class="hljs-comment">//比较相等</span><br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> employeeService.getOne(queryWrapper); <span class="hljs-comment">//返回查询结果</span><br><br>        <span class="hljs-comment">//3、如果没有查询到结果，则返回登录失败</span><br>        <span class="hljs-keyword">if</span> (emp==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;用户名不存在！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//4、比较密码是否正确</span><br>        <span class="hljs-keyword">if</span> (!password.equals(emp.getPassword()))<br>        &#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;密码错误&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//5、判断用户是否被禁用</span><br>        <span class="hljs-keyword">if</span> (emp.getStatus()==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;用户被禁用&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//6、登录成功，将员工的用户id加入到session中</span><br>        request.getSession().setAttribute(<span class="hljs-string">&quot;employee&quot;</span>,employee.getId());<br><br>        <span class="hljs-keyword">return</span> R.success(emp);<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 退出功能</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/logout&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">logout</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>        request.getSession().removeAttribute(<span class="hljs-string">&quot;employee&quot;</span>);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;退出成功&quot;</span>);<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="完善登录功能"><a href="#完善登录功能" class="headerlink" title="完善登录功能"></a>完善登录功能</h2><p><strong>如果不进行登录，直接访问url的时候，也可以进入主页面，这种设计很不合理。因此完善这个功能，当用户没有登录的时候，要跳转到登录页面。</strong></p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619234103147.png" alt="image-20220619234103147"></p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619234143910.png" alt="image-20220619234143910"></p><p><strong>处理逻辑</strong></p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220619234811897.png" alt="image-20220619234811897"></p><p>在这里使用过滤器实现，并在过滤器类上添加<code>@WebFilter(filterName = &quot;loginCheckFilter&quot;, urlPatterns = &quot;/*&quot;)</code>注解。</p><p>在启动类上添加：<code>@ServletComponentScan</code>注解进行扫描，如果不加，则识别不了过滤器上面的注解。</p><p><strong>代码为：</strong></p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(filterName = &quot;loginCheckFilter&quot;, urlPatterns = &quot;/*&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginCheckFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-comment">//路径匹配器，支持通配符</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">PATH_MATCHER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br><br>        <span class="hljs-comment">//获取请求访问的URI</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestURI</span> <span class="hljs-operator">=</span> request.getRequestURI();<br><br>        <span class="hljs-comment">//设置那些请求不拦截,,不拦截的是访问的uri，而不是静态js</span><br>        String [] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>                <span class="hljs-string">&quot;/employee/login&quot;</span>,<br>                <span class="hljs-string">&quot;/employee/logout&quot;</span>,<br>                <span class="hljs-string">&quot;/backend/**&quot;</span>,<br>                <span class="hljs-string">&quot;/front/**&quot;</span><br>        &#125;;<br>        <span class="hljs-comment">//判断请求的URI 和 数组 s 是否匹配，也就是是否需要拦截</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> just(s,requestURI);<br>        <span class="hljs-comment">//如果不需要拦截，则放行，</span><br>        <span class="hljs-keyword">if</span> (res)&#123;<br>            log.info(requestURI +<span class="hljs-string">&quot;不是拦截路径&quot;</span>);<br>            filterChain.doFilter(request,response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//如果是需要拦截的URI，则判断用户是否登录</span><br>        <span class="hljs-comment">//1、用户名不为空，证明已经登录，不需要拦截</span><br>        <span class="hljs-keyword">if</span> (request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>)!=<span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;是拦截路径，用户已经登录，id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>));<br>            filterChain.doFilter(request,response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//以上情况不发生，则拦截,发送一个json对象，前端接收到后，进行跳转页面</span><br>        response.getWriter().write(JSON.toJSONString(R.error(<span class="hljs-string">&quot;NOTLOGIN&quot;</span>)));<br>        log.info(<span class="hljs-string">&quot;用户未登录,拦截路径为:&#123;&#125;&quot;</span>,requestURI);<br>        <span class="hljs-keyword">return</span>;<br><br>    &#125;<br>    <span class="hljs-comment">//判断是否与不拦截的路径匹配</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">just</span><span class="hljs-params">(String s[],String requestURI)</span>&#123;<br>        <span class="hljs-keyword">for</span> (String uri:s) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> PATH_MATCHER.match(uri, requestURI);<br>            <span class="hljs-keyword">if</span> (match)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h1><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220621155021710.png" alt="image-20220621155021710"></p><p><strong>添加新增员工的信息，点击保存，提交给服务器。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增员工</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> employee</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">saveEmployee</span><span class="hljs-params">(HttpServletRequest request, <span class="hljs-meta">@RequestBody</span> Employee employee)</span>&#123;<br><br>        <span class="hljs-comment">//设置初始密码，进行md5加密</span><br>        employee.setPassword(DigestUtils.md5DigestAsHex(<span class="hljs-string">&quot;123456&quot;</span>.getBytes()));<br>        <span class="hljs-comment">//因为传递过来的信息，中没有对数据库字段中的创建时间、更新时间，创建者和更新者等进行设置，因此进行设置</span><br>        <span class="hljs-comment">//设置创建时间，在实体类中可以看到时间的类型为：LocalDateTime</span><br>        employee.setCreateTime(LocalDateTime.now());<br><br>        <span class="hljs-comment">//设置更新时间</span><br>        employee.setUpdateTime(LocalDateTime.now());<br>        <span class="hljs-comment">//设置创建者</span><br>        <span class="hljs-comment">//获取目前登录用户的ID，也就是在session中的id</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userID</span> <span class="hljs-operator">=</span> (Long)request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>);<br>        employee.setCreateUser(userID);<br>        <span class="hljs-comment">//设置更新者</span><br>        employee.setUpdateUser(userID);<br><br>        employeeService.save(employee);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;保存成功&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>但仅仅是上面的代码，还存在一些问题，就是我们规定该系统的用户名是唯一的，</p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220621155348324.png" alt="image-20220621155348324"></p><p>当我们添加一样的用户名的时候，控制台显示错误。</p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220621155437188.png" alt="image-20220621155437188"></p><p><strong>解决这个问题;</strong></p><ul><li><p>(1)可以将代码中添加<code>try..catch</code>进行捕获异常，这种方式处理非常不好，因为后面我们这种添加操作会很多，这样我们就要处理很多遍，。</p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220621155605677.png" alt="image-20220621155605677"></p></li><li><p>（2）推荐！！–使用异常处理器进行全局异常捕获，对整个项目进行捕获，不管是那个模块，只要出现着这种异常就可以捕获。</p><p>定义一个全局异常处理器：<code>GlobalExceptionHandler.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(SQLIntegrityConstraintViolationException.class)</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">exceptionHandler</span><span class="hljs-params">(SQLIntegrityConstraintViolationException e)</span>&#123;<br><span class="hljs-comment">// Duplicate entry &#x27;zhangsan&#x27; fro key &#x27;employee.idx_username&#x27;</span><br>        <span class="hljs-keyword">if</span> (e.getMessage().contains(<span class="hljs-string">&quot;Duplicate entry&quot;</span>))&#123;<br>            String[] s = e.getMessage().split(<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> s[<span class="hljs-number">2</span>]+<span class="hljs-string">&quot;已存在&quot;</span>;<br>            <span class="hljs-keyword">return</span> R.error(msg);<br>        &#125;<br>        <span class="hljs-keyword">return</span> R.error(<span class="hljs-string">&quot;未知错误&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>流程;</strong></p></li></ul><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220621162348717.png" alt="image-20220621162348717"></p><h1 id="员工信息分页查询"><a href="#员工信息分页查询" class="headerlink" title="员工信息分页查询"></a>员工信息分页查询</h1><p>使用mybatisplus中的分页插件进行实现。</p><p><strong>（1）首先编写MybatisPlus的分页插件配置类</strong></p><p>MybatisPlusConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * mybatisplus分页插件配置类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisPlusConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">mybatisPlusInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        mybatisPlusInterceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）编写Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置查询员工分页功能</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> page</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageSize</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/page&quot;)</span><br>    <span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page,<span class="hljs-type">int</span> pageSize,String name)</span>&#123;<br><br>        <span class="hljs-comment">//构造分页构造器</span><br>        <span class="hljs-type">Page</span> <span class="hljs-variable">pageInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(page,pageSize);<br><br>        <span class="hljs-comment">//构造条件构造器</span><br>        LambdaQueryWrapper&lt;Employee&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>        queryWrapper.like(StringUtils.isNotBlank(name),Employee::getName,name);<br>        <span class="hljs-comment">//添加排序条件</span><br>        queryWrapper.orderByDesc(Employee::getUpdateTime);<br><br>        <span class="hljs-comment">//执行查询</span><br>        employeeService.page(pageInfo,queryWrapper);<br><br>        <span class="hljs-keyword">return</span> R.success(pageInfo);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="启用禁用员工账号功能"><a href="#启用禁用员工账号功能" class="headerlink" title="启用禁用员工账号功能"></a>启用禁用员工账号功能</h1><p>（1）编写启用禁用员工的Controller，也就是更新员工的信息，所以写为update，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动禁用员工账号功能，也就是更新员工的信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping()</span><br>    <span class="hljs-keyword">public</span> R&lt;String&gt; <span class="hljs-title function_">update</span><span class="hljs-params">(HttpServletRequest request, <span class="hljs-meta">@RequestBody</span> Employee employee)</span>&#123;<br><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (Long) request.getSession().getAttribute(<span class="hljs-string">&quot;employee&quot;</span>);<br>        employee.setUpdateTime(LocalDateTime.now());<br>        employee.setUpdateUser(id);<br>        employeeService.updateById(employee);<br>        <span class="hljs-keyword">return</span> R.success(<span class="hljs-string">&quot;员工信息修改成功&quot;</span>);<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>但以上这么写完之后，修改不成功，也不提示错误，原因是浏览器通过json字符串传递过去的id值与数据库中的id值不相同</p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220621222838629.png" alt="image-20220621222838629"></p><p>数据库;</p><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220621222852762.png" alt="image-20220621222852762"></p><p>因此修改不成功，因为js对long类型的数据进行处理时丢失了精度，</p><p>如何解决：服务器给页面响应json数据的时候进行处理，将long数据类型转换为String字符串。</p><p>实现步骤：</p><p>（1）提供对象转换器JacksonObject，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象</span><br><span class="hljs-comment"> * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]</span><br><span class="hljs-comment"> * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JacksonObjectMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ObjectMapper</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_DATE_FORMAT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_DATE_TIME_FORMAT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_TIME_FORMAT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HH:mm:ss&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JacksonObjectMapper</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-comment">//收到未知属性时不报异常</span><br>        <span class="hljs-built_in">this</span>.configure(FAIL_ON_UNKNOWN_PROPERTIES, <span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">//反序列化时，属性不存在的兼容处理</span><br>        <span class="hljs-built_in">this</span>.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);<br><br><br>        <span class="hljs-type">SimpleModule</span> <span class="hljs-variable">simpleModule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleModule</span>()<br>                .addDeserializer(LocalDateTime.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))<br>                .addDeserializer(LocalDate.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDateDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))<br>                .addDeserializer(LocalTime.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalTimeDeserializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))<br><br>                .addSerializer(BigInteger.class, ToStringSerializer.instance)<br>                .addSerializer(Long.class, ToStringSerializer.instance)<br>                .addSerializer(LocalDateTime.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))<br>                .addSerializer(LocalDate.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))<br>                .addSerializer(LocalTime.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalTimeSerializer</span>(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));<br><br>        <span class="hljs-comment">//注册功能模块 例如，可以添加自定义序列化器和反序列化器</span><br>        <span class="hljs-built_in">this</span>.registerModule(simpleModule);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）在WebMvcConfig配置类中扩展Spring mvc的消息转换器，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 扩展mvc框架的消息转换器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> converters</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extendMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;<br>        <span class="hljs-comment">//创建消息转换器对象</span><br>        <span class="hljs-type">MappingJackson2HttpMessageConverter</span> <span class="hljs-variable">messageConverter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2HttpMessageConverter</span>();<br>        <span class="hljs-comment">//设置对象转换器对象，底层使用Jackson将JAVA对象转为json</span><br>        messageConverter.setObjectMapper(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonObjectMapper</span>());<br>        <span class="hljs-comment">//将上面的消息转换器对象追加到mvc框架的转换器集合中</span><br>        converters.add(<span class="hljs-number">0</span>,messageConverter);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="编辑员工信息"><a href="#编辑员工信息" class="headerlink" title="编辑员工信息"></a>编辑员工信息</h1><p><img src="/2022/06/19/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/image-20220722121148271.png" alt="image-20220722121148271"></p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span>  R&lt;Employee&gt; <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;根据id查询员工信息。。。&quot;</span>);<br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">byId</span> <span class="hljs-operator">=</span> employeeService.getById(id);<br>        <span class="hljs-keyword">return</span> R.success(byId);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringBoot项目</category>
      
      <category>瑞吉外卖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板1-基础算法</title>
    <link href="/2022/06/15/%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/06/15/%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p>计算区间之内的和都可以统一用这个公式：<code>S[r]-S[l-1]</code></p><p>下标必须从1开始，S0 &#x3D; 0；为了处理边界问题，例如：求[1,10]之间的和：S[10]-S[0]，为了所有的区间都可以使用这个公式，所以下标要从1开始，S0设置为0，因为要用到S0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220615220854543.png" alt="image-20220615220854543"></p><p><strong>例题：</strong></p><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>第二行包含 n 个整数，表示整数数列。</p><p>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> s[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            a[i] = scanner.nextInt();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            s[i] = s[i-<span class="hljs-number">1</span>] + a[i]; <span class="hljs-comment">//求每个数的前缀和</span><br>        &#125;<br>        <span class="hljs-keyword">while</span> (m--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            System.out.println(s[r]-s[l-<span class="hljs-number">1</span>]);  <span class="hljs-comment">//一维求两个数之间的和</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p><strong>S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和</strong><br><strong>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</strong><br><code>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</code></p><p><strong>推到：</strong></p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220616113027318.png" alt="image-20220616113027318"></p><p>而其中的<code>S[x,y] = S[x-1,y] + S[x,y-1] - S[x-1,y-1] + a[x,y];</code></p><p><strong>例题：</strong></p><p><strong>输入格式</strong></p><p>第一行包含三个整数 n，m，q。</p><p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p><p>接下来 q 行，每行包含四个整数 x1,y1,x2,y2,表示一组询问。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">1010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">1010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">Q</span> <span class="hljs-operator">=</span> <span class="hljs-number">200010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> qq[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[Q];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> s[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][M];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][M];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<span class="hljs-comment">//行</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<span class="hljs-comment">//列</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                a[i][j] = scanner.nextInt();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                s[i][j] = s[i-<span class="hljs-number">1</span>][j] + s[i][j-<span class="hljs-number">1</span>] - s[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+a[i][j]; <span class="hljs-comment">//先算每个方块中的前缀和，用了上面说的公式</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y2</span> <span class="hljs-operator">=</span> scanner.nextInt();<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> s[x2][y2] - s[x1-<span class="hljs-number">1</span>][y2] - s[x2][y1-<span class="hljs-number">1</span>] + s[x1-<span class="hljs-number">1</span>][y1-<span class="hljs-number">1</span>];  <span class="hljs-comment">//两个方块之间的和，用了上面说的公式</span><br>            System.out.println(res);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="差分（前缀和的逆运算）"><a href="#差分（前缀和的逆运算）" class="headerlink" title="差分（前缀和的逆运算）"></a>差分（前缀和的逆运算）</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p><strong>如果给出数组为b , a数组为b数组的前缀和数组，则b数组称为差分数组，。</strong></p><p>差分数组一般运用在，<strong>给出一个数组，求数组在[l,r]区间内加上某个数之后的数组是多少的问题：</strong></p><p>也就是如果要计算这种问题则，则先构造一个差分数组（<code>b[i] = a[i]-a[i-1]</code>）。</p><p>再将他的差分数组按照以下公式计算即可：</p><p><code>B[l] += c, B[r + 1] -= c</code></p><p>因此，如果要在原数组中改变，。则需要O(n)的时间，但使用差分数组，则只需要改变它的差分数组中的两个数即可，时间复杂度为线性的。</p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220616152317862.png" alt="image-20220616152317862"></p><p><strong>例题：</strong></p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220616152431442.png" alt="image-20220616152431442"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span>  <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            a[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-comment">//求a数组的差分数组--》b 这一步也可以使用insert方法，就是每次像b数组中加入一个小单元格，因为b初始的时候都是0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            b[i] = a[i] - a[i-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (m--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            insert(l,r,c);<br>        &#125;<br>        <span class="hljs-comment">//求从差分数组的前缀数组，并输出。因为将原数组差分之后还要转换回去才行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            b[i] = b[i-<span class="hljs-number">1</span>] + b[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            System.out.print(b[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//增加差分中两个数的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span>&#123;  <span class="hljs-comment">//使用的就是上面所说的公式</span><br>        b[l] = b[l] + c;<br>        b[r+<span class="hljs-number">1</span>] = b[r+<span class="hljs-number">1</span>] - c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p>S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和<br>以(x2, y2)为左上角，(x1, y1)为右下角的子矩阵的和为：</p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220616162713636.png" alt="image-20220616162713636"></p><p><strong>例题：</strong></p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220616160111643.png" alt="image-20220616160111643"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">1010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">M</span> <span class="hljs-operator">=</span> <span class="hljs-number">1010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][M];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N][M];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                a[i][j] = scanner.nextInt();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                insert(i,j,i,j,a[i][j]);  <span class="hljs-comment">//求二维数组的差分数组</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q--&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x2</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y2</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            insert(x1,y1,x2,y2,c);<br>        &#125;<br><br>        <span class="hljs-comment">//求出b的前缀和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                b[i][j] = b[i-<span class="hljs-number">1</span>][j] + b[i][j-<span class="hljs-number">1</span>] - b[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + b[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//输出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>                System.out.print(b[i][j]+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span>&#123;<br>        b[x1][y1] +=c;<br>        b[x2+<span class="hljs-number">1</span>][y1] -=c;<br>        b[x1][y2+<span class="hljs-number">1</span>] -=c;<br>        b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] +=c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p><strong>常见问题分类：</strong><br>    (1) 对于一个序列，用两个指针维护一段区间<br>    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220617085834965.png" alt="image-20220617085834965"></p><p><strong>模板：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; check(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220617100023712.png" alt="image-20220617100023712"></p><p><strong>代码1为（使用数组）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> s[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];  <span class="hljs-comment">//当前区间内，每个i出现的次数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            a[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            s[a[i]]++;<br>            <span class="hljs-keyword">while</span> (j&lt;=i &amp;&amp; s[a[i]]&gt;<span class="hljs-number">1</span>) &#123;<br>                s[a[j]]--;<br>                j++;<br>            &#125;<br>            res = Math.max(res,i-j+<span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码2为（使用哈希表），当判断的元素不是整数的时候，又可能是字母时，要使用哈希表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> Map&lt;Object,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            a[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(a[i])) map.put(a[i],map.get(a[i])+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> map.put(a[i],<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (j&lt;=i &amp;&amp; map.get(a[i])&gt;<span class="hljs-number">1</span>) &#123;<br>                map.put(a[j], map.get(a[j]) - <span class="hljs-number">1</span>);<br>                j++;<br>            &#125;<br>            res = Math.max(res,i-j+<span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p><strong>求n二进制中的第k位数字模板：</strong></p><p> <code>n &gt;&gt; k &amp; 1</code></p><p><strong>删除二进制中最后一个1</strong></p><p><code>n&amp;n-1</code></p><p><strong>返回二进制中的最后一个 1</strong></p><p><code>n &amp; -n</code></p><p><strong>例题：</strong></p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220617113253137.png" alt="image-20220617113253137"></p><p><strong>代码1为（使用<code>n&amp;(n-1)</code>）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span>  <span class="hljs-operator">=</span>scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            a[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (a[i]!=<span class="hljs-number">0</span>)&#123;<br>                a[i] = a[i]&amp;a[i]-<span class="hljs-number">1</span>;<br>                res++;<br>            &#125;<br>            System.out.print(res+ <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码2为 （使用<code>n&amp;-n</code>）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span>  <span class="hljs-operator">=</span>scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            a[i] = scanner.nextInt();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (a[i]!=<span class="hljs-number">0</span>)&#123;<br>                a[i] = a[i]-(a[i]&amp;(-a[i]));<br>                res++;<br>            &#125;<br>            System.out.print(res+ <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p><strong>针对什么样的问题？</strong></p><p>当对于所求数的值域非常大，但在实际的操作过程中，却只用到了一部分的数据，比如求 【l，r】之间的和，只用到了【l，r】之间的数，这时又可能想到利用前缀和的方式，进行计算，但是，值域很大 例如在10的-9次幂，到10的9次幂之间，设置一个数组很显然，不现实</p><p>因此，要使用离散化进行数据的映射，将用到的数据，映射到新的链表中，</p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220617222653747.png" alt="image-20220617222653747"></p><p><strong>例题：</strong></p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220617215642689.png" alt="image-20220617215642689"></p><p><strong>代码为l;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">300010</span>;<br>    <span class="hljs-keyword">static</span> List&lt;Integer&gt; alls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//存储操作的下标的询问的下标，也就是需要访问到的下标都要存储进去</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> s[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<span class="hljs-comment">//操作次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<span class="hljs-comment">//询问次数</span><br><br>        List&lt;Pair&gt; pairn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Pair&gt; pairm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            pairn.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(x,c));<br>            alls.add(x);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            pairm.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>(l,r));<br>            alls.add(l);<br>            alls.add(r);<br>        &#125;<br><br>        <span class="hljs-comment">//排序</span><br>        Collections.sort(alls);<br>        <span class="hljs-comment">//和去重</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> unique();<br>        alls = alls.subList(<span class="hljs-number">0</span>,p);<br>        <br>        <span class="hljs-keyword">for</span> (Pair pn:pairn)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> find(pn.first);<br>            a[i] = a[i] + pn.second;<br>        &#125;<br>        <span class="hljs-comment">//对a[i]进行求前缀和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=alls.size();i++) s[i] = s[i-<span class="hljs-number">1</span>]+a[i];<br><span class="hljs-comment">//遍历询问</span><br>        <span class="hljs-keyword">for</span> (Pair pm:pairm)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> find(pm.first);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> find(pm.second);<br>            System.out.println(s[r]-s[l-<span class="hljs-number">1</span>]);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">//找到在alls所对应的下标</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> alls.size()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (alls.get(mid)&gt;=x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-comment">//去掉alls中的重复元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">unique</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;alls.size();i++)&#123;<br>            <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> || alls.get(i)!=alls.get(i-<span class="hljs-number">1</span>))&#123;<br>                alls.set(j,alls.get(i));<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&#123;<br>    <span class="hljs-type">int</span> first;<br>    <span class="hljs-type">int</span> second;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second)</span> &#123;<br>        <span class="hljs-built_in">this</span>.first = first;<br>        <span class="hljs-built_in">this</span>.second = second;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p><strong>题型：</strong></p><p>有n个区间，把所有 有交集的区间进行合并，最后求出合并后区间的个数</p><p>多个区间，如果有交集的就进行合并。如下图所示：最后合并完的区间为3个</p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220617223228718.png" alt="image-20220617223228718"></p><p><strong>思想和步骤：</strong></p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220618114041739.png" alt="image-20220618114041739"></p><p><strong>代码模板：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(-<span class="hljs-number">2</span>*Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>));<br><span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(-<span class="hljs-number">2</span>*Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k[]:list)&#123;<br><span class="hljs-comment">//新区间的左端点大于前面区间的右端点，说明没有交集，要把之前的那个区间存入到结果集中</span><br><span class="hljs-keyword">if</span> (k[<span class="hljs-number">0</span>]&gt;r)&#123;<br><span class="hljs-comment">//如果不是第一个区间，则加入，之前已经合并之后的区间</span><br><span class="hljs-keyword">if</span> (l!=(<span class="hljs-type">int</span>)(-<span class="hljs-number">2</span>*Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>))) res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;l,r&#125;);<br><span class="hljs-comment">//维护下一个区间</span><br>l = k[<span class="hljs-number">0</span>];<br>r = k[<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//有交集的情况，更新最右端点</span><br>r = Math.max(r,k[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">//将最后一组加入结果集</span><br><span class="hljs-keyword">if</span> (l!=(<span class="hljs-type">int</span>)(-<span class="hljs-number">2</span>*Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>))) res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;l,r&#125;);<br></code></pre></td></tr></table></figure><p><strong>例题：</strong></p><p><img src="/2022/06/15/%E6%A8%A1%E6%9D%BF/image-20220618114104011.png" alt="image-20220618114104011"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[];<br>    <span class="hljs-keyword">static</span> List&lt;<span class="hljs-type">int</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> List&lt;<span class="hljs-type">int</span>[]&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            a[<span class="hljs-number">0</span>] = l;<br>            a[<span class="hljs-number">1</span>] = r;<br>            list.add(a);<br>        &#125;<br>        list.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] o1, <span class="hljs-type">int</span>[] o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(-<span class="hljs-number">2</span>*Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(-<span class="hljs-number">2</span>*Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>));<br>        <span class="hljs-comment">//区间合并模板</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k[]:list)&#123;<br>            <span class="hljs-comment">//新区间的左端点大于前面区间的右端点，说明没有交集，要把之前的那个区间存入到结果集中</span><br>            <span class="hljs-keyword">if</span> (k[<span class="hljs-number">0</span>]&gt;r)&#123;<br>                <span class="hljs-keyword">if</span> (l!=(<span class="hljs-type">int</span>)(-<span class="hljs-number">2</span>*Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>))) res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;l,r&#125;);<br>                <span class="hljs-comment">//维护下一个区间</span><br>                l = k[<span class="hljs-number">0</span>];<br>                r = k[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">//有交集，更新最右端点。</span><br>            r = Math.max(r,k[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-comment">//将最后一组加入结果集</span><br>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;l,r&#125;);<br>        System.out.println(res.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络问答</title>
    <link href="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221012151019484.png" alt="image-20221012151019484"></p><p><strong>物理层：</strong>主要的作用就是将比特流转化为电流传输，到达目标后，再转化为比特流。所以作比喻的话，公路、汽车和飞机等承载货物（数据）的交通工具，</p><p><strong>数据链路层：</strong>格式化数据进行传输，提供错误检测和纠正。封装为数据帧，传输给对方。根据帧中的信息把数据发送到正确的接受方。</p><p><strong>网络层：</strong>寻址和路由选择，负责在两台主机中，选择一条相对流畅的通路将数据传递过去。IP地址通过不断转发到更近的IP地址，最终可以到达目标地址</p><blockquote><p>IP协议:</p><p>ICMP协议：（对网络连接情况进行判断）能够检测网路的连线状况﹐也能确保连线的准确性。当路由器在处理一个数据包的过程中发生了意外，可以通过ICMP向数据包的源端报告有关事件。（Ping命令是一种使用ICMP协议的网络工具，用于测试主机之间的可达性和网络连接质量。）</p><p>ARP协议（Address Resolution Protocol）：地址解析协议，根据IP地址获取物理地址（mac地址）。主机将APR请求广播到本地网络上的所有主机。</p><p>RARP协议：通过MAC地址得到IP地址，主机向本地的RARP服务器进行广播。</p></blockquote><p><strong>传输层：</strong>提供数据传输，保证传输质量。为了传输大量文件的准确性，对数据进行切分，其中一个段落丢失是否重传和段落是否按序到达，都是传输层要考虑的问题。</p><blockquote><p>TCP协议、UDP协议</p></blockquote><p><strong>会话层：</strong>管理应用程序之间的会话（何时建立连接，断开连接，以及保持多久的连接）。</p><p><strong>表示层：</strong>解决不同系统之间通信语法的问题。数据格式的转换，解密和加密。比如说linux系统给windows系统发包，不用系统语法不一致。</p><p><strong>应用层：</strong>应用进程间的交互，向用户提供应用程序。其中存在：FTP（文件传输协议）、DNS（域名系统）、HTTP协议。应用层交互的数据单元称为报文。</p><h1 id="TCP-x2F-IP协议的层级"><a href="#TCP-x2F-IP协议的层级" class="headerlink" title="TCP&#x2F;IP协议的层级"></a>TCP&#x2F;IP协议的层级</h1><p><strong>（1）应用层：</strong>应用进程间的交互，向用户提供应用程序。其中存在：FTP（文件传输协议）、DNS（域名系统）、HTTP协议。应用层交互的数据单元称为报文。</p><p><strong>（2）传输层：</strong>对上层的应用层提供网络连接中的两台计算机之间的数据传输。其中有协议：TCP（传输控制协议）、UDP（ 用户数据报协议）</p><p><strong>（3）网络层：</strong>用来处理网络上流动的数据包，该层规定了，<strong>通过怎么样的传输路线到达对方的计算机</strong>，并把数据包传递给对方。（当与对方计算机通信之间通过多台计算机或网络设备进行传输时，网络层的作用就是在众多选项中选择一条传输路线。），使用IP协议。</p><p><strong>（4）数据链路层：</strong>两台主机之间的数据传输，总是在⼀段⼀段的链路上传送的，这就需要使⽤专⻔的链路层的协议。  数据链路层将⽹络层交下来的 IP 数据报组装成帧， 。</p><p><strong>（5）物理层：</strong>相邻计算机节点之间⽐特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异 ， 物理层上传输的数据单位时是比特。</p><p>使用HTTP举例来说明：</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220717222321278.png" alt="image-20220717222321278"></p><p>首先客户端在应用层发出一个HTTP请求，</p><p>接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP报文）进行分割，打上标记序号和端口号传输给网络层，</p><p>网络层增加MAC地址（网卡所属的固定地址）后发送给数据链路层，</p><p>接收端的服务器在数据链路层接受到数据，按序往上层发送，一直到应用层，当传输到应用层才能算真正接收到客户端发送过来的请求。。。</p><p>IP间的通信依赖MAC地址，在网络上，通信的双方在同一个局域网的情况很少，通常是多台计算机和网络设备中转才能连接到对方，而中转时会利用下一个中转设备的MAC地址来搜索下一个中转目标，这时会采用ARP协议，（<strong>ARP是一种解析地址的协议，根据通信方的IP地址反查出对应的MAC地址</strong>）</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220717224547322.png" alt="image-20220717224547322"></p><p>HTTP协议通信的过程中，各个协议发挥了哪些作用</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220717225953602.png" alt="image-20220717225953602"></p><h1 id="Tcp的三次握手和四次挥手"><a href="#Tcp的三次握手和四次挥手" class="headerlink" title="Tcp的三次握手和四次挥手"></a>Tcp的三次握手和四次挥手</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221028152944883.png" alt="image-20221028152944883"></p><p><strong>（1）第一握手：SYN&#x3D;1,seq&#x3D;x（客户端向服务器端发出连接请求）</strong></p><p>SYN&#x3D;1：表示客户端与服务器段建立连接</p><p>seq&#x3D;x：表示客户端向服务器端发送的序列号为x，表明传送数据时，第一个数据字节的序号为x。</p><p><strong>（2）第二次握手：SYN&#x3D;1,ACK&#x3D;1,seq&#x3D;y,ack&#x3D;x+1（服务器端确认可以连接，并向客户端发起连接请求）</strong></p><p>ACK&#x3D;1：服务器收到SYN&#x3D;1后知道客户端请求连接，确认标志位ACK为1，表示可以连接。</p><p>ack&#x3D;x+1：表示服务器端确认序号，表明已经收到x+1序号之前的所有数据。</p><p>SYN&#x3D;1：表示服务器要向客户端发起连接请求。（因为不是只有客户端才能发送数据）</p><p>seq&#x3D;y：表示客户端向服务端发送数据的开始序号。</p><p><strong>（3）第三次握手：ACK&#x3D;1,seq&#x3D;x+1,ack&#x3D;y+1（客户端确认可以连接）</strong></p><p>ACK&#x3D;1：表示客户端确认，服务器端向客户端发起的连接请求。表明可以连接。</p><p>seq&#x3D;x+1：发送下一个x+1的序列号。</p><p>ack&#x3D;y+1：表明客户端已经成功接收了服务器端向客户端发送的前y+1个数据。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221028154434202.png" alt="image-20221028154434202"></p><p><strong>（1）第一次挥手：FIN&#x3D;1，seq&#x3D;u</strong></p><p>FIN&#x3D;1：表示要关闭连接。</p><p>seq&#x3D;u表示：表示u之前的数据已经全部发送，并且发送到u就截止。</p><p><strong>（2）第二次挥手：ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1</strong></p><p>ACK&#x3D;1：确认断开连接</p><p>seq&#x3D;v：服务器端传送数据，序列号为v。</p><p>ack&#x3D;u+1：确认号，表明已经接收到u+1之前的所有数据</p><p><strong>（3）第三次挥手：FIN &#x3D; 1，ACK&#x3D;1，seq&#x3D;w，ack&#x3D;u+1</strong></p><p>FIN&#x3D;1：表示服务器端发起断开请求</p><p>ACK&#x3D;1：收到确认</p><p>seq&#x3D;w：服务器端发送数据</p><p>ack&#x3D;u+1：发送确认号</p><p><strong>（4）第四次挥手：ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1</strong></p><p>ACK&#x3D;1：确认断开连接</p><p>seq&#x3D;u+1：发送序列号为u+1</p><p>ack&#x3D;w+1：确认序列号，表明已经接收到w+1之前的所有数据</p><h1 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h1><p><strong>（1）端口号不一致：</strong></p><ul><li>HTTP的URL是由”http:&#x2F;&#x2F;“开始，默认端口号为<strong>80</strong>，HTTPS的URL是由”https:&#x2F;&#x2F;“开始，默认端口号为<strong>443</strong></li></ul><p><strong>（2）安全性和资源消耗</strong></p><ul><li>HTTP是运行在TCP之上的，所有的传输的内容都是明文（没有加密的文字），HTTPS是运行在<strong>SSL&#x2F;TLS</strong>(客户端和服务器之间提供安全通信通道的加密协议)<strong>之上</strong>的协议，SSL&#x2F;TLS运行在TCP之上的，所有传输都是经过加密的。</li><li>加密采用对称加密，密钥用服务器方的证书进行非对称加密，因此，<strong>HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源。</strong></li></ul><blockquote><p>对称加密：加密和解密的秘钥使用的是同一个</p><p>非对称加密：与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。</p></blockquote><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718131833415.png" alt="image-20220718131833415"></p><p>SSL是独立于 HTTP 的协议， 所以不光是 HTTP 协议， 其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。  </p><h1 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h1><ul><li>对称加密：文件的加密和解密用的是同一个密钥，使用起来简单快捷，密钥较短</li><li>非对称加密：需要两个密钥：公有密钥和私有密钥，组成一对，公有密钥对数据加密只能用私有密钥进行解密，私有密钥对数据进行加密只能用公有密钥进行解密。<ul><li>实现过程：甲方生成一对密钥，把其中一把作为公用密钥，则乙方得到该公用密钥对文件进行加密，传送给甲方时，甲方通过自己保存的那个私有密钥进行解密，甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</li></ul></li></ul><p><strong>区别：</strong></p><p>（1）加密过程不同</p><p>（2）加密速度不同：对称加密快，适用于数据较长的，非对称加密速度较慢，适用于少量数据</p><p>（3）传输安全不同：</p><ul><li>对称加密安全性较低，因为在传输的过程中，可能被其他第三方捕获。</li><li>非对称加密：私钥通过一定的加密算法推到出的公钥，私钥到公钥的推导过程是单向的，不能通过公钥而推导出私钥。</li></ul><h1 id="常见的加密算法"><a href="#常见的加密算法" class="headerlink" title="常见的加密算法"></a>常见的加密算法</h1><p><strong>（1）对称加密算法：</strong></p><p>过程：接收方收到加密后的报文后，结合解密算法使用相同密钥解密组合后得出原始数据</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221102110249271.png" alt="image-20221102110249271"></p><p>优点：效率高，简单，系统开销小，适合加密大量数据</p><p>缺点：安全性差，扩展性差（n个用户的团体就需要协商n*(n-1)&#x2F;2个不同的密钥，不便于管理），</p><p><strong>常见的对称加密算法：DES,3DES,AES..</strong></p><p><strong>（2）非对称加密算法</strong></p><p>过程：(非对称密钥加密适合对密钥或身份信息等敏感信息加密，从而在安全性上满足用户的需求。）)</p><p>1.甲使用乙的公钥并结合相应的非对称算法将明文加密后发送给乙，并将密文发送给乙。<br>2.乙收到密文后，结合自己的私钥和非对称算法解密得到明文，得到最初的明文。</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221102110456546.png" alt="image-20221102110456546"></p><p>优点：更高的安全性，因为加密和解密用的是不同密钥，而且无法从一个密钥推导出另一个密钥，且公钥加密的信息只能用同一方的私钥进行解密。</p><p>缺点：（1）算法复杂，加密时间长，适合对少量数据进行加密。（2）无法确认公钥的来源合法性以及数据的完整性</p><p><strong>常见的算法：RSA,DSA,DSS</strong></p><p><strong>（3）单向加密：</strong></p><p>单向加密算法只能用于对数据的加密，无法被解密，其特点为定长输出、雪崩效应（少量消息位的变化会引起信息摘要的许多位变化）。</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221102110725473.png" alt="image-20221102110725473"></p><p><strong>常见的算法：MD5、sha1、sha224等等</strong></p><h1 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么?"></a>URI和URL的区别是什么?</h1><ul><li><p>URI(Uniform Resource Identifier) 是统⼀资源标志符，可以唯⼀标识⼀个资源。  (身份证)</p></li><li><p>URL(Uniform Resource Location) 是统⼀资源定位符，可以提供该资源的路径。  <strong>不仅可以标识 一个资源，还可以定位这个资源。</strong>（家庭地址）</p></li></ul><h1 id="HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>HTTP 1.0和HTTP 1.1的主要区别是什么?</h1><p>（1）http1.0使用在1996年，只使用在一些简单的网页上和网络请求。</p><p>（2）http1.1在1999年广泛使用于各大浏览器，也是目前最广泛的http协议。</p><p><strong>有一下几个区别表现：</strong></p><ul><li><p><strong>长连接：</strong>http1.0使用的是短连接，也就是说每次请求都要重新建⽴⼀次连接。  （HTTP 是基于TCP&#x2F;IP协议的,每⼀次建⽴或者断开连接都需要三次握⼿四次挥⼿的开销  ）HTTP 1.1起，<strong>默认使⽤⻓连接 ,默认开启Connection： keep-alive。</strong>  </p></li><li><p>**错误状态响应码 : ** <strong>在HTTP1.1中新增了24个错误状态响应码</strong>，  409（Conflict）表示请求的资源与资源的当前状态发⽣冲突； 410（Gone）表示服务器上的某个资源被永久性的删除。  </p></li><li><p><strong>缓存处理</strong>  ：HTTP1.1引⼊了更多的缓存控制策略 </p></li><li><p><strong>带宽优化及⽹络连接的使⽤ :</strong>  HTTP1.0中，存在⼀些浪费带宽的现象  ，例如客户端只是需要某个对象的⼀部分，⽽服务器却将整个对象送过来了，并且不支持断点续传功能  <strong>HTTP1.1则在请求头引⼊了range头域，它允许只请求资源的某个部分（使用：range：bytes&#x3D;开始数据的索引位置-结束数据的索引位置）</strong>  </p></li><li><p><strong>管线化技术：</strong>从前发送请求，需要等待并收到响应，才能发送下一个请求，管线技术出现后，不用等待，可以直接发送下一个请求，可以做到并行发送多个请求，比长连接速度更快。</p></li><li><p><strong>Host字段：</strong>Http1.1中增加了这个字段，因为随着虚拟机的出现，一台服务器上可以存在多个虚拟主机，并且共享同一个IP地址。所以要通过host字段指定主机名称。<strong>如果没有该字段，则会返回一个400的状态码</strong>。</p></li><li><p><strong>100状态码：</strong>客户端首先发一个带头域的请求，如果服务器拒绝了请求，响应码为401，如果响应码为100，客户端可以继续发送一个带实体的完整请求。也就是用请求头试探服务器，看服务器要不要接受请求体。</p></li></ul><h1 id="http的缓存策略有哪些"><a href="#http的缓存策略有哪些" class="headerlink" title="http的缓存策略有哪些"></a>http的缓存策略有哪些</h1><blockquote><p>http的缓存策略是是浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，通过缓存标识来判断是否用本地缓存。如果缓存有效则直接用，否则向服务器发起请求并携带缓存标识，http协议中有两种缓存策略：<strong>强制缓存和协商缓存</strong>，强制的优先级大于协商</p></blockquote><p><strong>强制缓存：</strong>强制缓存就是在第一次访问服务器取到数据之后，在过期时间之内不会再去重复请求，而是直接读取本地缓存数据库中的信息（from memory or from disk），两种方式根据浏览器的策略随机获取。</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5e09cbb89fec46d6a40538bf7f4b554d~tplv-k3u1fbpfcp-watermark.image" alt="http缓存-强制缓存"></p><p>当发起请求的时间超过了设定的时间，即表示资源缓存时间到期，会再次发送请求到服务器重新获取资源。而如果发起请求的时间在限定的时间之内，浏览器会直接读取本地缓存数据库中的信息。</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6f32242f0724406c845eca39f4882b2f~tplv-k3u1fbpfcp-watermark.image" alt="http缓存-强制缓存-缓存失效"></p><p>实现这个流程的核心就是<strong>如何知道当前时间是否超过了过期时间</strong>。强制缓存的过期时间通过第一次访问服务器时返回的响应头获取。在 http 1.0 和 http 1.1 版本中通过不同的响应头字段实现。</p><p>在 http 1.0 版本中，强制缓存通过<code>Expires</code>响应头来实现。 expires 表示未来资源会过期的时间。</p><p>在 http 1.1 版本中，强制缓存通过 <code>Cache-Control: max-age=xxx</code> 响应头来实现。</p><p>一般来说，为了兼容，两个版本的强制缓存都会被实现。</p><p><strong>协商缓存：</strong>协商缓存与强制缓存的不同之处在于，协商缓存每次读取数据时都需要跟服务器通信，并且会增加缓存标识。</p><ol><li>在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。</li><li>当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回 304 状态码，浏览器就读取本地缓存服务器中的数据。</li></ol><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4d9460548b8248a0aad44849eb494156~tplv-k3u1fbpfcp-watermark.image" alt="协商缓存流程图"></p><p><strong>Http缓存都是从第二次请求开始的：</strong></p><p>​第一次请求资源时，服务器返回资源并在响应头中回传缓存策略</p><p>​第二次请求资源时，浏览器判断这些请求参数，如果命中强制缓存，则直接返回状态码200，否则把请求参数加到请求头传给服务器，看是否命中协商缓存，命中返回304状态码，否则服务器返回新的资源。</p><p><strong>http1.0中的协商缓存</strong></p><ol><li>第一次请求资源时服务器通过 Last-Modified 来设置响应头的缓存标识，也就是最后修改修改的时间返回给浏览器</li><li>在第二次请求时，浏览器会将 Last-Modified 的信息放到 If-Modified-Since 请求头去访问服务器。服务器会将 If-Modified-Since 中携带的时间与资源修改的时间匹配，如果时间不一致，服务器会返回新的资源，并且将 Last-Modified 值更新，作为响应头返回给浏览器。如果时间一致，表示资源没有更新，服务器返回 304 状态码，浏览器拿到响应状态码后从本地缓存数据库中读取缓存资源。</li></ol><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/250bdae9421f4a238f8300e8042a7ce7~tplv-k3u1fbpfcp-watermark.image" alt="协商缓存之last-Modified"></p><p>这种方式有一个弊端，就是当服务器中的资源增加了一个字符，后来又把这个字符删掉，本身资源文件并没有发生变化，但修改时间发生了变化。当下次请求过来时，服务器也会把这个本来没有变化的资源重新返回给浏览器。</p><p><strong>http1.1中的协商缓存</strong>（在 http 1.1 版本中，服务器通过 Etag 来设置响应头缓存标识。Etag 的值由服务端生成。）</p><ol><li>在第一次请求时，服务器会将资源和 Etag 一并返回给浏览器，浏览器将两者缓存到本地缓存数据库。</li><li>在第二次请求时，浏览器会将 Etag 信息放到 If-None-Match 请求头去访问服务器。服务器收到请求后，会将服务器中的文件标识与浏览器发来的标识进行对比，如果不相同，服务器返回更新的资源和新的 Etag ，如果相同，服务器返回 304 状态码，浏览器读取缓存。</li></ol><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/099ff22bbcb141a5b48301a319c516a5~tplv-k3u1fbpfcp-watermark.image" alt="协商缓存之Etag"></p><p>控制强制缓存的字段：Cache-Control（http1.1）和Expires（http1.0）。</p><blockquote><p>Cache-control是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。 </p><p>Expires是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求。</p></blockquote><p>控制协商缓存的字段有：Last-Modified&#x2F;If-Modified-since（http1.0）和Etag&#x2F;If-None-match（http1.1）</p><blockquote><p>Last-Modified&#x2F;If-Modified-since表示的是服务器的资源最后一次修改的时间。Etag(响应头)&#x2F;If-None-match（请求验证缓存）表示的是服务器资源的唯一标识，只要资源变化，Etag就会重新生成。</p></blockquote><p><strong>协商缓存的总结：</strong></p><p>​协商缓存每次请求都会与服务器交互，第一次是拿数据和标识的过程，第二次开始，就是浏览器询问服务器资源是否有更新的过程。每次请求都会传输数据，如果命中缓存，则资源的 Status 状态码为 304 而不是 200 。同样的，一般来讲为了兼容，两个版本的协商缓存都会被实现，http 1.1 版本的实现优先级会高于 http 1.0 版本的实现。</p><h1 id="Http缓存用到了什么字段"><a href="#Http缓存用到了什么字段" class="headerlink" title="Http缓存用到了什么字段"></a>Http缓存用到了什么字段</h1><p>用到了以下三个字段</p><p><strong>Cache-Control&#x2F;Pragma, Expires, Last-Modified&#x2F;Etag</strong></p><p><strong>（1）Cache-Control&#x2F;Pragma：</strong>用于指定所有缓存机制的整个请求中必须服从的指令，可以指定下列可选值：<br>    public:所有内容都将被缓存，在响应头设置<br>    private：内容只缓存在私有缓存中，在响应头设置<br>    no-cache：所有内容都不会被缓存，在请求头和 响应头中设置<br>    no-store：所有内容都不会被缓存在缓存或Internet临时文件中，在响应头中设置</p><p><strong>（2）Expires：</strong>后面跟着日期和时间，超过这个时间后，缓存内容将失效，浏览器发送请求之前，检查这个页面的字段，看页面是否已经过期，<br>如果过期就向服务器重新发起请求。</p><p><strong>（3）Last-Modified：</strong>服务器上的资源最后的修改时间，服务器会在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间<br>浏览器在请求时在请求头中增加If-Modified-Since字段，询问当前缓存页面是否是最新，如果是最新则返回304，告诉浏览器是最新的，服务器不会传输最新数据。z</p><h1 id="Http1-x-和-Http2-0的区别"><a href="#Http1-x-和-Http2-0的区别" class="headerlink" title="Http1.x 和 Http2.0的区别"></a>Http1.x 和 Http2.0的区别</h1><ul><li>新的二进制格式，Http1.x是基于文本的。</li><li>多路复用，即连接共享，每一个request都是用作连接共享机制的，一个requeast对应一个id，所以一个连接中有多个请求，接收方根据request的id归属到不同的服务器请求里面。</li><li>header压缩：Http1.x中的header中有大量的信息，每次都要重复发送，HTTP2.0将通讯双方各自cache一份header fields表，避免了重复header传输，减小了传输的大小。数据体积小，网络传输更快。</li><li>服务端推送：当服务器接收到请求时，服务器会顺便把一些客户需要的资源一起推送到客户端。免得客户端再次创建连接发送请求。<ul><li>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送。</li></ul></li></ul><h1 id="Cookie的作⽤是什么-和Session有什么区别？"><a href="#Cookie的作⽤是什么-和Session有什么区别？" class="headerlink" title="Cookie的作⽤是什么?和Session有什么区别？"></a>Cookie的作⽤是什么?和Session有什么区别？</h1><p>cookie是当客户端发送给服务器请求时，如果服务器需要记录该用户的状态，则服务器生成一串字符，respone客户端，客户端保存这个cookie，当再次访问服务器时，浏览器把请求的网址连同该cookie一同提交给服务器，服务器检查cookie，以此来辨认用户状态。</p><p><strong>Session时另一种记录用户状态的机制</strong>，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p><strong>区别：</strong></p><p><strong>1、数据存储位置：</strong>cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p><strong>2、安全性：</strong>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。</p><p><strong>3、服务器性能：</strong>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。</p><p><strong>4、数据大小：</strong>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p><strong>5、信息重要程度：</strong>可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。</p><p><strong>（1）Cookie ⼀般⽤来保存⽤户信息   ：</strong></p><ul><li>我们在 Cookie 中保存已经登录过得⽤户信息，下次访问⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了  </li><li>保持登录功能：也就是说下次你再访问⽹站的时候就不需要重新登录了  这是因为⽤户登录的时候我们可以存放了⼀个Token 在 Cookie 中</li></ul><blockquote><p>Token:<strong>Token是服务端生成的一串字符串</strong>当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。 token其实说的更通俗点可以叫暗号，在一些数据传输之前，要先进行暗号的核对，不同的暗号被授权不同的数据操作。  </p></blockquote><ul><li>登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录</li></ul><p><strong>（2）Session 的主要作⽤就是通过服务端记录⽤户的状态</strong>  </p><ul><li>服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了  （典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 <strong>HTTP 协议是⽆状态的。</strong>  ）</li></ul><p><strong>Cookie 存储在客户端中，⽽Session存储在服务器上，相对来说 Session 安全性更⾼。</strong>  </p><h1 id="HTTP是不保存状态的协议-如何保存⽤户状态"><a href="#HTTP是不保存状态的协议-如何保存⽤户状态" class="headerlink" title="HTTP是不保存状态的协议,如何保存⽤户状态?"></a>HTTP是不保存状态的协议,如何保存⽤户状态?</h1><p><strong>HTTP 是⼀种不保存状态  指的是：HTTP 协议⾃身不对请求和响应之间的通信状态进⾏保存。</strong>  </p><p>如何保存用户状态：Session：Session 的主要作⽤就是通过服务端记录⽤户的状态。  </p><p>服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了  </p><p> Session 存放在服务器端，⼤部分情况下，我们都是通过在 Cookie 中附加⼀个 Session ID 来⽅式来跟踪。  </p><h1 id="返回结果的HTTP状态码"><a href="#返回结果的HTTP状态码" class="headerlink" title="返回结果的HTTP状态码"></a>返回结果的HTTP状态码</h1><p>状态码的职责是当客户端向服务器端发送请求时， 描述返回的请求结果。 借助状态码， 用户可以知道服务器端是正常处理了请求， 还是出现了错误。  </p><p><strong>状态码的类别：</strong></p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718000141987.png" alt="image-20220718000141987"></p><p><strong>经常使用的14种状态码：</strong></p><h2 id="2xx（请求被正常处理）"><a href="#2xx（请求被正常处理）" class="headerlink" title="2xx（请求被正常处理）"></a>2xx（请求被正常处理）</h2><p><strong>200(成功)：</strong>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。<br><strong>201(已创建)：</strong>请求成功并且服务器创建了新的资源。<br><strong>202(已接受)：</strong>服务器已接受请求，但尚未处理。<br><strong>203(非授权信息)：</strong>服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>*<em>204(无内容)：</em>**<em>服务器成功处理了请求，但没有返回任何内容。<br><strong>205(重置内容)：</strong></em>*服务器成功处理了请求，但没有返回任何内容。<br><strong>206(部分内容)：</strong>服务器成功处理了部分 GET 请求。</p><p>（1）200 OK ：表示请求已经正常处理</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718000557231.png" alt="image-20220718000557231"></p><p>（2）204 No Content  ：请求处理成功，没有资源可以返回</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718000546692.png" alt="image-20220718000546692"></p><p>（3）206 Partial Content  ：该状态码表示客户端进行了范围请求， 而服务器成功执行了这部分的GET 请求。   </p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718000535285.png" alt="image-20220718000535285"></p><h2 id="3xx（重定向）"><a href="#3xx（重定向）" class="headerlink" title="3xx（重定向）"></a>3xx（重定向）</h2><p>响应结果表明浏览器需要执行某些特殊的处理从而正确处理请求</p><p><strong>（1）301 Moved Permanently  ：</strong>永久性重定向，该状态码表示请求的资源已被分配了新的 URI， 以后应使用资源现在所指的 URI。   </p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718122334296.png" alt="image-20220718122334296"></p><p><strong>（2）302 Found  ：</strong>临时性重定向。 该状态码表示请求的资源已被分配了新的 URI， 希望用户（本次） 能使用新的 URI 访问。  </p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718122341384.png" alt="image-20220718122341384"></p><p><strong>301和302都会在响应头里使用字段location，指明后续要跳转的url，浏览器会自动重定向新的url</strong></p><p><strong>（3）303 See Other</strong>  ：其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时。</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718122351174.png" alt="image-20220718122351174"></p><p><strong>（4）304 Not Modified  ：</strong>该状态码表示客户端发送附带条件的请求 2 时， 服务器端允许请求访问资源， 但未满足条件的情况。  </p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718122359237.png" alt="image-20220718122359237"></p><p><strong>（5）307 Temporary Redirect  ：</strong>也是临时重定向，307 会遵照浏览器标准， 不会从 POST 变成 GET。   </p><h2 id="4xx（客户端错误）"><a href="#4xx（客户端错误）" class="headerlink" title="4xx（客户端错误）"></a>4xx（客户端错误）</h2><p>响应结果表明客户端是发生错误的原因所在  </p><p><strong>（1）400 Bad Request</strong>  该状态码表示请求报文中存在语法错误  ，需要修改请求的内容再次发送。</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718123733573.png" alt="image-20220718123733573"></p><p><strong>（2）401 Unauthorized  ：</strong>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证） 的认证信息。   </p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718123928331.png" alt="image-20220718123928331"></p><p><strong>（3）403 Forbidden  ：</strong>该状态码表明对请求资源的访问被服务器拒绝了。   </p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718123943423.png" alt="image-20220718123943423"></p><p><strong>（4）404 Not Found  ：</strong>该状态码表明服务器上无法找到请求的资源。 除此之外， 也可以在服务器端拒绝请求且不想说明理由时使用。  </p><pre><code class="hljs"> ![image-20220718124038432](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718124038432.png)</code></pre><h2 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h2><p>响应结果表明服务器本身发生错误。  </p><p><strong>（1）500 Internal Server Error  ：</strong>服务器端在执行请求时发生了错误。   </p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718124231991.png" alt="image-20220718124231991"></p><p><strong>（2）503 Service Unavailable  ：</strong>服务器停机维护</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220718124301680.png" alt="image-20220718124301680"></p><h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><p><strong>（1）UDP：</strong>（qq语音，qq视频等等。）</p><ul><li><strong>面向无连接：</strong>在传送数据之前不需要先建立连接，想发送就发送，</li><li><strong>面向报文的：</strong>不会对报文进行拆分和拼接。</li><li><strong>不可靠：</strong>远地主机收到UDP报文后，不需要给出任何确认，传输速度快 ，</li><li><strong>单播，多播，广播功能</strong></li></ul><p><strong>（2）TCP：</strong>（TCP ⼀般⽤于⽂件传输、发送和接收邮件、远程登录等场景。  ）</p><ul><li><strong>是面向连接的服务</strong>，在传送数据之前必须要建立连接（三次握手的方法），数据传送结束后要释放连接，</li><li><strong>单播传播</strong>：TCP传输只能有两个端点，只进行点对点的数据传输，不支持多播和广播的传输方式。</li><li><strong>面向字节流</strong>：以字节流的方式进行传播，不像UDP报文那样一个个报文独立的传播。</li><li><strong>可靠传输</strong>：为了保证报文可靠传输，给每一个报文一个序号，同时这个需要也保证了接收端按包的顺序接受，接收端收到后给发送端发送OK，如果发送端在一定的时间内，没有收到确认，则重新发送。</li><li><strong>提供拥塞控制</strong>：当网络出现拥塞时，TCP减少向网路注入数据的速度和数量，缓解拥塞。</li></ul><h1 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h1><p><strong>就是自动重传请求</strong>（Automatic Repeat-reQuest  ）：通过确认和超时两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送⽅在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。  </p><p>ARQ包括<strong>停⽌等待ARQ协议</strong>和<strong>连续ARQ协议</strong>  </p><h2 id="运行在哪个层"><a href="#运行在哪个层" class="headerlink" title="运行在哪个层"></a>运行在哪个层</h2><p>ARQ是可以在不可靠的数据通道上可靠的传输数据的方案，所以链路层和传输层都用了ARQ，并不专属于哪一层。</p><p>如果自己写程序，要在应用层通信，但传输层不想用TCP，想用UDP，也可以在你的程序里用ARQ协议来实现可靠性。</p><h2 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h2><p>没发送一个分组后就停止等待，等待对方回复确认ACK，超过一段时候没有收到确认时，则重新发送。接收方如果接收到重复的分组则丢弃。</p><p>优点： 简单<br>缺点： 信道利⽤率低，等待时间⻓  </p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221102150813853.png" alt="image-20221102150813853"></p><h2 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h2><p>可提高信道利用率，发送方维持一个窗口，凡是位于窗口内的分组可以连续发出，不需要等待对方确认，接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组的所有分组都已经正确收到。</p><p>优点： 信道利⽤率⾼，容易实现，即使确认丢失，也不必重传  </p><p>缺点：不能像发送方反应已经收到的正确的所有分组的信息，例如，发送5个分组，第3个分组丢失，这时接受收方只能发送前两个成功发送的确认，而不能直到4和5 也成功接受，所以只能重新传递4和5。</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221102150818226.png" alt="image-20221102150818226"></p><h1 id="滑动窗⼝和流量控制"><a href="#滑动窗⼝和流量控制" class="headerlink" title="滑动窗⼝和流量控制"></a>滑动窗⼝和流量控制</h1><p>TCP 利⽤滑动窗⼝实现流量控制。流量控制是为了控制发送⽅发送速率，保证接收⽅来得及接收。 接收⽅发送的确认报⽂中的窗⼝字段可以⽤来控制发送⽅窗⼝⼤⼩，从⽽影响发送⽅的发送速率。将窗⼝字段设置为 0，则发送⽅不能发送数据。  </p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>拥塞控制就是为了防⽌过多的数据注⼊到⽹络中，这样就可以使⽹络中的路由器或链路不致过载。  </p><p>为了进⾏拥塞控制， TCP 发送⽅要维持⼀个 拥塞窗⼝(cwnd) 的状态变量。拥塞控制窗⼝的⼤⼩取决于⽹络的拥塞程度，并且动态变化。发送⽅让⾃⼰的发送窗⼝取为拥塞窗⼝和接收⽅的接受窗⼝中较⼩的⼀个。  </p><h1 id="在浏览器中输⼊url地址-gt-gt-显示主⻚的过程-⾯试常客"><a href="#在浏览器中输⼊url地址-gt-gt-显示主⻚的过程-⾯试常客" class="headerlink" title="在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程(⾯试常客)"></a>在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程(⾯试常客)</h1><ol><li>DNS 解析：获取域名对应IP</li><li>TCP 连接：（三次握手）</li><li>发送 HTTP 请求：向web服务器发送一个Http请求（get和post请求：请求行，请求头，请求体）</li><li>服务器处理请求并返回 HTTP 报文：（响应行，响应头，响应体）</li><li>浏览器解析渲染页面：（浏览器是一个边解析边渲染的过程）</li><li>连接结束</li></ol><h1 id="TCP是怎么实现可靠传输的"><a href="#TCP是怎么实现可靠传输的" class="headerlink" title="TCP是怎么实现可靠传输的"></a>TCP是怎么实现可靠传输的</h1><ol><li><strong>基于数据快传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li><li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。</li><li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li><li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送</li></ol><h1 id="IP协议中的TTL是什么"><a href="#IP协议中的TTL是什么" class="headerlink" title="IP协议中的TTL是什么"></a>IP协议中的TTL是什么</h1><p><strong>IP包被路由器丢弃之前允许通过的最大网段数量，。</strong></p><p>TTL的最初设想是确定一个时间范围，超过此时间就把包丢弃。由于每个路由器都至少要把TTL域减一，TTL通常表示包在被丢弃前最多能经过的路由器个数。当记数到0时，路由器决定丢弃该包，并发送一个ICMP报文给最初的发送者。</p><h1 id="Http的请求有哪些"><a href="#Http的请求有哪些" class="headerlink" title="Http的请求有哪些"></a>Http的请求有哪些</h1><p>（1）POST请求：向服务器提交数据（上传表单和提交文件等等），数据包含在请求头中。参数不可见，长度不受限制（新增）</p><p>（2）GET请求：发送请求获取服务器上的资源。参数在url上，长度有限制，不安全（查询）</p><p>（3）HEAD请求：获取报文头（用于客户端查看服务器性能）</p><p>（4）PUT请求：更新服务器上的资源</p><p>（5）PATCH请求：对put的补充，局部更新</p><p>（6）OPTION请求：获取服务器支持的http请求方法，用来检查服务器的性能。（预请求，检测实际请求是否包含可以被浏览器接受）</p><p>（7）DELETE请求：从服务器删除特定的资源</p><p>（8）CONNECT请求：将连接改为管道方式的代理服务器。</p><p>（9）TRACE请求：回显服务器收到的请求，主要用于测试和诊断。</p><h2 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h2><ul><li><strong>get请求参数是添加到head中的，可以在url中看到，post请求是添加到请求体中的，在url中不可见</strong>。</li><li><strong>请求中的url长度限制</strong>，get请求的url长度要将请求参数的长度加进去，而post不用考虑请求参数的长度（<strong>是因为浏览器对url的限制</strong>）</li><li><strong>get请求产生一个数据包，post请求产生两个数据包</strong>（并不是所有的浏览器都发送两个包，火狐浏览器就发动一个包）。<ul><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</li><li>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li></ul></li><li><strong>get请求会被浏览器缓存下来，留下历史记录，而post默认不会。</strong></li><li><strong>get是获取数据，post是提交新增数据。</strong></li><li><strong>get安全性非常低，post安全性较高。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数相加</title>
    <link href="/2022/06/13/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2022/06/13/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–2（两数相加）"><a href="#leetCode–2（两数相加）" class="headerlink" title="leetCode–2（两数相加）"></a>leetCode–2（两数相加）</h1><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><p><img src="/2022/06/13/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/image-20220613161623648.png" alt="image-20220613161623648"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span><br>输出：<span class="hljs-comment">[7,0,8]</span><br>解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[0]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br></code></pre></td></tr></table></figure><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>定义一个新的链表，里面存放相加的值，最主要的一点，是对进位数的处理、。<strong>每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值。</strong></p><p>哪个部分进位，哪个部分是保留下来的。</p><p>对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。</p><p><strong>使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pre;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//表示进位</span><br>        <span class="hljs-keyword">while</span> (l1!=<span class="hljs-literal">null</span> || l2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//为空的数，用0填补</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> l1==<span class="hljs-literal">null</span>?<span class="hljs-number">0</span>:l1.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> l2==<span class="hljs-literal">null</span>?<span class="hljs-number">0</span>:l2.val;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> x+y+a;<br>            a = sum/<span class="hljs-number">10</span>;  <span class="hljs-comment">//进位的数</span><br>            sum = sum%<span class="hljs-number">10</span>; <span class="hljs-comment">//该位置保存的树</span><br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            cur = cur.next;<br>            <span class="hljs-keyword">if</span> (l1!=<span class="hljs-literal">null</span>) l1 = l1.next;<br>            <span class="hljs-keyword">if</span> (l2!=<span class="hljs-literal">null</span>) l2 = l2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a==<span class="hljs-number">1</span>) cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(a);<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数的三次方根</title>
    <link href="/2022/06/13/%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9/"/>
    <url>/2022/06/13/%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="790-数的三次方根"><a href="#790-数的三次方根" class="headerlink" title="790. 数的三次方根"></a>790. 数的三次方根</h1><p>给定一个浮点数 nn，求它的三次方根。</p><p><strong>输入格式</strong></p><p>共一行，包含一个浮点数 nn。</p><p><strong>输出格式</strong></p><p>共一行，包含一个浮点数，表示问题的解。</p><p>注意，结果保留 66 位小数。</p><p><strong>数据范围</strong></p><p>−10000≤n≤10000</p><p><strong>输入样例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1000</span>.<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">10</span>.<span class="hljs-number">000000</span><br></code></pre></td></tr></table></figure><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>二分法，对<code>−10000≤n≤10000</code>区间内进行遍历即可。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> scanner.nextDouble();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> -<span class="hljs-number">10000</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br>        <span class="hljs-comment">//因为保留6位所以取-8，比小数点后面的数要多二，比较保险</span><br>        <span class="hljs-keyword">while</span> (r-l&gt;<span class="hljs-number">1e-8</span>)&#123;<span class="hljs-comment">//浮点数二分的本质也是边界, 唯一区别是浮点数没有整除,当区间长度足够小时, 便可以认为是一个数</span><br>            <span class="hljs-type">double</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (mid*mid*mid&gt;=n) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid; <span class="hljs-comment">//为什么没有+1：因为是浮点数求解，l的结果也有可能是mid+0.1,所以不能+1.</span><br>        &#125;<br>        <span class="hljs-comment">//方式一：</span><br><span class="hljs-comment">//        DecimalFormat decimalFormat = new DecimalFormat();</span><br><span class="hljs-comment">//        decimalFormat.applyPattern(&quot;0.000000&quot;);</span><br><span class="hljs-comment">//        System.out.println(decimalFormat.format(l));</span><br>        <span class="hljs-comment">//方式二：</span><br>        System.out.println(String.format(<span class="hljs-string">&quot;%.6f&quot;</span>,l));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分法</category>
      
      <category>二分法练习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数的范围</title>
    <link href="/2022/06/13/%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4/"/>
    <url>/2022/06/13/%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="789-数的范围"><a href="#789-数的范围" class="headerlink" title="789. 数的范围"></a>789. 数的范围</h1><p>给定一个按照升序排列的长度为 nn 的整数数组，以及 qq 个查询。对于每个查询，返回一个元素 kk 的起始位置和终止位置（位置从 00 开始计数）。如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><p><strong>输入格式</strong></p><p>第一行包含整数 nn 和 qq，表示数组长度和询问个数。</p><p>第二行包含 nn 个整数（均在 1∼100001∼10000 范围内），表示完整数组。</p><p>接下来 qq 行，每行包含一个整数 kk，表示一个询问元素。</p><p><strong>输出格式</strong></p><p>共 qq 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><p><strong>数据范围</strong></p><p>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000</p><p><strong>输入样例：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">3 4<br>5 5<br><span class="hljs-string">-1</span> <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><h2 id="解法：二分法"><a href="#解法：二分法" class="headerlink" title="解法：二分法"></a>解法：二分法</h2><p><strong>使用两个模板。分别求出该数的左右坐标</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">Q</span> <span class="hljs-operator">=</span> <span class="hljs-number">10010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">K</span> <span class="hljs-operator">=</span> <span class="hljs-number">10010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> q[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[Q];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(System.out)));<br>        String s[] = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-type">int</span> n[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        n[<span class="hljs-number">0</span>] = Integer.parseInt(s[<span class="hljs-number">0</span>]); <span class="hljs-comment">//所有元素的个数</span><br>        n[<span class="hljs-number">1</span>] = Integer.parseInt(s[<span class="hljs-number">1</span>]); <span class="hljs-comment">//要检索的元素个数</span><br>        String ss[]  = br.readLine().split(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n[<span class="hljs-number">0</span>];i++)&#123;<br>            a[i] = Integer.parseInt(ss[i]);  <span class="hljs-comment">//所有的元素</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n[<span class="hljs-number">1</span>];i++)&#123;<br>            q[i] = Integer.parseInt(br.readLine());<span class="hljs-comment">//要检索的元素</span><br>        &#125;<br><br>        <span class="hljs-comment">//开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n[<span class="hljs-number">1</span>];j++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> n[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (a[mid] &gt;= q[j]) r = mid;<br>                <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (a[l]==q[j]) System.out.print(l+<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">else</span> System.out.print(-<span class="hljs-number">1</span>+<span class="hljs-string">&quot; &quot;</span>);<br>            l = <span class="hljs-number">0</span>;<br>            r = n[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (a[mid] &lt;= q[j]) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (a[l]==q[j]) System.out.print(l+<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">else</span> System.out.print(-<span class="hljs-number">1</span>+<span class="hljs-string">&quot; &quot;</span>);<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分法</category>
      
      <category>二分法练习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法模板</title>
    <link href="/2022/06/13/%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/06/13/%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="二分法的模板"><a href="#二分法的模板" class="headerlink" title="二分法的模板"></a>二分法的模板</h1><p><img src="/2022/06/13/%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF/image-20220613135821257.png" alt="image-20220613135821257"></p><h3 id="模板一："><a href="#模板一：" class="headerlink" title="模板一："></a>模板一：</h3><p>当mid在绿色区域，也就是 <code>a[mid]&gt;=target</code>。使用下列模板：</p><p>区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">way1</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (a[mid] &gt;= target) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="模板二"><a href="#模板二" class="headerlink" title="模板二"></a>模板二</h2><p>当min在红色区域，也就是a[mid]&lt;&#x3D;target.使用下列模板。</p><p>区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">way2</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (a[mid] &lt;= target) l = mid; <br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>二分法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo</title>
    <link href="/2022/06/12/Dubbo/"/>
    <url>/2022/06/12/Dubbo/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="分布式基础理论"><a href="#分布式基础理论" class="headerlink" title="分布式基础理论"></a>分布式基础理论</h2><p><strong>什么是分布式系统？</strong>  </p><blockquote><p>“分布式系统是若干独立计算机的集合， 这些计算机对于用户来说就像单个相关系统”  </p></blockquote><p>随着互联网的发展， 网站应用的规模不断扩大，   需要一个治理系统确保架构有条不紊的演进。  </p><p><strong>发展演变</strong></p><p><strong>（1）单一应用架构</strong></p><p>​当网站流量很小时， 只需一个应用， 将所有功能都部署在一起， 以减少部署节点和成本。 此时， 用于简化增删改查工作量的数据访问框架(ORM)是关键  </p><p><img src="/2022/06/12/Dubbo/image-20220612115631030.png" alt="image-20220612115631030"></p><p><strong>适用于小型网站， 小型管理系统， 将所有功能都部署到一个功能里， 简单易用。</strong><br><strong>缺点：</strong> </p><p>1、 性能扩展比较难<br>2、 协同开发问题<br>3、 不利于升级维护  </p><p><strong>（2）垂直应用架构</strong>  </p><p>​当访问量逐渐增大， 单一应用增加机器带来的加速度越来越小， 将应用拆成互不相干的几个应用，以提升效率。 此时， 用于加速前端页面开发的 Web 框架(MVC)是关键  </p><p><img src="/2022/06/12/Dubbo/image-20220612115640815.png" alt="image-20220612115640815"></p><p>通过切分业务来实现各个模块独立部署， 降低了维护和部署的难度， 团队各司其职更易管理，性能扩展也更方便， 更有针对性。<br><strong>缺点</strong>： 公用模块无法重复利用， 开发性的浪费  </p><p><strong>（3）分布式服务架构</strong>  </p><p>​当垂直应用越来越多， 应用之间交互不可避免， 将核心业务抽取出来， 作为独立的服务， 逐渐形成稳定的服务中心， 使前端应用能更快速的响应多变的市场需求。 此时， 用于提高业务复用及整合的分布式服务框架(RPC)是关键  </p><p><img src="/2022/06/12/Dubbo/image-20220612115649120.png" alt="image-20220612115649120"></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><strong>什么叫 RPC？</strong>  </p><pre><code class="hljs">    是指远程过程调用， 是一种进程间通信方式， 他是一种技术的思想，而不是规范。不用程序员显式编码这个远程调用的细节。 即程序员无论是调用本地的还是远程的函数， 本质上编写的调用代码基本相同  </code></pre><p>   <strong>（也就是服务器A中的方法想要调用服务器B 中的方法）</strong></p><p>**RPC 基本原理  **：</p><p><img src="/2022/06/12/Dubbo/image-20220612115902123.png" alt="image-20220612115902123"></p><p><strong>调用过程：</strong></p><p><img src="/2022/06/12/Dubbo/image-20220612115917798.png" alt="image-20220612115917798"></p><h2 id="Dubbo核心概念"><a href="#Dubbo核心概念" class="headerlink" title="Dubbo核心概念"></a>Dubbo核心概念</h2><p>​Apache Dubbo (incubating)  是一款高性能、 轻量级的开源 Java RPC 框架， 它提供了三大核心能力： <strong>面向接口的远程方法调用， 智能容错和负载均衡， 以及服务自动注册和发现</strong>  </p><p><strong>基本概念</strong></p><p><img src="/2022/06/12/Dubbo/image-20220612135446507.png" alt="image-20220612135446507"></p><p><strong>服务提供者（ Provider）</strong> ： 暴露服务的服务提供方， 服务提供者在启动时， 向注册中心注册自己提供的服务。  </p><p><strong>服务消费者（ Consumer）</strong> : 调用远程服务的服务消费方， 服务消费者在启动时， 向注册中心订阅自己所需的服务， 服务消费者， 从提供者地址列表中， 基于软负载均衡算法， 选一台提供者进行调用， 如果调用失败， 再选另一台调用。  </p><p><strong>注册中心（ Registry）</strong> ： 注册中心返回服务提供者地址列表给消费者， 如果有变更， 注册中心将基于长连接推送变更数据给消费者  </p><p><strong>监控中心（ Monitor） ：</strong> 服务消费者和提供者， 在内存中累计调用次数和调用时间， 定时每分钟发送一次统计数据到监控中心  </p><p><strong>调用关系说明：</strong></p><ul><li>服务容器负责启动， 加载， 运行服务提供者。  </li><li>服务提供者在启动时， 向注册中心注册自己提供的服务  </li><li>服务消费者在启动时， 向注册中心订阅自己所需的服务。  </li><li>注册中心返回服务提供者地址列表给消费者， 如果有变更， 注册中心将基于长连接推送变更数据给消费者  </li><li>服务消费者， 从提供者地址列表中， 基于软负载均衡算法， 选一台提供者进行调用， 如果调用失败， 再选另一台调用  </li><li>服务消费者和提供者， 在内存中累计调用次数和调用时间， 定时每分钟发送一次统计数据到监控中心</li></ul><h2 id="dubbo-环境搭建"><a href="#dubbo-环境搭建" class="headerlink" title="dubbo 环境搭建"></a>dubbo 环境搭建</h2><p><strong>（1）安装注册中心—zookeeper</strong></p><ul><li>下载zookeeper （网址 <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/%EF%BC%89">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/）</a></li><li>解压 zookeeper 解压运行 zkServer.cmd ， 初次运行会报错， 没有 zoo.cfg 配置文件</li><li>修改 zoo.cfg 配置文件：将 conf 下的 zoo_sample.cfg 复制一份改名为 zoo.cfg 即可。</li><li>dataDir&#x3D;.&#x2F; 临时数据存储的目录（可写相对路径）（dataDir&#x3D;..&#x2F;data）， clientPort&#x3D;2181 zookeeper 的端口号 ，修改完成后再次启动 zookeeper</li><li>使用 zkCli.cmd 测试</li></ul>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot连接Redis失败问题</title>
    <link href="/2022/06/12/SpringBoot%E8%BF%9E%E6%8E%A5Redis%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2022/06/12/SpringBoot%E8%BF%9E%E6%8E%A5Redis%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot集成Redis连接不上的问题"><a href="#SpringBoot集成Redis连接不上的问题" class="headerlink" title="SpringBoot集成Redis连接不上的问题"></a>SpringBoot集成Redis连接不上的问题</h1><p>问题描述<br>初学SpringBoot</p><p>当进行SpringBoot集成Redis时。测试向redis中添加String类型的数据，key&#x3D;name , value &#x3D; zlw。<br>但出现了一下错误：（Whitelabel Error Page）</p><p><img src="/2022/06/12/SpringBoot%E8%BF%9E%E6%8E%A5Redis%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220612105150148.png" alt="image-20220612105150148"></p><p>看控制台输出发现，大致应该是redis没有连接成功。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Servlet.service() <span class="hljs-keyword">for</span> servlet [dispatcherServlet] <span class="hljs-keyword">in</span> context <span class="hljs-keyword">with</span> <span class="hljs-type">path</span> [] threw <span class="hljs-keyword">exception</span> [Request processing failed; nested <span class="hljs-keyword">exception</span> <span class="hljs-keyword">is</span> org.springframework.data.redis.RedisConnectionFailureException: Unable <span class="hljs-keyword">to</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> Redis; nested <span class="hljs-keyword">exception</span> <span class="hljs-keyword">is</span> io.lettuce.core.RedisConnectionException: Unable <span class="hljs-keyword">to</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> <span class="hljs-number">192.168</span><span class="hljs-number">.86</span><span class="hljs-number">.129</span>/&lt;unresolved&gt;:<span class="hljs-number">6379</span>] <span class="hljs-keyword">with</span> root cause<br></code></pre></td></tr></table></figure><p>上网搜索了好多这个问题的错误，但好像都没有解决，不是自己的错误，但后来回想到，学习linux的时候，想要连接成功<strong>必须要关闭linux的防火墙才行。。。</strong></p><p>试一试</p><p><img src="/2022/06/12/SpringBoot%E8%BF%9E%E6%8E%A5Redis%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220612105210233.png" alt="image-20220612105210233"></p><p>可以看到防火墙已经关闭了，</p><p>哇~有新发现了，，虽然页面还是没有变化，但控制台的信息发生了变化。提示：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">WRONGPASS invalid username-password pair <span class="hljs-keyword">or</span> <span class="hljs-keyword">user</span> <span class="hljs-title">is</span> disabled.<br></code></pre></td></tr></table></figure><p>这应该是我的redis密码有问题。。</p><p>这应该是我的redis密码有问题。。</p><p>原来是我的密码加上了引号<br><strong>记住：密码要去掉引号！！！</strong></p><p>去掉双引号之后再次访问，成功！！</p><p><strong><img src="/2022/06/12/SpringBoot%E8%BF%9E%E6%8E%A5Redis%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/image-20220612105234002.png" alt="image-20220612105234002"></strong></p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
      <category>错误解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并二叉树</title>
    <link href="/2022/06/11/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/06/11/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–617（合并二叉树）"><a href="#leetCode–617（合并二叉树）" class="headerlink" title="leetCode–617（合并二叉树）"></a>leetCode–617（合并二叉树）</h1><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意</strong>: 合并过程必须从两个树的根节点开始。</p><p><strong>示例1：</strong></p><p><img src="/2022/06/11/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220611130151737.png" alt="image-20220611130151737"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root1 = <span class="hljs-comment">[1]</span>, root2 = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,2]</span><br></code></pre></td></tr></table></figure><h1 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h1><p>先判断两个树是否为空，如果不为空将，两棵树的根节点相加，再递归遍历两个数的左子树和右子树。</p><p><img src="/2022/06/11/%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/23fbf9388a4193475a7606a6390729f575e3329e0a810d2047682f701d3ddd1f-recursion.gif" alt="recursion.gif"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root1==<span class="hljs-literal">null</span> &amp;&amp; root2==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root1==<span class="hljs-literal">null</span> || root2==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root1==<span class="hljs-literal">null</span>?root2:root1;<br>        root1.val = root1.val+root2.val;<br>        <span class="hljs-comment">//合并该节点的左子树</span><br>        root1.left = mergeTrees(root1.left,root2.left);<br>        root1.right = mergeTrees(root1.right,root2.right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><p>使用一个队列，只要两个树的左节点不为空，就将节点放入队列中，同理右子树也一样，只要右子树节点不为空，就将右子树加入到队列中，。</p><p>同时再定义一个合并后的队列，存放合并后的树。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-comment">//迭代</span><br>        <span class="hljs-keyword">if</span> (root1==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span> (root2==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root1;<br>        Deque&lt;TreeNode&gt; merDeque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<span class="hljs-comment">//合并后的节点</span><br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();  <span class="hljs-comment">//两个树中的节点</span><br>        TreeNode mer= <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root1.val+root2.val);<br>        merDeque.addLast(mer);<br>        deque.addLast(root1);<br>        deque.addLast(root2);<br>        <span class="hljs-keyword">while</span> (!merDeque.isEmpty() &amp;&amp; !deque.isEmpty())&#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> merDeque.pop();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node1</span> <span class="hljs-operator">=</span> deque.pop();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node2</span> <span class="hljs-operator">=</span> deque.pop();<br>            <span class="hljs-comment">//对于左子树</span><br>            <span class="hljs-keyword">if</span> (node1.left!=<span class="hljs-literal">null</span> || node2.left!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//如果两棵树的左子树都不为空，则加入到队列中继续遍历相加</span><br>                <span class="hljs-keyword">if</span> (node1.left!=<span class="hljs-literal">null</span> &amp;&amp; node2.left!=<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(node1.left.val + node2.left.val);<br>                    node.left = leftNode;<br>                    merDeque.addLast(leftNode);<br>                    deque.addLast(node1.left);<br>                    deque.addLast(node2.left);<br>                &#125;<br>                <span class="hljs-comment">//如果有其中一个树的左子树为空，则合并后的左子树就是不为空的左子树，不用再进行遍历。</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node1.left==<span class="hljs-literal">null</span>)&#123;<br>                    node.left = node2.left;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(node2.left==<span class="hljs-literal">null</span>)&#123;<br>                    node.left = node1.left;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//对于右子树</span><br>            <span class="hljs-keyword">if</span> (node1.right!=<span class="hljs-literal">null</span> || node2.right!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">if</span> (node1.right!=<span class="hljs-literal">null</span> &amp;&amp; node2.right!=<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-comment">//如果两棵树的右子树都不为空，则加入到队列中继续遍历相加</span><br>                    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(node1.right.val + node2.right.val);<br>                    node.right = rightNode;<br>                    merDeque.addLast(rightNode);<br>                    deque.addLast(node1.right);<br>                    deque.addLast(node2.right);<br>                &#125;<br>                <span class="hljs-comment">//如果有其中一个树的右子树为空，则合并后的右子树就是不为空的右子树，不用再进行遍历。</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node1.right==<span class="hljs-literal">null</span>)&#123;<br>                    node.right = node2.right;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node2.right==<span class="hljs-literal">null</span>) &#123;<br>                    node.right = node1.right;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的直径</title>
    <link href="/2022/06/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2022/06/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–543（二叉树的直径）"><a href="#leetCode–543（二叉树的直径）" class="headerlink" title="leetCode–543（二叉树的直径）"></a>leetCode–543（二叉树的直径）</h1><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code class="hljs">      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>第一次读题时：想法：啊 求根节点的左右子树的最大深度之和。</p><p><strong>开始写代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> getCount(root.left) + getCount(root.right);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> getCount(root.left);<span class="hljs-comment">//左节点为根子树的深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span>  getCount(root.right);<span class="hljs-comment">//右节点为根子树的深度</span><br>        res = Math.max(res,l+r+<span class="hljs-number">1</span>);<span class="hljs-comment">//计算距离，保留计算过的最大值</span><br>        <span class="hljs-keyword">return</span> Math.max(l,r)+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回该节点为根的子树的深度</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但测试用例</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">[4,<span class="hljs-string">-7</span>,<span class="hljs-string">-3</span>,null,null,<span class="hljs-string">-9</span>,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-7</span>,<span class="hljs-string">-4</span>,null,6,null,<span class="hljs-string">-6</span>,<span class="hljs-string">-6</span>,null,null,0,6,5,null,9,null,null,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>,null,null,null,<span class="hljs-string">-2</span>]<br></code></pre></td></tr></table></figure><p>这个没有通过，感觉也没有毛病呀！</p><p>啊~看题解的解释才明白，题目中说的是，任意两个节点之间的距离，每个节点都可以当作根节点，所以要记录一下所求每个节点为根节点时，左右子树的最大深度和。才是最终的值。</p><p><img src="/2022/06/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/image-20220611104947156.png" alt="image-20220611104947156"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        getCount(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> getCount(root.left);<span class="hljs-comment">//左节点为根子树的深度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span>  getCount(root.right);<span class="hljs-comment">//右节点为根子树的深度</span><br>        res = Math.max(res,l+r);<span class="hljs-comment">//计算距离，保留计算过的最大值</span><br>        <span class="hljs-keyword">return</span> Math.max(l,r)+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回该节点为根的子树的深度</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比特位计数</title>
    <link href="/2022/06/09/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <url>/2022/06/09/%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="leetCode–338（比特位计数）"><a href="#leetCode–338（比特位计数）" class="headerlink" title="leetCode–338（比特位计数）"></a>leetCode–338（比特位计数）</h2><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><p>示例 1：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>解释：<br><span class="hljs-number">0</span> <span class="hljs-comment">--&gt; 0</span><br><span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 1</span><br><span class="hljs-number">2</span> <span class="hljs-comment">--&gt; 10</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入：n = <span class="hljs-number">5</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>解释：<br><span class="hljs-number">0</span> <span class="hljs-comment">--&gt; 0</span><br><span class="hljs-number">1</span> <span class="hljs-comment">--&gt; 1</span><br><span class="hljs-number">2</span> <span class="hljs-comment">--&gt; 10</span><br><span class="hljs-number">3</span> <span class="hljs-comment">--&gt; 11</span><br><span class="hljs-number">4</span> <span class="hljs-comment">--&gt; 100</span><br><span class="hljs-number">5</span> <span class="hljs-comment">--&gt; 101</span><br></code></pre></td></tr></table></figure><h1 id="解法一：Brian-Kernighan-算法"><a href="#解法一：Brian-Kernighan-算法" class="headerlink" title="解法一：Brian Kernighan 算法"></a>解法一：Brian Kernighan 算法</h1><p><strong>Brian Kernighan 算法：</strong> 当进行<code>x&amp;(x-1)</code>时，时删除<code>x</code>二进制位中最右侧的 1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countBits(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            res[i] = sal(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sal</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (a&gt;<span class="hljs-number">0</span>)&#123;<br>            a = a&amp;(a-<span class="hljs-number">1</span>);<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>位运算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉明距离</title>
    <link href="/2022/06/09/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
    <url>/2022/06/09/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–461（汉明距离）"><a href="#leetCode–461（汉明距离）" class="headerlink" title="leetCode–461（汉明距离）"></a>leetCode–461（汉明距离）</h1><p>两个整数之间的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p><p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p><p>示例 1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">1</span>, y = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">1</span>   (<span class="hljs-number">0 0 0 1</span>)<br><span class="hljs-number">4</span>   (<span class="hljs-number">0 1 0 0</span>)<br>       ↑   ↑<br>上面的箭头指出了对应二进制位不同的位置。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：x </span>=<span class="hljs-string"> 3, y = 1</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><h1 id="解法一：内置函数"><a href="#解法一：内置函数" class="headerlink" title="解法一：内置函数"></a>解法一：内置函数</h1><p><strong>汉明距离</strong>：就是两个二进制位中不同位置的数目。</p><p><strong>两个整数二进制位中不同的数目：就是两个数进行异或 ， 结果为 1 的数目。</strong></p><p>首先可以使用java中的内置方法，。<code>Integer.bitCount()</code>，用来求二进制中为1 的数目。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">//异或后求1的个数就是二进制中不同位置的个数，也就是汉明距离</span><br>        <span class="hljs-keyword">return</span> Integer.bitCount(x^y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解法二：移位实现位计数"><a href="#解法二：移位实现位计数" class="headerlink" title="解法二：移位实现位计数"></a>解法二：移位实现位计数</h1><p><img src="/2022/06/09/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/image-20220609220904552.png" alt="image-20220609220904552"></p><p><strong>我们可以不断地检查 s 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 s 整体右移一位，这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s&#x3D;0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">//异或，通过移位的方法计算1 的个数</span><br>        <span class="hljs-comment">//每次像右移动一位。如果最低位为1，则数量加1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x^y;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (a!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//判断最低为是否为1 </span><br>            <span class="hljs-keyword">if</span> ((a&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>) count++;<br>            a = a&gt;&gt;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解法三：Brian-Kernighan-算法"><a href="#解法三：Brian-Kernighan-算法" class="headerlink" title="解法三：Brian Kernighan 算法"></a>解法三：Brian Kernighan 算法</h1><p>在解法二的位移动方法中，对于 s&#x3D;(10001100)的情况，我们需要循环右移 8 次才能得到答案。而实际上如果我们可以跳过两个 11 之间的 00，直接对 11 进行计数，那么就只需要循环 33 次即可。</p><p>可以使用 Brian Kernighan 算法进行优化。</p><p><strong>Brian Kernighan 算法：</strong> 当进行<code>x&amp;(x-1)</code>时，时删除<code>x</code>二进制位中最右侧的 1 。</p><p>这样就大大减少了，对0 的移动次数</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">//异或 通过使用Brian Kernighan 算法，对移位算法进行优化</span><br>        <span class="hljs-comment">//因为移位要每次移动一位，但Brian Kernighan 算法时删除最后一个1，每次移动多位，直到遇到0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x^y;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (a!=<span class="hljs-number">0</span>)&#123;<br>            a = a&amp;(a-<span class="hljs-number">1</span>);<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>位运算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动零</title>
    <link href="/2022/06/09/%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2022/06/09/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–283（移动零）"><a href="#leetCode–283（移动零）" class="headerlink" title="leetCode–283（移动零）"></a>leetCode–283（移动零）</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><h1 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h1><p>定义两个指针，分别为左指针（l）和右指针（r）。</p><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (r&lt;n)&#123;<br>            <span class="hljs-keyword">if</span> (nums[r]!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[r];<br>                nums[r] = nums[l];<br>                nums[l] = t;<br>                l++;<br>            &#125;<br>            r++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>遍历数组，遇到不为0 的数则放入数组的最前面，遇到0则继续遍历。</p><p>放入的位置通过一个坐标（index）控制，进行向后移动，</p><p>最后将index到最后之间的数设置为0；</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]!=<span class="hljs-number">0</span>)&#123;<br>                nums[index] = nums[i];<br>                index++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index;i&lt;nums.length;i++)&#123;<br>            nums[index++] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>简单题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找到所有数组中消失的数字</title>
    <link href="/2022/06/09/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/06/09/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–448（找到所有数组中消失的数字）"><a href="#leetCode–448（找到所有数组中消失的数字）" class="headerlink" title="leetCode–448（找到所有数组中消失的数字）"></a>leetCode–448（找到所有数组中消失的数字）</h1><p>给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">4,3,2,7</span>,<span class="hljs-number">8,2,3,1</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1]</span><br>输出：<span class="hljs-comment">[2]</span><br></code></pre></td></tr></table></figure><h1 id="解法一：自己：借助额外的数组"><a href="#解法一：自己：借助额外的数组" class="headerlink" title="解法一：自己：借助额外的数组"></a>解法一：自己：借助额外的数组</h1><p><strong>代码为：</strong></p><p>遍历数组，将数组中的值，放入新数组所对应值下标的位置。再遍历数组，哪个下标没有值，说明哪个数没在数组中，加入到链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> res[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (res[nums[i]]==<span class="hljs-number">0</span>) &#123;<br>                res[nums[i]] = nums[i];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;res.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (res[i]==<span class="hljs-number">0</span>)&#123;<br>                list.add(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解法二：不适用额外数组"><a href="#解法二：不适用额外数组" class="headerlink" title="解法二：不适用额外数组"></a>解法二：不适用额外数组</h1><p>遍历数组中的元素，将元素值所对应下标的位置元素+n。</p><p>再遍历一遍数组，如果小于等于n。说明该坐标位置没有被加n，也就是所遍历的元素中没有这个坐标数、也就是没有这个元素。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//这个 %n 是为了当执行某个元素时数组已经改变了，所以%n 可以恢复为原来的值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (nums[i] - <span class="hljs-number">1</span>) % n;<br>            nums[x] = nums[x] + n;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]&lt;=n)&#123;<br>                list.add(i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>简单题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文链表</title>
    <link href="/2022/06/08/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/08/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–234（回文串）"><a href="#leetCode–234（回文串）" class="headerlink" title="leetCode–234（回文串）"></a>leetCode–234（回文串）</h1><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="/2022/06/08/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/image-20220608172057862.png" alt="image-20220608172057862"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2,2,1]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/06/08/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/image-20220608172106828.png" alt="image-20220608172106828"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="解法一：自己，使用栈完成"><a href="#解法一：自己，使用栈完成" class="headerlink" title="解法一：自己，使用栈完成"></a>解法一：自己，使用栈完成</h2><p>使用栈来存储遍历的链表，后依次出栈，和链表比较。</p><p>太低了吧！！ 哈哈哈  加油加油！</p><p><img src="/2022/06/08/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/image-20220608172154883.png" alt="image-20220608172154883"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (head.next.next==<span class="hljs-literal">null</span> &amp;&amp; head.val==head.next.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head.next.next==<span class="hljs-literal">null</span> &amp;&amp; head.val!=head.next.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Stack&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">null</span>)&#123;<br>            stack.push(cur);<br>            cur = cur.next;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (cur.val!=stack.peek().val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> stack.pop();<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>将链表中的元素存储在list集合中，定义两个前后指针，遍历list，对前后指针的元素进行比较。</p><ul><li>如果是回文链表，则前后指针指向的元素值相等，继续移动 l++,r–。</li><li>如果前后指针指向的元素不相等，则直接返回false。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//将链表中的值存储到list集合中，通过两个指针进行判断是否是回文链表</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">null</span>)&#123;<br>            list.add(cur.val);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> list.size()-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-keyword">if</span> (list.get(l)!=list.get(r)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l++;<br>                r--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：递归"><a href="#解法三：递归" class="headerlink" title="解法三：递归"></a>解法三：递归</h2><p>递归遍历每个节点，前面的那些节点已经在栈中存储了，当到最后一个节点的时候停止，和head元素比较。</p><p>通过递归的特性，是由后向前比较，而头结点也依次的向后移动。</p><blockquote><p>算法的正确性在于递归处理节点的顺序是相反的（回顾上面打印的算法），而我们在函数外又记录了一个变量，因此从本质上，我们同时在正向和逆向迭代匹配。</p></blockquote><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> ListNode t;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        t = head;<br>        <span class="hljs-keyword">return</span> check(head);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-keyword">if</span> (head!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//首先将指针指到了最后，而t还指向头节点，所以可以进行两两比较</span><br>            <span class="hljs-keyword">if</span> (!check(head.next)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//如果返回false，则直接返回给调用函数的fasle，也就是不是回文链表</span><br>            <span class="hljs-comment">//比较值是否相等，若不相等则直接返回false。</span><br>            <span class="hljs-keyword">if</span> (head.val!=t.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            t =t.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法四：快慢指针-链表逆转"><a href="#解法四：快慢指针-链表逆转" class="headerlink" title="解法四：快慢指针+链表逆转"></a>解法四：快慢指针+链表逆转</h2><p>使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p><p>将分割后的第二部分进行链表逆转，</p><p>比较两个部分的值，当后半部分到达末尾则比较完成。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//快慢指针，将链表分成两部分，得到的是第一部分的最后位置</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> merge(head);<br>        <span class="hljs-comment">//将后半部分进行链表逆转。</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> revList(first.next);<br>        <span class="hljs-comment">//通过两部分判断是否是回文</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> second;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (result &amp;&amp; p2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (p1.val!=p2.val) result =  <span class="hljs-literal">false</span>;<br>            p1 = p1.next;<br>            p2 = p2.next;<br>        &#125;<br>        <span class="hljs-comment">//还原列表，返回结果</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">//逆转后一部分的链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">revList</span><span class="hljs-params">(ListNode node)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> node;<br>        ListNode next;<br>        <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">null</span>)&#123;<br>            next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    <span class="hljs-comment">//返回分割点</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">//fast.next.next!=null:当链表元素位偶数的时候，fast.next!=null：当链表元素为奇数的时候</span><br>        <span class="hljs-keyword">while</span> (fast.next!=<span class="hljs-literal">null</span> &amp;&amp; fast.next.next!=<span class="hljs-literal">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-comment">//当fast到最后，slow正好到第一部分的最后。</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetCode</tag>
      
      <tag>回文串</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻转二叉树</title>
    <link href="/2022/06/08/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/06/08/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–226（翻转二叉树）"><a href="#leetCode–226（翻转二叉树）" class="headerlink" title="leetCode–226（翻转二叉树）"></a>leetCode–226（翻转二叉树）</h1><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="/2022/06/08/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220608164849018.png" alt="image-20220608164849018"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,7,1,3,6,9]</span><br>输出：<span class="hljs-string">[4,7,2,9,6,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/06/08/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220608164859662.png" alt="image-20220608164859662"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[2,1,3]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>遍历每个节点，转换每个节点的左右子树。这个想法要是想到了，代码会很简单，但没想到！</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//左右子树进行交换</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> root.left;<br>        root.left = root.right;<br>        root.right = t;<br>        <span class="hljs-comment">//遍历左节点，让左节点的左右子树交换</span><br>        <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>) invertTree(root.left);<br>        <span class="hljs-comment">//遍历右节点，让右节点的左右子树交换</span><br>        <span class="hljs-keyword">if</span> (root.right!=<span class="hljs-literal">null</span>) invertTree(root.right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><p>额外的数据结构–队列，来存放临时遍历到的元素。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//迭代</span><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty())&#123;<br>            <span class="hljs-comment">//每次从队列中拿出一个节点，并交换左右子树</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> stack.pop();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a.left;<br>            a.left = a.right;<br>            a.right = t;<br>            <span class="hljs-comment">//如果当前节点的左子树不为空，则放入队列等待后续处理</span><br>            <span class="hljs-keyword">if</span> (a.left!=<span class="hljs-literal">null</span>) stack.push(a.left);<br>            <span class="hljs-comment">//如果当前节点的右子树不为空，则放入队列等待后续处理</span><br>            <span class="hljs-keyword">if</span> (a.right!=<span class="hljs-literal">null</span>) stack.push(a.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetCode</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–206（反转链表）"><a href="#leetCode–206（反转链表）" class="headerlink" title="leetCode–206（反转链表）"></a>leetCode–206（反转链表）</h1><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220607214101110.png" alt="image-20220607214101110"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220607214111603.png" alt="image-20220607214111603"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><h2 id="解法一：迭代"><a href="#解法一：迭代" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h2><p>定于两个指针，第一个指针pre指向null，第二个cur指针指向head。</p><p>不断的遍历cur，终止条件是：cur为空。</p><p>每次遍历，将cur指向pre。之后pre等于cur。cur向后移动一位。以此类推。</p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif" alt="迭代.gif"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">null</span>)&#123;<br>            next = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220809172448973.png" alt="image-20220809172448973"></p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220809172531552.png" alt="image-20220809172531552"></p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220809172605118.png" alt="image-20220809172605118"></p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220809172645161.png" alt="image-20220809172645161"></p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220809172716283.png" alt="image-20220809172716283"></p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220809172747203.png" alt="image-20220809172747203"></p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220809172819709.png" alt="image-20220809172819709"></p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220809172855161.png" alt="image-20220809172855161"></p><h2 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/image-20220607220309617.png" alt="image-20220607220309617"></p><p><img src="/2022/06/07/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt="递归.gif"></p><p>递归的两个条件：</p><ol><li>终止条件是当前节点或者下一个节点&#x3D;&#x3D;null</li><li>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</li></ol><p>递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//递归</span><br>        <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">null</span> || head.next==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多数元素</title>
    <link href="/2022/06/07/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <url>/2022/06/07/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–169（多数元素）"><a href="#leetCode–169（多数元素）" class="headerlink" title="leetCode–169（多数元素）"></a>leetCode–169（多数元素）</h1><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,2,3]</span><br><span class="hljs-string">输出：3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,2,1,1,1,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>使用hash表来存放每个元素出现的次数，最后遍历hash 返回次数 &gt; len&#x2F;2 的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> n/<span class="hljs-number">2</span>;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(nums[i])) map.put(nums[i],map.get(nums[i])+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> map.put(nums[i],<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> key:map.keySet())&#123;<br>            <span class="hljs-keyword">if</span> (map.get(key)&gt;len) <span class="hljs-keyword">return</span> key;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：排序"><a href="#解法二：排序" class="headerlink" title="解法二：排序"></a>解法二：排序</h2><p>我的：先对数组进行排序，后进行遍历。。</p><p><strong>我：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> n/<span class="hljs-number">2</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i]==nums[i+<span class="hljs-number">1</span>]) count = count + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (count+<span class="hljs-number">1</span>&gt;len) <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>傻呀傻，，看看人家官方的。。充分利用了众数的性质。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">return</span> nums[nums.length/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>绝了！</p><h2 id="解法三：投票方法"><a href="#解法三：投票方法" class="headerlink" title="解法三：投票方法"></a>解法三：投票方法</h2><p>如果遇见相等的数加1，遇见不相等的数减 1.</p><p>众数个数至少比非众数多一，把COUNT加减当作一个众数抵消掉一个非众数，剩下的一定是众数。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//如果为0 说明众数和非众数打个平手 </span><br>            <span class="hljs-keyword">if</span> (count==<span class="hljs-number">0</span>) a = nums[i];<br>            <span class="hljs-comment">//相等加1 不相等减 1 </span><br>            count += (nums[i]==a)?<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法四：分治算法"><a href="#解法四：分治算法" class="headerlink" title="解法四：分治算法"></a>解法四：分治算法</h2><p>没看懂~~</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>简单题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相交链表</title>
    <link href="/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–160（相交链表）"><a href="#leetCode–160（相交链表）" class="headerlink" title="leetCode–160（相交链表）"></a>leetCode–160（相交链表）</h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/image-20220607193630170.png" alt="image-20220607193630170"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>自定义评测：</p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0</li><li>listA - 第一个链表</li><li>listB - 第二个链表</li><li>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数</li><li>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</li></ul><p><strong>示例 1：</strong></p><p><img src="/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/image-20220607193708779.png" alt="image-20220607193708779"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/image-20220607193725660.png" alt="image-20220607193725660"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/image-20220607193742275.png" alt="image-20220607193742275"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><h2 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p><strong>遍历链表A，将链表A中的元素存储到list集合中，再遍历链表B，如果遇到相等的节点，说明A和B相交了，如果没有相等的则返回null。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        List&lt;ListNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-keyword">while</span> (a!=<span class="hljs-literal">null</span>)&#123;<br>            list.add(a);<br>            a = a.next;<br>        &#125;<br>        a = headB;<br>        <span class="hljs-keyword">while</span> (a!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (list.contains(a))&#123;<br>                <span class="hljs-keyword">return</span> a;<br>            &#125;<br>            a = a.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>这个方法太巧妙了 ，，但看了好半天才看懂，太不好想了~~什么时候能一下就想出来这么好的解法呢。</p><p>先定义两个指针a 和 b。</p><p>a指向链表A的头结点，b指向链表B的头结点。</p><p>如果a为空说明链表A遍历完成，再让 a 指向 链表B的头结点，继续遍历。</p><p>如果 b 为空说明链表B遍历完成，再让b 指向链表A的头结点，继续遍历。</p><p>也就是说：</p><p>设链表A的节点数为  A ，设链表B的节点数为 B ，相交重合的节点数为 C。</p><ul><li>指针 <code>A</code> 先遍历完链表 <code>headA</code> ，再开始遍历链表 <code>headB</code> ，当走到 <code>node</code> 时，共走步数为：<em>a</em>+(<em>b</em>−<em>c</em>)</li><li>指针 <code>B</code> 先遍历完链表 <code>headB</code> ，再开始遍历链表 <code>headA</code> ，当走到 <code>node</code> 时，共走步数为：<em>b</em>+(<em>a</em>−<em>c</em>)</li></ul><p>此时  指针a和指针b重合，</p><p>如果两个链表相交：同时指向 node；</p><p>如果两个链表不相交：a和b同时为null；</p><p><strong>用图来表示：</strong></p><p><img src="/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/image-20220607195507599.png" alt="image-20220607195507599"></p><p><img src="/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/image-20220607195557243.png" alt="image-20220607195557243"></p><p><img src="/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/image-20220607195626818.png" alt="image-20220607195626818"></p><p><img src="/2022/06/07/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/image-20220607195722119.png" alt="image-20220607195722119"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        <span class="hljs-keyword">if</span> (headA==<span class="hljs-literal">null</span> ||headB==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> headA;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> headB;<br>        <span class="hljs-keyword">while</span> (a!=b)&#123;<br>            a = a==<span class="hljs-literal">null</span>?headB:a.next;<br>            b = b==<span class="hljs-literal">null</span>?headA:b.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis</title>
    <link href="/2022/06/07/redis/"/>
    <url>/2022/06/07/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="NoSQL数据库简介"><a href="#NoSQL数据库简介" class="headerlink" title="NoSQL数据库简介"></a>NoSQL数据库简介</h1><p><strong>主要解决性能问题</strong></p><p>Web1.0 的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。  </p><p>随着 Web2.0 的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。  </p><p><img src="/2022/06/07/redis/image-20220607112049192.png" alt="image-20220607112049192"></p><p><strong>NoSQL的出现解决了解决 CPU 及内存压力  和 IO 压力</strong>  </p><h2 id="解决-CPU-及内存压力"><a href="#解决-CPU-及内存压力" class="headerlink" title="解决 CPU 及内存压力"></a>解决 CPU 及内存压力</h2><p>将服务器进行 集群 或 分布式 部署，也就是多台服务器。通过nginx（负载均衡）进行分配服务器。</p><p>但存在一个问题，就是当用户访问服务器时，例如，分配了第一个服务器，将session存储到服务器1中，但当第二次访问时，分配的是第二台服务器，此时第二台服务器没有session对象，怎么办？</p><p><img src="/2022/06/07/redis/image-20220607112137349.png" alt="image-20220607112137349"></p><p><strong>NoSql可以减少cpu和io的压力，直接通过内存进行读取，nosql可以缓存数据库，提高访问速度，减少io操作</strong>  </p><h2 id="解决-IO-压力"><a href="#解决-IO-压力" class="headerlink" title="解决 IO 压力"></a>解决 IO 压力</h2><p><img src="/2022/06/07/redis/image-20220607124939134.png" alt="image-20220607124939134"></p><h2 id="NoSQL-数据库概述"><a href="#NoSQL-数据库概述" class="headerlink" title="NoSQL 数据库概述"></a>NoSQL 数据库概述</h2><p><strong>非关系型的数据库</strong>  。NoSQL 不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力。  </p><ul><li>不遵循 SQL 标准。</li><li>不支持 ACID。（原子性，一致性，隔离性，持久性  ）</li><li>远超于 SQL 的性能。</li></ul><p><strong>NoSQL 适用场景</strong>  </p><ul><li>数据高并发的读写</li><li>海量数据的读写</li><li>对数据高可扩展性的</li></ul><p><strong>NoSQL 不适用场景</strong>  </p><ul><li>需要事务支持</li><li>基于 sql 的结构化查询存储，处理复杂的关系,需要即席查询。</li><li><strong>（用不着 sql 的和用了 sql 也不行的情况，请考虑用 NoSql）</strong></li></ul><p><strong>NoSQL具体的数据库：</strong></p><p>（1）Memcache</p><ul><li>很早出现的 NoSql 数据库</li><li>数据都在内存中， 一般不持久化</li><li>支持简单的 key-value 模式， 支持类型单一 </li><li>一般是作为缓存数据库辅助持久化的数据库</li></ul><p><strong>（2） Redis</strong></p><ul><li>几乎覆盖了 Memcached 的绝大部分功能 </li><li>数据都在内存中， 支持持久化， 主要用作备份恢复</li><li>除了支持简单的 key-value 模式， 还支持多种数据结构 的存储， 比如 list、 set、 hash、 zset 等。</li><li>一般是作为缓存数据库辅助持久化的数据库</li></ul><p>（3） MongoDB</p><ul><li>数据都在内存中， 如果内存不足， 把不常用的数据保 存到硬盘 </li><li>虽 然 是 key-value 模 式 ， 但 是 对 value （ 尤 其 是 json） 提供了丰富的查询功能  支持二进制数据及大型对象 </li><li>可以根据数据的特点替代 RDBMS ， 成为独立的数据 库。 或者配合 RDBMS， 存储特定的数据。</li></ul><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><p>（1）在官网下载稳定版本</p><p>（2）<strong>在linux环境下进行安装</strong>，eg：redis-6.2.1.tar.gz  </p><p>（3）在linux环境 <strong>安装 C 语言的编译环境</strong>  </p><ul><li><code>yum install centos-release-scl scl-utils-build</code>  </li><li><code>yum install -y devtoolset-8-toolchain</code>  </li><li><code>scl enable devtoolset-8 bash</code></li></ul><p><strong>如果在Centos7下，直接安装gcc就可以</strong>  ：<code>yum install gcc</code></p><p>测试gcc版本 ： <code>gcc --version</code>  (GCC是一个用于linux系统下编程的编译器)</p><p><img src="/2022/06/07/redis/image-20220607125734946.png" alt="image-20220607125734946"></p><p>（4）<strong>下载 <code>redis-6.2.1.tar.gz</code> 放&#x2F;opt&#x2F;redis 目录  中（</strong>运用文件传输软件，例如Xftp）</p><p>（5）<strong>解压命令</strong>： <code>tar -zxvf redis-6.2.1.tar.gz</code>  </p><p>（6）<strong>解压完成后进入目录</strong>： cd redis-6.2.1  </p><p>（7）在 redis-6.2.1 目录下<strong>执行 <code>make</code> 命令</strong>  </p><p>（8）如果没有准备好 C 语言编译环境， <code>make</code> 会报错—<code>Jemalloc/jemalloc.h</code>： 没有那个文件  </p><ul><li>解决方案： 运行 <code>make distclean</code>  后再次执行<code>make</code>。</li></ul><p>（9）跳过 make test 继续执行: <strong><code>make install</code></strong>  </p><p>（10）<strong>默认的安装目录为</strong>：<code>/usr/local/bin</code>  </p><p>查看默认安装目录：  </p><ul><li><code>redis-benchmark</code>:性能测试工具，可以在自己本子运行，看看自己本子性能如何  </li><li><code>redis-check-aof</code>：修复有问题的 AOF 文件，rdb 和 aof 后面讲  </li><li><code>redis-check-dump</code>：修复有问题的 dump.rdb 文件  </li><li><code>redis-sentinel</code>：Redis 集群使用  </li><li><code>redis-server</code>：Redis 服务器启动命令  </li><li><code>redis-cli</code>：客户端，操作入口</li></ul><p>（11）<strong>后台启动</strong></p><ul><li>备份redis.conf     ：  <code>cp /opt/redis-3.2.5/redis.conf  /etc/ redis.conf</code></li></ul><p>（12）<strong>后台启动设置 daemonize no 改成 yes</strong>  ：修改 redis.conf(128 行)文件将里面的 daemonize no 改成 yes，让服务在后台启动  </p><p>（13）<strong>Redis 启动</strong>  ：  <code>redis-server /etc/redis.conf</code>  </p><p>（14）<strong>用客户端访问：</strong> <code>redis-cli</code>  </p><p>（15）<strong>测试验证：</strong> ping  </p><p><img src="/2022/06/07/redis/image-20220607131718774.png" alt="image-20220607131718774"></p><p>（16）<strong>Redis 关闭：</strong>  </p><ul><li>单实例关闭：redis-cli shutdown  </li><li>也可以通过关闭进程进行关闭</li></ul><p><img src="/2022/06/07/redis/image-20220607131847688.png" alt="image-20220607131847688"></p><p><strong>(17)给redis设置密码：</strong></p><p>修改redis.conf配置文件中的requirepass，修改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"># requirepass foobared<br>requirepass Zlw199805<br></code></pre></td></tr></table></figure><h1 id="Redis-介绍相关知识"><a href="#Redis-介绍相关知识" class="headerlink" title="Redis 介绍相关知识"></a>Redis 介绍相关知识</h1><p><strong>redis的底层使用的是：单线程+多路IO服用 ：</strong></p><p>Redis支持多线程主要有两个原因：</p><ul><li>可以充分利用服务器CPU资源，目前主线程只能利用一个核。</li><li>多线程任务可以分摊Redis同步IO读写负荷。</li></ul><p><img src="/2022/06/07/redis/image-20220607133051004.png" alt="image-20220607133051004"></p><p>黄牛还没有买到票的时候，123个人都在做自己的事情，而不是一直等待着票。</p><h1 id="Redis中常用的五大数据类型"><a href="#Redis中常用的五大数据类型" class="headerlink" title="Redis中常用的五大数据类型"></a>Redis中常用的五大数据类型</h1><h2 id="Redis键（Key）"><a href="#Redis键（Key）" class="headerlink" title="Redis键（Key）"></a>Redis键（Key）</h2><p>（1）<code>keys *</code> ：查看当前库中所有的key</p><p><img src="/2022/06/07/redis/image-20220607134236942.png" alt="image-20220607134236942"></p><p>（2）<code>exists key</code>  ：判断某个 key 是否存在  </p><p>（3）<code>type key</code>：查看你的 key 是什么类型  </p><p>（4）<code>del key</code> ：删除指定的 key 数据   &#x2F;  unlink key 根据 value 选择非阻塞删除  </p><p>（5）<code>expire key 10</code> ：10 秒钟：为给定的 key 设置过期时间  </p><p>（6）<code>ttl key</code> ：查看还有多少秒过期，-1 表示永不过期，-2 表示已过期  </p><p>（7）<code>select</code> ：命令切换数据库  </p><p>（8）<code>dbsize</code> ：查看当前数据库的 key 的数量  </p><p>（9） <code>flushdb</code> ：清空当前库  &#x2F;   <code>flushall</code> ：通杀全部库  </p><h2 id="Redis-字符串-String"><a href="#Redis-字符串-String" class="headerlink" title="Redis 字符串(String)"></a>Redis 字符串(String)</h2><p><strong>String 类型是二进制安全的（内容能用字符串表示的  ）。意味着 Redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。</strong>  </p><p><strong>String 类型是 Redis 最基本的数据类型，一个 Redis 中字符串 value 最多可以是 512M</strong>  </p><p><strong>常用命令</strong>  </p><p>（1）<code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对(内容能用字符串表示的)如果设置相同的key，则前面的value被覆盖  </p><p>（2）<code>get &lt;key&gt;</code>：查询对应键值  </p><p>（3）<code>append &lt;key&gt;&lt;value&gt;</code>：将给定的<value> 追加到原值的末尾  </value></p><p>（4）<code>strlen &lt;key&gt;</code>：获得值的长度  </p><p>（5）<code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 key 不存在时 设置 key 的值</p><p>（6）<code>incr &lt;key&gt;</code>    ：将 key 中储存的数字值增 1  （只能对数字操作）</p><p>（7）<code>decr &lt;key&gt;</code>  ：将 key 中储存的数字值减 1  （只能对数字操作）</p><p>（8） <code>incrby / decrby &lt;key&gt;&lt;步长&gt;</code>：将 key 中储存的数字值增减。自定义步长。  </p><ul><li>是原子性的：<strong>所谓原子操作是指不会被线程调度机制打断的操作；</strong>  </li><li>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li><li>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li><li>Redis 单命令的原子性主要得益于 Redis 的单线程。</li></ul><p>（9）<code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code>同时设置一个或多个 key-value 对  </p><p>（10）<code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....</code>同时获取一个或多个 value  </p><p>（11）<code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code>  ：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在  </p><p>（12）<code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>： 获得值的范围  </p><p>（13）<code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code> ：用 <value> 覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(索引从 0 开始)。  </key></value></p><p>（14）<code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒  </p><p>（15）<code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。  </p><p><strong>数据结构：</strong></p><p>String 的数据结构为<strong>简单动态字符串</strong>(Simple Dynamic String,缩写 SDS)。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.  </p><p><img src="/2022/06/07/redis/image-20220607151814346.png" alt="image-20220607151814346"></p><p>内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度len。如果字符串小于1M，扩容加倍现有的空间，如果超过1M，扩容时多扩1M空间。  需要注意的是字符串最大长度为 512M  。</p><h2 id="Redis-列表-List"><a href="#Redis-列表-List" class="headerlink" title="Redis 列表(List)"></a>Redis 列表(List)</h2><p><strong>单键多值  按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</strong>  <strong>它的底层实际是个双向链表，</strong>  </p><p><strong>常用命令</strong></p><p>（1）<code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边&#x2F;右边插入一个或多个值。<br>（2）<code>lpop/rpop &lt;key&gt;</code>从左边&#x2F;右边吐出一个值。值在键在，值光键亡。<br>（3）<code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>从<key1>列表右边吐出一个值，插到<key2>列表左边。<br>（4）<code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>按照索引下标获得元素(从左到右)<br>（5）<code>lrange mylist 0 -1 0</code> 左边第一个，-1 右边第一个，（0-1 表示获取所有）<br>（6）<code>lindex &lt;key&gt;&lt;index&gt;</code>按照索引下标获得元素(从左到右)<br>（7）<code>llen &lt;key&gt;</code>获得列表长度<br>（8）<code>linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;</code>在<value>的后面插入<newvalue>插入值<br>（9）<code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>从左边删除 n 个 value(从左到右)<br>（10）<code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>将列表 key 下标为 index 的值替换成 value  </newvalue></value></key2></key1></p><p><strong>数据结构</strong></p><p><strong>List 的数据结构为快速链表 quickList。</strong>  </p><p><strong>当列表元素比较少的情况下</strong>，会使用一块连续的内存存储，<strong>这个结构是 ziplist，也即是压缩列表</strong>  。因为普通的链表需要的附加指针空间太大，会比较浪费空间。  </p><p><strong>当数据量比较多的时候才会改成 quicklist</strong>  </p><p>Redis 将链表和 ziplist 结合起来组成了 quicklist。也<strong>就是将多个 ziplist 使用双向指针串起来使用</strong>。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h2 id="Redis-集合-Set"><a href="#Redis-集合-Set" class="headerlink" title="Redis 集合(Set)"></a>Redis 集合(Set)</h2><p>特殊之处在于 <strong>set 是可以自动排重的</strong></p><p> <strong>常用命令</strong>  </p><p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略<br><code>smembers &lt;key&gt;</code>取出该集合的所有值。<br><code>sismember &lt;key&gt;&lt;value&gt;</code>判断集合<key>是否为含有该<value>值，有 1，没有 0<br><code>scard&lt;key&gt;</code>返回该集合的元素个数。  </value></key></p><p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code> 删除集合中的某个元素。<br><code>spop &lt;key&gt;</code>随机从该集合中吐出一个值。<br><code>srandmember &lt;key&gt;&lt;n&gt;</code>随机从该集合中取出 n 个值。不会从集合中删除 。<br><code>smove &lt;source&gt;&lt;destination&gt;value</code> 把集合中一个值从一个集合移动到另一个集合<br><code>sinter &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的交集元素。<br><code>sunion &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的并集元素。<br><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的差集元素(key1 中的，不包含 key2 中的)  </p><p><strong>数据结构</strong>  </p><p>Set 数据结构是 dict 字典，<strong>字典是用哈希表实现的</strong>  </p><h2 id="Redis-哈希-Hash"><a href="#Redis-哈希-Hash" class="headerlink" title="Redis 哈希(Hash)"></a>Redis 哈希(Hash)</h2><p>Redis hash 是一个键值对集合。Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。  </p><p><img src="/2022/06/07/redis/image-20220607155709655.png" alt="image-20220607155709655"></p><p><strong>常用命令</strong></p><p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给<key>集合中的 <field>键赋值<value><br><code>hget &lt;key1&gt;&lt;field&gt;</code>：从<key1>集合<field>取出 value<br><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code> ：批量设置 hash 的值<br><code>hexists&lt;key1&gt;&lt;field&gt;</code>：查看哈希表 key 中， 给定域 field 是否存在。<br><code>hkeys &lt;key&gt;</code>：列出该 hash 集合的所有 field<br><code>hvals &lt;key&gt;：</code>列出该 hash 集合的所有 value<br><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;：</code>为哈希表 key 中的域 field 的值加上增量 1 -1<br><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;：</code>将哈希表 key 中的域 field 的值设置为 value ， 当且仅当域field 不存在  </field></key1></value></field></key></p><p><strong>数据结构</strong>  </p><p>Hash 类型对应的数据结构是两种： ziplist（压缩列表）， hashtable（哈希表）。 当field-value 长度较短且个数较少时， 使用 ziplist， 否则使用 hashtable。  </p><h2 id="Redis-有序集合-Zset-sorted-set"><a href="#Redis-有序集合-Zset-sorted-set" class="headerlink" title="Redis 有序集合 Zset(sorted set)"></a>Redis 有序集合 Zset(sorted set)</h2><p>Redis 有序集合 zset 与普通集合 set 非常相似，是一个<strong>没有重复元素</strong>的字符串集合。<br>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复了 。</strong>  </p><p><strong>常用命令</strong></p><p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code> [WITHSCORES]返回有序集 key 中，下标在<start><stop></stop>之间的元素带 WITHSCORES，可以让分数一起和值返回到结果集。<br><code>zrangebyscore key minmax [withscores] [limit offset count]</code>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br><code>zrevrangebyscore key maxmin [withscores] [limit offset count]</code>同上，改为从大到小排列。  </start></p><p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code> 为元素的 score 加上增量<br><code>zrem &lt;key&gt;&lt;value&gt;</code>删除该集合下，指定值的元素<br><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>统计该集合，分数区间内的元素个数<br><code>zrank &lt;key&gt;&lt;value&gt;</code>返回该值在集合中的排名，从 0 开始。  </p><p><strong>数据结构</strong></p><p><strong>zset 底层使用了两个数据结构</strong><br>（1）hash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。<br>（2）跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。  </p><p><img src="/2022/06/07/redis/image-20220607161721235.png" alt="image-20220607161721235"></p><p><strong>从此可以看出跳跃表比有序链表效率要高</strong>  </p><h1 id="Redis-的发布和订阅"><a href="#Redis-的发布和订阅" class="headerlink" title="Redis 的发布和订阅"></a>Redis 的发布和订阅</h1><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者(sub) 接收消息  </p><p>当订阅者订阅A频道时，A频道发布消息，则订阅者就能收到，如果B频道也发布消息，但订阅者没有订阅，则不会收到。</p><p><img src="/2022/06/07/redis/image-20220607221305094.png" alt="image-20220607221305094"></p><p><strong>命令行实现：</strong></p><p>（1）打开客户端的订阅 channel1  ：<code>SUBSCRIBE channel1</code>  </p><p>（2）打开另一个客户端，给 channel1 发布消息 hello  ：<code>publish channel1 hello</code>  </p><p>（3）打开第一个客户端，可以看到发送的消息</p><p><img src="/2022/06/07/redis/image-20220607221433147.png" alt="image-20220607221433147"></p><h1 id="Redis-新数据类型"><a href="#Redis-新数据类型" class="headerlink" title="Redis 新数据类型"></a>Redis 新数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p>​<strong>在我们平时的开发过程中，会有一些bool类型数据需要存取，比如用户一年的签到记录，签了是1，没签是0，要记录365天。如果使用普通的key&#x2F;value,每个用户要记录365个，当用户数上亿的时候，需要的存储空间是惊人的。</strong></p><p>​    <strong>为了解决这个问题，Redis提供了位图数据结构，这样每天的签到记录只占据了一个位，365天就是365个位，46个字节(一个稍长一点的字符串)就可以完全容纳下来，这就大大节约了存储空间。位图的最小单位是bit，每个bit的取值只能是0或1。</strong></p><p>Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：  </p><p>（1） Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ，但是它<strong>可以对字符串的位进行操作。</strong><br>（2） Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组，数组的每个单元只能存储 0 和 1， <strong>数组的下标在 Bitmaps 中叫做偏移量。</strong>  </p><p><strong>常用命令：</strong></p><p><strong>（1）setbit</strong>  </p><p><code>setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;</code>设置 Bitmaps 中某个偏移量的值（0 或 1）  </p><p>实例：<br>        每个独立用户是否访问过网站存放在 Bitmaps 中， 将访问的用户记做 1， 没有访问的用户记做 0， 用偏移量作为用户的 id。  </p><p>​设置键的第 offset 个位的值（从 0 算起） ， 假设现在有 20 个用户，userid&#x3D;1，6， 11， 15， 19 的用户对网站进行了访问  </p><p><img src="/2022/06/07/redis/image-20220608094714290.png" alt="image-20220608094714290"></p><p>注意：</p><p>​由于很多用户id 以一个指定数字（例如 10000） 开头， 直接将用户 id 和Bitmaps 的偏移量对应势必会造成一定的浪费， 通常的做法是每次做 setbit 操作时将用户 id 减去这个指定数字  。</p><p><strong>（2）getbit</strong></p><p><code>getbit&lt;key&gt;&lt;offset&gt;</code>获取 Bitmaps 中某个偏移量的值  </p><p>获取用户id为，15，18，19的用户是否被访问过，如果被访问过值为1，否则为0.</p><p><img src="/2022/06/07/redis/image-20220608100244411.png" alt="image-20220608100244411"></p><p><strong>（3）bitcount</strong>  </p><p>统计字符串被设置为 1 的 bit 数  一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，  </p><p>start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指 bit 组的字节的下标数，二者皆包含 。</p><p><code>bitcount&lt;key&gt;[start end]</code> 统计字符串从 start 字节到 end 字节比特值为 1 的数量  </p><p>实例：</p><p>计算用户 id 在第 1 个字节到第 3 个字  </p><p><img src="/2022/06/07/redis/image-20220608100603141.png" alt="image-20220608100603141"></p><p>举例： K1 【01000001 01000000 00000000 00100001】，对应【0，1，2，3】  </p><p><img src="/2022/06/07/redis/image-20220608101336433.png" alt="image-20220608101336433"></p><p><strong>（4）bitop</strong>  </p><p><code>bitop and(or/not/xor) &lt;destkey&gt; [key…]</code>   ： bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not<br>（非） 、 xor（异或） 操作并将结果保存在 destkey 中 。</p><p>**实例 ：计算出两天都访问过网站的用户数量  **（使用and）</p><p>​2020-11-04 日访问网站的 userid&#x3D;1,2,5,9。  </p><p>​2020-11-03 日访问网站的 userid&#x3D;0,1,4,9 。</p><p><img src="/2022/06/07/redis/image-20220608101808071.png" alt="image-20220608101808071"></p><p><img src="/2022/06/07/redis/image-20220608101833339.png" alt="image-20220608101833339"></p><p><strong>Bitmaps 与 set 对比</strong>  </p><p>​在存储活跃用户时，bitmap要比set要大大节省空间。</p><p><img src="/2022/06/07/redis/image-20220608101952307.png" alt="image-20220608101952307"></p><p>但如果该网站每天的独立访问用户很少， 例如只有 10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps 就不太合适了， 因为基本上大部分位都是 0  。</p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView 页面访问量）,可以使用 Redis 的 incr、incrby 轻松实现  </p><p><strong>用于解决UV（独立访客  ）独立 IP 数、搜索记录数等需要去重和计数的问题</strong>  </p><p>主要用于基数计算的操作，帮助去重复  ，解决去重问题，有很多方案，为什么要新提出一个这个，例如：</p><p>（1）数据存储在 MySQL 表中，使用 distinct count 计算不重复个数<br>（2）使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理  </p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。  </p><p><strong>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的</strong>  </p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。  </p><p><strong>什么是基数?</strong>  比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8},基数(不重复元素)为 5。 基数估计就是在误差可接受的范围内，快速计算基数。  </p><p><strong>命令：</strong></p><p><strong>（1）pfadd</strong></p><p><code>pfadd &lt;key&gt;&lt; element&gt; [element ...]</code> 添加指定元素到 HyperLogLog 中  </p><p><img src="/2022/06/07/redis/image-20220608103326649.png" alt="image-20220608103326649"></p><p><strong>（2）pfcount</strong>  </p><p><code>pfcount&lt;key&gt; [key ...]</code> 计算 HLL 的近似基数  ，可以计算多个</p><p><img src="/2022/06/07/redis/image-20220608103423389.png" alt="image-20220608103423389"></p><p><strong>（3）pfmerge</strong>  </p><p><code>pfmerge&lt;destkey&gt;&lt;sourcekey&gt; [sourcekey ...]</code> 将一个或多个 HLL 合并后的结果存储在另一个 HLL 中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得  </p><p><img src="/2022/06/07/redis/image-20220608103630010.png" alt="image-20220608103630010"></p><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><p>​<strong>该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。</strong>  </p><p><strong>命令</strong></p><p><strong>（1）getadd</strong></p><p><code>geoadd&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;&lt;member&gt; [longitude latitude member...]</code> 添加地理位置（经度，纬度，名称）  </p><p><img src="/2022/06/07/redis/image-20220608104301235.png" alt="image-20220608104301235"></p><p><strong>（2）geopos</strong></p><p><code>geopos &lt;key&gt;&lt;member&gt; [member...]</code> 获得指定地区的坐标值  </p><p><img src="/2022/06/07/redis/image-20220608104401677.png" alt="image-20220608104401677"></p><p><strong>（3）geodist</strong></p><p><code>geodist&lt;key&gt;&lt;member1&gt;&lt;member2&gt; [m|km|ft|mi ]</code> 获取两个位置之间的直线距离  </p><p><img src="/2022/06/07/redis/image-20220608104503203.png" alt="image-20220608104503203"></p><ul><li>m 表示单位为米[默认值]。</li><li>km 表示单位为千米。</li><li>mi 表示单位为英里。</li><li>ft 表示单位为英尺。</li><li>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</li></ul><p><strong>（4）georadius</strong>  </p><p><code>georadius&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;radius m|km|ft|mi</code>   以给定的经纬度为中心，找出某一半径内的元素  </p><p><img src="/2022/06/07/redis/image-20220608104720055.png" alt="image-20220608104720055"></p><h1 id="Redis-Jedis-测试"><a href="#Redis-Jedis-测试" class="headerlink" title="Redis_Jedis_测试"></a>Redis_Jedis_测试</h1><h2 id="Jedis-所需要的-jar-包"><a href="#Jedis-所需要的-jar-包" class="headerlink" title="Jedis 所需要的 jar 包"></a>Jedis 所需要的 jar 包</h2><p><strong>引入依赖：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>&lt;groupId&gt;redis.clients&lt;/groupId&gt;<br>&lt;artifactId&gt;jedis&lt;/artifactId&gt;<br>&lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p><strong>连接 Redis 注意事项</strong>  </p><ul><li>禁用 Linux 的防火墙：Linux(CentOS7)里执行命令</li><li>systemctl stop&#x2F;disable firewalld.service</li><li>redis.conf 中注释掉 bind 127.0.0.1 ,然后 protected-mode no</li></ul><h2 id="Jedis-常用操作"><a href="#Jedis-常用操作" class="headerlink" title="Jedis 常用操作"></a>Jedis 常用操作</h2><p><strong>（1）创建测试程序</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.86.129&quot;</span>,<span class="hljs-number">6379</span>);<br>    jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ping</span> <span class="hljs-operator">=</span> jedis.ping();<br>    System.out.println(ping);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）测试：Jedis-API: Key</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试：key</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testKey</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.86.129&quot;</span>,<span class="hljs-number">6379</span>);<br>    jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br>    jedis.set(<span class="hljs-string">&quot;k1&quot;</span>,<span class="hljs-string">&quot;v1&quot;</span>);<br>    jedis.set(<span class="hljs-string">&quot;k2&quot;</span>,<span class="hljs-string">&quot;v2&quot;</span>);<br>    jedis.set(<span class="hljs-string">&quot;k3&quot;</span>,<span class="hljs-string">&quot;v3&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">k2</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;k2&quot;</span>);<br>    System.out.println(k2);<br>    Set&lt;String&gt; keys = jedis.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String key:keys)&#123;<br>        System.out.print(key+<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>    System.out.println(jedis.exists(<span class="hljs-string">&quot;k3&quot;</span>));<br>    System.out.println(jedis.ttl(<span class="hljs-string">&quot;k2&quot;</span>));<span class="hljs-comment">//-1 表示永不过期</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/06/07/redis/image-20220608114625329.png" alt="image-20220608114625329"></p><p><strong>（3）测试 ：Jedis-API: String</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试String</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">StringTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.86.129&quot;</span>,<span class="hljs-number">6379</span>);<br>        jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br>        jedis.flushDB();<br>        jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;zlw&quot;</span>);<br>        jedis.mset(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;name2&quot;</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br>        List&lt;String&gt; name1 = jedis.mget(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-string">&quot;name2&quot;</span>);<br>        System.out.println(name1);<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> jedis.strlen(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(len);<br><br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/06/07/redis/image-20220608134027626.png" alt="image-20220608134027626"></p><p><strong>（4）测试：Jedis-API: List</strong>  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试list</span><br><span class="hljs-comment">     */</span><br>    @Test<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> ListTest()&#123;<br>        Jedis jedis = <span class="hljs-built_in">new</span> Jedis(&quot;192.168.86.129&quot;,<span class="hljs-number">6379</span>);<br>        jedis.auth(&quot;Zlw199805&quot;);<br>        jedis.flushDB();<br>        jedis.lpush(&quot;name&quot;, &quot;zlw&quot;, &quot;hhh&quot;, &quot;aaa&quot;);<br>        String <span class="hljs-type">name</span> = jedis.lpop(&quot;name&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">name</span>);<br>        List&lt;String&gt; name1 = jedis.lrange(&quot;name&quot;, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(name1);<br>        Long len = jedis.llen(&quot;name&quot;);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(len);<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/06/07/redis/image-20220608133540388.png" alt="image-20220608133540388"></p><p><strong>（5）测试：Jedis-API: set</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试set</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTest</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.86.129&quot;</span>,<span class="hljs-number">6379</span>);<br>    jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br>    jedis.flushDB();<br>    jedis.sadd(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;mary&quot;</span>,<span class="hljs-string">&quot;zlw&quot;</span>);<br>    Set&lt;String&gt; name = jedis.smembers(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(name);<br>    <span class="hljs-comment">//判断集合中是否有：zlw</span><br>    System.out.println(jedis.sismember(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zlw&quot;</span>));<br>    <span class="hljs-comment">//返回集合中元素的数量</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> jedis.scard(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(len);<br>    <span class="hljs-comment">//删除集合中的元素</span><br>    jedis.srem(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zlw&quot;</span>);<br>    Set&lt;String&gt; name1 = jedis.smembers(<span class="hljs-string">&quot;name&quot;</span>);<br>    System.out.println(name1);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/06/07/redis/image-20220608134454960.png" alt="image-20220608134454960"></p><p><strong>（6）测试：Jedis-API: hash</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试hash</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hashTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.86.129&quot;</span>,<span class="hljs-number">6379</span>);<br>        jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br>        jedis.flushDB();<br>        jedis.hset(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;zlw&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>);<br>        System.out.println(jedis.hget(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zlw&quot;</span>));<br>        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;22&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;mary&quot;</span>,<span class="hljs-string">&quot;21&quot;</span>);<br>        jedis.hset(<span class="hljs-string">&quot;names&quot;</span>,map);<br>        System.out.println(jedis.hmget(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;mary&quot;</span>));<br>        <span class="hljs-comment">//查看是否有元素</span><br>        System.out.println(jedis.hexists(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zlw&quot;</span>));<br>        <span class="hljs-comment">//列出key中所有的filed</span><br>        System.out.println(jedis.hkeys(<span class="hljs-string">&quot;names&quot;</span>));<br>        <span class="hljs-comment">//列出key中所有的value</span><br>        System.out.println(jedis.hvals(<span class="hljs-string">&quot;names&quot;</span>));<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/06/07/redis/image-20220608135235012.png" alt="image-20220608135235012"></p><p><strong>（7）测试：Jedis-API: zset</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 测试zset</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">zsetTest</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.86.129&quot;</span>,<span class="hljs-number">6379</span>);<br>       jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br>       jedis.flushDB();<br>       jedis.zadd(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-number">100d</span>,<span class="hljs-string">&quot;zlw&quot;</span>);<br>       jedis.zadd(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-number">99d</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>       jedis.zadd(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-number">98d</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>       System.out.println(jedis.zrange(<span class="hljs-string">&quot;name1&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>       System.out.println(jedis.zrangeByScore(<span class="hljs-string">&quot;name1&quot;</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>));<br>       jedis.zincrby(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>       System.out.println(jedis.zrange(<span class="hljs-string">&quot;name1&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="/2022/06/07/redis/image-20220608140213830.png" alt="image-20220608140213830"></p><h1 id="Redis-Jedis-实例-完成手机验证"><a href="#Redis-Jedis-实例-完成手机验证" class="headerlink" title="Redis_Jedis_实例 (完成手机验证)"></a>Redis_Jedis_实例 (完成手机验证)</h1><h2 id="完成一个手机验证码功能"><a href="#完成一个手机验证码功能" class="headerlink" title="完成一个手机验证码功能"></a>完成一个手机验证码功能</h2><p><strong>要求：</strong></p><p>（1）输入手机号，点击发送后随机生成 6 位数字码，2 分钟有效</p><p>（2）输入验证码，点击验证，返回成功或失败</p><p>（3）每个手机号每天只能输入 3 次  </p><p><strong>对要求的分析：</strong></p><p><img src="/2022/06/07/redis/image-20220608140726491.png" alt="image-20220608140726491"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zlw.redis;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneCode</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;18840613021&quot;</span>;<br>        <span class="hljs-type">PhoneCode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhoneCode</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> p.getCode();<br><span class="hljs-comment">//        String code = &quot;399675&quot;;</span><br><span class="hljs-comment">//        p.VerCode(phone,code);</span><br>        p.setCodeToRedis(phone,code);<br><br>    &#125;<br>    <span class="hljs-comment">//1.生成随机6位数字验证</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)&#123;<br>            code +=random.nextInt(<span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-comment">//将发送验证码的数量放入到redis中，设置每个手机一天之内只能发送三次，放入redis中，设置验证码在2分钟内有效，</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCodeToRedis</span><span class="hljs-params">(String phone, String code)</span>&#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.86.129&quot;</span>,<span class="hljs-number">6379</span>);<br>        jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br>        <span class="hljs-comment">//验证码数量的key</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">codeCount</span> <span class="hljs-operator">=</span> phone + <span class="hljs-string">&quot;:count&quot;</span>;<br>        <span class="hljs-comment">//验证码两分钟有效的key</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">codeVer</span> <span class="hljs-operator">=</span> phone + <span class="hljs-string">&quot;:ver&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (jedis.get(codeCount)==<span class="hljs-literal">null</span>)&#123;<br>            jedis.setex(codeCount,<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Integer.parseInt(jedis.get(codeCount) )&lt;=<span class="hljs-number">2</span>)&#123;<br>            jedis.incr(codeCount);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Integer.parseInt(jedis.get(codeCount) )&gt;<span class="hljs-number">2</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;今日发送已经超过三日，明日再来吧~~&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果发送失败了，就不会将验证码存入到redis中了，因此结束return;</span><br>        &#125;<br><br>        jedis.setex(codeVer,<span class="hljs-number">120</span>,code);<br>        jedis.close();<br>    &#125;<br><br>    <span class="hljs-comment">//验证 验证码和输入的是否相等</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">VerCode</span><span class="hljs-params">(String phone,String code)</span>&#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.86.129&quot;</span>,<span class="hljs-number">6379</span>);<br>        jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">codeVer</span> <span class="hljs-operator">=</span> phone + <span class="hljs-string">&quot;:ver&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code1</span> <span class="hljs-operator">=</span> jedis.get(codeVer);<br>        <span class="hljs-keyword">if</span> (code1.equals(code))&#123;<br>            System.out.println(<span class="hljs-string">&quot;成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;失败&quot;</span>);<br>        &#125;<br>        jedis.close();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Redis-与-Spring-Boot-整合"><a href="#Redis-与-Spring-Boot-整合" class="headerlink" title="Redis 与 Spring Boot 整合"></a>Redis 与 Spring Boot 整合</h1><p><strong>整合步骤：</strong></p><p><strong>（1）在 pom.xml 文件中引入 redis 相关依赖</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- redis --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!-- spring2.X 集成 redis 所需 common-pool2--&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;<br>&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;<br>&lt;version&gt;<span class="hljs-number">2.6</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p><strong>（2）application.properties 配置 redis 配置</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">#Redis 服务器地址<br>spring.redis.host=<span class="hljs-number">192.168</span><span class="hljs-number">.140</span><span class="hljs-number">.136</span><br>#Redis 服务器连接端口<br>spring.redis.port=<span class="hljs-number">6379</span><br>#Redis 数据库索引（ 默认为 <span class="hljs-number">0</span>）<br>spring.redis.database= <span class="hljs-number">0</span><br>#连接超时时间（ 毫秒）<br>spring.redis.timeout=<span class="hljs-number">1800000</span><br>#连接池最大连接数（ 使用负值表示没有限制）<br>spring.redis.lettuce.pool.max-active=<span class="hljs-number">20</span><br>#最大阻塞等待时间(负数表示没限制)<br>spring.redis.lettuce.pool.max-wait=-<span class="hljs-number">1</span><br>#连接池中的最大空闲连接<br>spring.redis.lettuce.pool.max-idle=<span class="hljs-number">5</span><br>#连接池中的最小空闲连接<br>spring.redis.lettuce.pool.min-idle=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>（3）添加 redis 配置类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableCaching</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br>        template.setConnectionFactory(factory);<br><span class="hljs-comment">//key 序列化方式</span><br>        template.setKeySerializer(redisSerializer);<br><span class="hljs-comment">//value 序列化</span><br>        template.setValueSerializer(jackson2JsonRedisSerializer);<br><span class="hljs-comment">//value hashmap 序列化</span><br>        template.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CacheManager <span class="hljs-title function_">cacheManager</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br>        RedisSerializer&lt;String&gt; redisSerializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>();<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br><span class="hljs-comment">//解决查询缓存转换异常的问题</span><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jackson2JsonRedisSerializer.setObjectMapper(om);<br><span class="hljs-comment">// 配置序列化（ 解决乱码的问题） ,过期时间 600 秒</span><br>        <span class="hljs-type">RedisCacheConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RedisCacheConfiguration.defaultCacheConfig().<br>                entryTtl(Duration.ofSeconds(<span class="hljs-number">600</span>)).<br>                serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)).<br>                serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))<br>                .disableCachingNullValues();<br>        <span class="hljs-type">RedisCacheManager</span> <span class="hljs-variable">cacheManager</span> <span class="hljs-operator">=</span> RedisCacheManager.builder(factory).cacheDefaults(config).build();<br>        <span class="hljs-keyword">return</span> cacheManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>瑞吉外卖中的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Redis配置类</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br><br>        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//默认的Key序列化器为：JdkSerializationRedisSerializer</span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br><br>        redisTemplate.setConnectionFactory(connectionFactory);<br><br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>（4）测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/redisTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisTestController</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><span class="hljs-meta">@GetMapping</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedis</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//设置值到 redis</span><br>redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br><span class="hljs-comment">//从 redis 获取值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String)redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">return</span> name;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>瑞吉外卖中的测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.DataType;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.*;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringDataRedisTest</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作String类型数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span>&#123;<br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;city123&quot;</span>,<span class="hljs-string">&quot;beijing&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;city123&quot;</span>);<br>        System.out.println(value);<br><br>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;key1&quot;</span>,<span class="hljs-string">&quot;value1&quot;</span>,<span class="hljs-number">10l</span>, TimeUnit.SECONDS);<br><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">aBoolean</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;city1234&quot;</span>, <span class="hljs-string">&quot;nanjing&quot;</span>);<br>        System.out.println(aBoolean);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作Hash类型数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">HashOperations</span> <span class="hljs-variable">hashOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash();<br><br>        <span class="hljs-comment">//存值</span><br>        hashOperations.put(<span class="hljs-string">&quot;002&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;xiaoming&quot;</span>);<br>        hashOperations.put(<span class="hljs-string">&quot;002&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>);<br>        hashOperations.put(<span class="hljs-string">&quot;002&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;bj&quot;</span>);<br><br>        <span class="hljs-comment">//取值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> (String) hashOperations.get(<span class="hljs-string">&quot;002&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(age);<br><br>        <span class="hljs-comment">//获得hash结构中的所有字段</span><br>        <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> hashOperations.keys(<span class="hljs-string">&quot;002&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Object key : keys) &#123;<br>            System.out.println(key);<br>        &#125;<br><br>        <span class="hljs-comment">//获得hash结构中的所有值</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> hashOperations.values(<span class="hljs-string">&quot;002&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Object value : values) &#123;<br>            System.out.println(value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作List类型的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testList</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ListOperations</span> <span class="hljs-variable">listOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForList();<br><br>        <span class="hljs-comment">//存值</span><br>        listOperations.leftPush(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>);<br>        listOperations.leftPushAll(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br><br>        <span class="hljs-comment">//取值</span><br>        List&lt;String&gt; mylist = listOperations.range(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (String value : mylist) &#123;<br>            System.out.println(value);<br>        &#125;<br><br>        <span class="hljs-comment">//获得列表长度 llen</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> listOperations.size(<span class="hljs-string">&quot;mylist&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lSize</span> <span class="hljs-operator">=</span> size.intValue();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lSize; i++) &#123;<br>            <span class="hljs-comment">//出队列</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> (String) listOperations.rightPop(<span class="hljs-string">&quot;mylist&quot;</span>);<br>            System.out.println(element);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作Set类型的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSet</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SetOperations</span> <span class="hljs-variable">setOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet();<br><br>        <span class="hljs-comment">//存值</span><br>        setOperations.add(<span class="hljs-string">&quot;myset&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>);<br><br>        <span class="hljs-comment">//取值</span><br>        Set&lt;String&gt; myset = setOperations.members(<span class="hljs-string">&quot;myset&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String o : myset) &#123;<br>            System.out.println(o);<br>        &#125;<br><br>        <span class="hljs-comment">//删除成员</span><br>        setOperations.remove(<span class="hljs-string">&quot;myset&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br><br>        <span class="hljs-comment">//取值</span><br>        myset = setOperations.members(<span class="hljs-string">&quot;myset&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String o : myset) &#123;<br>            System.out.println(o);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 操作ZSet类型的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZset</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ZSetOperations</span> <span class="hljs-variable">zSetOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForZSet();<br><br>        <span class="hljs-comment">//存值</span><br>        zSetOperations.add(<span class="hljs-string">&quot;myZset&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">10.0</span>);<br>        zSetOperations.add(<span class="hljs-string">&quot;myZset&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">11.0</span>);<br>        zSetOperations.add(<span class="hljs-string">&quot;myZset&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">12.0</span>);<br>        zSetOperations.add(<span class="hljs-string">&quot;myZset&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">13.0</span>);<br><br>        <span class="hljs-comment">//取值</span><br>        Set&lt;String&gt; myZset = zSetOperations.range(<span class="hljs-string">&quot;myZset&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (String s : myZset) &#123;<br>            System.out.println(s);<br>        &#125;<br><br>        <span class="hljs-comment">//修改分数</span><br>        zSetOperations.incrementScore(<span class="hljs-string">&quot;myZset&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">20.0</span>);<br><br>        <span class="hljs-comment">//取值</span><br>        myZset = zSetOperations.range(<span class="hljs-string">&quot;myZset&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (String s : myZset) &#123;<br>            System.out.println(s);<br>        &#125;<br><br>        <span class="hljs-comment">//删除成员</span><br>        zSetOperations.remove(<span class="hljs-string">&quot;myZset&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br><br>        <span class="hljs-comment">//取值</span><br>        myZset = zSetOperations.range(<span class="hljs-string">&quot;myZset&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (String s : myZset) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通用操作，针对不同的数据类型都可以操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCommon</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//获取Redis中所有的key</span><br>        Set&lt;String&gt; keys = redisTemplate.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>            System.out.println(key);<br>        &#125;<br><br>        <span class="hljs-comment">//判断某个key是否存在</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">itcast</span> <span class="hljs-operator">=</span> redisTemplate.hasKey(<span class="hljs-string">&quot;itcast&quot;</span>);<br>        System.out.println(itcast);<br><br>        <span class="hljs-comment">//删除指定key</span><br>        redisTemplate.delete(<span class="hljs-string">&quot;myZset&quot;</span>);<br><br>        <span class="hljs-comment">//获取指定key对应的value的数据类型</span><br>        <span class="hljs-type">DataType</span> <span class="hljs-variable">dataType</span> <span class="hljs-operator">=</span> redisTemplate.type(<span class="hljs-string">&quot;myset&quot;</span>);<br>        System.out.println(dataType.name());<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis_事务"></a>Redis_事务</h1><p><strong>Redis 事务的主要作用就是串联多个命令防止别的命令插队</strong>  </p><p>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec 后，Redis 会将之前的命令队列中的命令依次执行。组队的过程中可以通过 discard 来放弃组队。  </p><p><img src="/2022/06/07/redis/image-20220609132109343.png" alt="image-20220609132109343"></p><h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><ul><li>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消  </li><li>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚  。因此Redis不具有原子性。</li></ul><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p><strong>悲观锁</strong></p><p>​就是很悲观，每次去拿数据的时候都认为别人会修改<strong>，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁</strong>。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。  </p><p><img src="/2022/06/07/redis/image-20220609132539677.png" alt="image-20220609132539677"></p><p><strong>乐观锁</strong></p><p>就是很乐观，<strong>每次去拿数据的时候都认为别人不会修改，所以不会上锁</strong>，但是<strong>在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>  乐观锁适用于多读的应用类型，这样可以提高吞吐量。<strong>Redis 就是利用这种 check-and-set 机制实现事务的。</strong>  </p><h2 id="WATCH-key-key-…"><a href="#WATCH-key-key-…" class="headerlink" title="WATCH key [key …]"></a>WATCH key [key …]</h2><p>在执行 multi 之前，先执行 watch key1 [key2],可以监视一个(或多个) key ，<strong>如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</strong>  </p><p><strong>unwatch</strong>  ：取消 WATCH 命令对所有 key 的监视  </p><h2 id="Redis事务的相关指令"><a href="#Redis事务的相关指令" class="headerlink" title="Redis事务的相关指令"></a>Redis事务的相关指令</h2><p>（1）WATCH命令：乐观锁，可以为Redis事务提供check-and-set(CAS)行为。可以监控一个或多个键，一旦有一个被修改和删除，之后的事务不会执行。<br>（2）MULTI：开启一个事务，MULTI执行后，客户端可以向服务器发送多条命令，这些命令不会立即执行，而时被放入到一个队列中，当EXEC命令被调用时，所有的队列命令才会执行。</p><p>（3）EXEC：执行事务块内的命令，返回事务块内所有命令的返回值，按命令执行先后顺序排列，操作被打断时，返回nil。</p><p>（4）UNWATCH：可以取消watch对所有key的监控。</p><h2 id="Redis-事务三特性"><a href="#Redis-事务三特性" class="headerlink" title="Redis 事务三特性"></a>Redis 事务三特性</h2><p>（1）单独的隔离操作</p><ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li></ul><p>（2）没有隔离级别的概念  </p><ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul><p>（3）不保证原子性  </p><ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><h1 id="Redis-事务-秒杀案例"><a href="#Redis-事务-秒杀案例" class="headerlink" title="Redis-事务-秒杀案例"></a>Redis-事务-秒杀案例</h1><p>最基本的案例：最基本的代码：</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//秒杀过程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doSecKill</span><span class="hljs-params">(String uid,String prodid)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>   <span class="hljs-comment">//1.判断uid和proid是否为空，如果为空则不能秒杀</span><br>   <span class="hljs-keyword">if</span> (uid==<span class="hljs-literal">null</span> || prodid==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-comment">//设置key，产品的key和用户的key</span><br>   <span class="hljs-type">String</span> <span class="hljs-variable">proKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sk:&quot;</span> + prodid + <span class="hljs-string">&quot;:pt&quot;</span>;<br>   <span class="hljs-type">String</span> <span class="hljs-variable">usrKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sk:&quot;</span> + uid + <span class="hljs-string">&quot;:pt&quot;</span>;<br><br>   <span class="hljs-comment">//判断库存是否为null，null证明秒杀没有开始</span><br>   <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.86.129&quot;</span>,<span class="hljs-number">6379</span>);<br>   jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br>   <span class="hljs-keyword">if</span> (jedis.get(proKey)==<span class="hljs-literal">null</span>)&#123;<br>      System.out.println(<span class="hljs-string">&quot;秒杀还没有开始&quot;</span>);<br>      jedis.close();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>   <span class="hljs-comment">//判断库存是否够用，小于1 证明秒杀完成</span><br>   <span class="hljs-keyword">if</span> (Integer.parseInt(jedis.get(proKey) )&lt;=<span class="hljs-number">0</span>)&#123;<br>      System.out.println(<span class="hljs-string">&quot;秒杀结束&quot;</span>);<br>      jedis.close();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br><br>   <span class="hljs-comment">//判断用户是否已经秒杀过一次，同一个用户只能秒杀一次</span><br>   <span class="hljs-keyword">if</span> (jedis.sismember(usrKey,uid))&#123;<br>      System.out.println(<span class="hljs-string">&quot;该用户已经秒杀完成，不可以重复秒杀&quot;</span>);<br>      jedis.close();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br><br>   <span class="hljs-comment">//进行秒杀商品数量减1</span><br>   jedis.decr(proKey);<br>   <span class="hljs-comment">//加入用户</span><br>   jedis.sadd(usrKey,uid);<br>   System.out.println(<span class="hljs-string">&quot;秒杀成功！&quot;</span>);<br>   jedis.close();<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>但在以上的这段代码中，会发生连接超时和超卖问题（库存存在负数了）。</strong></p><p><strong>（1）修改连接超时问题：</strong></p><p>​通过数据库连接池实现：</p><p><strong>redis数据库连接池：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisPoolUtil</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">JedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">JedisPoolUtil</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> JedisPool <span class="hljs-title function_">getJedisPoolInstance</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == jedisPool) &#123;<br>         <span class="hljs-keyword">synchronized</span> (JedisPoolUtil.class) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == jedisPool) &#123;<br>               <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>               poolConfig.setMaxTotal(<span class="hljs-number">200</span>);<br>               poolConfig.setMaxIdle(<span class="hljs-number">32</span>);<br>               poolConfig.setMaxWaitMillis(<span class="hljs-number">100</span>*<span class="hljs-number">1000</span>);<br>               poolConfig.setBlockWhenExhausted(<span class="hljs-literal">true</span>);<br>               poolConfig.setTestOnBorrow(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// ping  PONG</span><br>             <br>               jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig, <span class="hljs-string">&quot;192.168.86.129&quot;</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">60000</span> );<br>            &#125;<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> jedisPool;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(JedisPool jedisPool, Jedis jedis)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != jedis) &#123;<br>         jedisPool.returnResource(jedis);<br>      &#125;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>将秒杀系统中的jedis对象，通过数据库连接池创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Jedis jedis = new Jedis(&quot;192.168.86.129&quot;,6379);</span><br><span class="hljs-comment">//jedis.auth(&quot;Zlw199805&quot;);</span><br><span class="hljs-comment">//通过连接池实现</span><br><span class="hljs-type">JedisPool</span> <span class="hljs-variable">jedisPoolInstance</span> <span class="hljs-operator">=</span> JedisPoolUtil.getJedisPoolInstance();<br><span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisPoolInstance.getResource();<br>jedis.auth(<span class="hljs-string">&quot;Zlw199805&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>（2）超卖问题</strong></p><p><strong>使用事务中的乐观锁监视即可。</strong></p><p><strong>代码为：</strong></p><ul><li><p>第一步监视商品的数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//监视商品的数量</span><br>jedis.watch(proKey);<br></code></pre></td></tr></table></figure></li><li><p>第二步：增加事务，商品数量减1 ，增加用户，执行事务，判断事务执行是否失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//增加事务</span><br><span class="hljs-type">Transaction</span> <span class="hljs-variable">multi</span> <span class="hljs-operator">=</span> jedis.multi();<br><span class="hljs-comment">//进行秒杀商品数量减1</span><br><span class="hljs-comment">//jedis.decr(proKey);</span><br><span class="hljs-comment">//减少库存</span><br>multi.decr(proKey);<br><span class="hljs-comment">//加入用户</span><br><span class="hljs-comment">//jedis.sadd(usrKey,uid);</span><br><span class="hljs-comment">//增加成功的用户</span><br>multi.sadd(usrKey,uid);<br><br><span class="hljs-comment">//执行事务</span><br>List&lt;Object&gt; exec = multi.exec();<br><span class="hljs-comment">//判断事务提交是否失败</span><br><span class="hljs-keyword">if</span> (exec==<span class="hljs-literal">null</span> ||exec.size()==<span class="hljs-number">0</span>)&#123;<br>System.out.println(<span class="hljs-string">&quot;秒杀结束了&quot;</span>);<br>jedis.close();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>（3）但使用乐观锁会产生数据遗留问题。因为乐观锁，当数据修改时，会改变版本号，其他的用户不能秒杀，所以出现库存遗留</strong></p><p><strong>使用LUA脚本解决库存遗留问题</strong><br>（LUA：是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。）</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">local userid=KEYS[<span class="hljs-number">1</span>];<br>local prodid=KEYS[<span class="hljs-number">2</span>];<br>local qtkey=<span class="hljs-string">&quot;sk:&quot;</span>..prodid..<span class="hljs-string">&quot;:qt&quot;</span>;<br>local usersKey=<span class="hljs-string">&quot;sk:&quot;</span>..prodid.<span class="hljs-string">&quot;:usr&#x27;;</span><br><span class="hljs-string">local userExists=redis.call(&quot;</span>sismember<span class="hljs-string">&quot;,usersKey,userid);</span><br><span class="hljs-string">if tonumber(userExists)==1 then</span><br><span class="hljs-string">return 2;</span><br><span class="hljs-string">end</span><br><span class="hljs-string">local num= redis.call(&quot;</span>get<span class="hljs-string">&quot; ,qtkey);</span><br><span class="hljs-string">if tonumber(num)&lt;=0 then</span><br><span class="hljs-string">return 0;</span><br><span class="hljs-string">else</span><br><span class="hljs-string">redis.call(&quot;</span>decr<span class="hljs-string">&quot;,qtkey);</span><br><span class="hljs-string">redis.call(&quot;</span>sadd<span class="hljs-string">&quot;,usersKey,userid);</span><br><span class="hljs-string">end</span><br><span class="hljs-string">return 1;</span><br></code></pre></td></tr></table></figure><h1 id="Redis-持久化之-RDB"><a href="#Redis-持久化之-RDB" class="headerlink" title="Redis 持久化之 RDB"></a>Redis 持久化之 RDB</h1><h2 id="为什么要持久化？"><a href="#为什么要持久化？" class="headerlink" title="为什么要持久化？"></a>为什么要持久化？</h2><p>为了能够重用Redis数据，或者防止系统故障，我们需要将Redis中的数据写入到磁盘中，即持久化。</p><p><strong>持久化：redis可以写到硬盘中。。</strong></p><blockquote><p>RDB是持久化方式，按照一定的时间间隔将内存的数据以快照的形式保存到硬盘，恢复时将快照读取到内存，</p></blockquote><h2 id="RDB是什么？"><a href="#RDB是什么？" class="headerlink" title="RDB是什么？"></a>RDB是什么？</h2><p>在<strong>指定的时间间隔</strong>内将内存中的<strong>数据集快照写入磁盘</strong>， 也就是行话讲的 Snapshot 快照，它恢复时是将快照文件直接读到内存里  </p><p><img src="/2022/06/07/redis/image-20220609193324763.png" alt="image-20220609193324763"></p><h2 id="备份是如何进行的？"><a href="#备份是如何进行的？" class="headerlink" title="备份是如何进行的？"></a>备份是如何进行的？</h2><p>Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何 IO 操作的，  </p><p><img src="/2022/06/07/redis/image-20220609160158010.png" alt="image-20220609160158010"></p><p><strong>Fork 的作用是复制一个与当前进程一样的进程。</strong>新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程  </p><h2 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h2><p><strong>优点：</strong></p><ul><li>适合大规模的数据恢复  </li><li>对数据完整性和一致性要求不高更适合使用  </li><li>节省磁盘空间  </li><li>恢复速度快</li></ul><p><strong>缺点：</strong></p><ul><li>Fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑  </li><li>虽然 Redis 在 fork 时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。  </li><li>备份周期在一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改</li></ul><h2 id="rbd的备份"><a href="#rbd的备份" class="headerlink" title="rbd的备份"></a>rbd的备份</h2><p>（1）先通过 config get dir 查询 rdb 文件的目录  </p><p>（2）将*.rdb 的文件拷贝到别的地方  eg:cp dump.rdb d.rdb</p><p>（3）rdb的恢复</p><ul><li><p>关闭 Redis  ，删除dump.rdb</p></li><li><p>先把备份的文件拷贝到工作目录下 cp d.rdb dump.rdb  </p></li><li><p>启动 Redis, 备份数据会直接加载  </p></li><li><p><img src="/2022/06/07/redis/image-20220609163844921.png" alt="image-20220609163844921"></p><p><img src="/2022/06/07/redis/image-20220609163802517.png" alt="image-20220609163802517"></p></li></ul><p><img src="/2022/06/07/redis/image-20220609163732378.png" alt="image-20220609163732378"></p><h1 id="Redis-持久化之-AOF"><a href="#Redis-持久化之-AOF" class="headerlink" title="Redis 持久化之 AOF"></a>Redis 持久化之 AOF</h1><p>AOF 持久化以日志的形式记录服务器所处理的每一个写、删除操作，但查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作。</p><p>AOF采用文件追加方式，<strong>文件越来越大，为避免出现这种情况，新增了重写机制</strong>，当AOF文件的大小超过所设定的阈值，<strong>Redis就会启动AOF文件的内存压缩，只保留可以恢复数据的最小指令集。</strong></p><p><img src="/2022/06/07/redis/image-20220609193655926.png" alt="image-20220609193655926"></p><h2 id="AOF-持久化流程"><a href="#AOF-持久化流程" class="headerlink" title="AOF 持久化流程"></a>AOF 持久化流程</h2><p>（1）客户端的请求写命令会被 append 追加到 AOF 缓冲区内；<br>（2）AOF 缓冲区根据 AOF 持久化策略[always,everysec,no]将操作 sync 同步到磁盘的AOF 文件中；<br>（3）AOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 rewrite 重写，压缩AOF 文件容量；  </p><p>（4）Redis 服务重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的；  </p><h2 id="AOF-启动-x2F-修复-x2F-恢复"><a href="#AOF-启动-x2F-修复-x2F-恢复" class="headerlink" title="AOF 启动&#x2F;修复&#x2F;恢复"></a>AOF 启动&#x2F;修复&#x2F;恢复</h2><ul><li><p>AOF 的备份机制和性能虽然和 RDB 不同, 但是备份和恢复的操作同 RDB 一样，都是拷贝备份文件，需要恢复时再拷贝到 Redis 工作目录下，启动系统即加载  </p></li><li><p>正常恢复  </p><ul><li>修改默认的 appendonly no，改为 yes  </li><li>将有数据的 aof 文件复制一份保存到对应目录(查看目录：config get dir)  </li><li>恢复：重启 redis 然后重新加载</li></ul></li><li><p>异常恢复  </p><ul><li>修改默认的 appendonly no，改为 yes  </li><li>如遇到 AOF 文件损坏，通过&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-check-aof–fix appendonly.aof 进行恢复  </li><li>备份被写坏的 AOF 文件  </li><li>恢复：重启 redis，然后重新加载</li></ul></li></ul><h2 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h2><p><strong>优势</strong>  </p><ul><li>备份机制更稳健，丢失数据概率更低  </li><li>可读的日志文本，通过操作 AOF 稳健，可以处理误操作。</li></ul><p><strong>劣势</strong>  </p><ul><li>比起 RDB 占用更多的磁盘空间。  </li><li>恢复备份速度要慢。  </li><li>每次读写都同步的话，有一定的性能压力  </li><li>存在个别 Bug，造成恢复不能。</li></ul><h1 id="对于持久化方式官网的建议"><a href="#对于持久化方式官网的建议" class="headerlink" title="对于持久化方式官网的建议"></a>对于持久化方式官网的建议</h1><ul><li>官方推荐两个都启用。</li><li>如果对数据不敏感，可以选单独用 RDB。</li><li>不建议单独用 AOF，因为可能会出现 Bug。</li><li>如果只是做纯内存缓存，可以都不用。</li></ul><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主机数据更新后根据配置和策略， 自动同步到备机的 master&#x2F;slaver 机制，<strong>Master 以写为主，Slave 以读为主</strong>  </p><h2 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h2><ul><li>读写分离，性能扩展  </li><li>容灾快速恢复  （当一台从机挂掉之后，其他从机能快速提供服务  ）</li><li><img src="/2022/06/07/redis/image-20220610102855173.png" alt="image-20220610102855173"></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><img src="/2022/06/07/redis/image-20220610102915397.png" alt="image-20220610102915397"></p><p><img src="/2022/06/07/redis/image-20220610104030188.png" alt="image-20220610104030188"></p><p>info replication<br><strong>打印主从复制的相关信息</strong></p><p><img src="/2022/06/07/redis/image-20220610111351081.png" alt="image-20220610111351081"></p><p><strong>配从(库)不配主(库)</strong>  </p><p><code>slaveof &lt;ip&gt;&lt;port&gt;</code>  ：主服务器的ip和端口。</p><p><strong>在主机上写，在从机上可以读取数据</strong>  </p><p><strong>主机挂掉，重启就行，一切如初</strong>  </p><p><strong>从机重启需重设：slaveof 127.0.0.1 6379</strong>  </p><h2 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h2><p>从机不可以写数据，</p><p>主机shutdown后，从机还是原地待命，不会上位变为主机。</p><p>主机又回来之后，主机新增记录，从机还能顺利复制，</p><p>其中一台从机down后，从新开启，重设<code>slaveof 127.0.0.1 6379</code>  ，依旧可以复制主机中的全部数据，。</p><h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p>其中一个从机可以作为其他其他从机的主机，。同样可以接受其他从机的连接和请求，可以有效减轻master’写的压力。<strong>也就是一态主机只写到一台从机，而一台从机下面右好多从机（缺点就是，唯一的这台与主机交互的从机一旦down掉，则后面的那些从机都没办法复制）</strong></p><p>**用 <code>slaveof &lt;ip&gt;&lt;port&gt;**</code>  </p><p><strong>中途变更转向:会清除之前的数据，重新建立拷贝最新的</strong>  </p><p><strong>风险是一旦某个 slave 宕机，后面的 slave 都没法备份</strong>  </p><p><strong>主机挂了，从机还是从机，无法写数据了</strong>  </p><p><img src="/2022/06/07/redis/image-20220610113123157.png" alt="image-20220610113123157"></p><h2 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h2><p><strong>当一个 master 宕机后，后面的 slave 可以立刻升为 master，其后面的 slave 不用做任何修改。</strong></p><p>  <strong>用 <code>slaveof no one</code> 将从机变为主机。</strong>  </p><p><strong>但这个过程是手动设置的，但在真正的使用中，如果主机挂掉，工作人员需要时间去指定下一个上位的从机，但这会花费时间，有没有一种可以自动去执行的这个过程？</strong></p><p><strong>搭：哨兵模式。在下面</strong></p><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a><strong>复制原理</strong></h2><ul><li>Slave 启动成功连接到 master 后会发送一个 sync（内存中的数据写入磁盘中） 命令</li><li>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master 将传送整个数据文件到 slave,以完成一次完全同步</li><li>全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave,完成同步</li><li>但是只要是重新连接 master,一次完全同步（全量复制)将被自动执行</li></ul><p><img src="/2022/06/07/redis/image-20220610111839270.png" alt="image-20220610111839270"></p><h2 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a>哨兵模式(sentinel)</h2><p>是什么：</p><p><strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了<strong>根据投票数自动将从库转换为主库</strong>  </p><p><img src="/2022/06/07/redis/image-20220610115550445.png" alt="image-20220610115550445"></p><p><strong>步骤：</strong></p><p>（1）调整为一主二仆模式， 6379 带着 6380、 6381  </p><p>（2）自定义的&#x2F;myredis 目录下新建 sentinel.conf 文件， 名字绝不能错  </p><p>（3）配置哨兵,填写内容  ：<code>sentinel monitor mymaster 127.0.0.1 6379 1</code>  （其中 mymaster 为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。  ）</p><p>（4）启动哨兵  ：执行 <code>redis-sentinel /myredis/sentinel.conf</code>  </p><p><img src="/2022/06/07/redis/image-20220610115726460.png" alt="image-20220610115726460"></p><p><strong>当主机挂掉， 从机选举中产生新的主机</strong>  </p><p>应该选择哪个从机作为主机呢？</p><p>（1）<strong>选择优先级靠前的。</strong>—redis.conf配置文件中，<code>replica-priority</code>  默认值为100，值越小优先级越高</p><p>（2）<strong>选择偏移量最大的</strong>，也就是从机中包含主机中数据最多的。</p><p>（3）<strong>选择runid最小的从服务：</strong>：每个 redis 实例启动后都会随机生成一个 40 位的 runid  （这个就是随机选取了）</p><p><strong>主从复制设置哨兵的工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedisFromSentinel</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(jedisSentinelPool==<span class="hljs-literal">null</span>)&#123;<br>Set&lt;String&gt; sentinelSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>sentinelSet.add(<span class="hljs-string">&quot;192.168.11.103:26379&quot;</span>);<br><span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>); <span class="hljs-comment">//最大可用连接数</span><br>jedisPoolConfig.setMaxIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">//最大闲置连接数</span><br>jedisPoolConfig.setMinIdle(<span class="hljs-number">5</span>); <span class="hljs-comment">//最小闲置连接数</span><br>jedisPoolConfig.setBlockWhenExhausted(<span class="hljs-literal">true</span>); <span class="hljs-comment">//连接耗尽是否等待</span><br>jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">2000</span>); <span class="hljs-comment">//等待时间</span><br>jedisPoolConfig.setTestOnBorrow(<span class="hljs-literal">true</span>); <span class="hljs-comment">//取连接的时候进行一下测试 ping pong</span><br>jedisSentinelPool=<span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisSentinelPool</span>(<span class="hljs-string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);<br><span class="hljs-keyword">return</span> jedisSentinelPool.getResource();<br>replica-priority&#125;<br>    <span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> jedisSentinelPool.getResource();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h1><p>容量不够，redis 如何进行扩容？  可以使用多台redis</p><p>并发写操作， redis 如何分摊？   多个redis</p><p><strong>之前通过代理主机来解决，但是 redis3.0 中提供了解决方案。就是无中心化集群配置。</strong>  </p><p><strong>之前的代理主机：</strong></p><p><img src="/2022/06/07/redis/image-20220610121734297.png" alt="image-20220610121734297"></p><p><strong>现在的无中心化集群配置：</strong></p><p><strong>任何一台服务器都可以作为集群的入口。</strong>可以把请求转交给任何一台服务器</p><p><img src="/2022/06/07/redis/image-20220610121748075.png" alt="image-20220610121748075"></p><h2 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h2><p><strong>Redis 集群实现了对 Redis 的水平扩容</strong>，即启动 N 个 redis 节点，将整个数据库分布存储在这 N 个节点中，每个节点存储总数据的 1&#x2F;N  </p><p><strong>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）</strong>： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。  （提供了从机）</p><h2 id="配置集群步骤："><a href="#配置集群步骤：" class="headerlink" title="配置集群步骤："></a><strong>配置集群步骤：</strong></h2><p>（1）将 rdb,aof 文件都删除掉  </p><p>（2）制作 6 个实例， 6379,6380,6381,6389,6390,6391.conf</p><p>（3）redis cluster 配置修改  ，在原来的主从复制中的配置添加：</p><ul><li>cluster-enabled yes 打开集群模式</li><li>cluster-config-file nodes-6379.conf 设定节点配置文件名</li><li>cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">include /home/bigdata/redis.conf<br>port <span class="hljs-number">6379</span><br>pidfile <span class="hljs-string">&quot;/var/run/redis_6379.pid&quot;</span><br>dbfilename <span class="hljs-string">&quot;dump6379.rdb&quot;</span><br>dir <span class="hljs-string">&quot;/home/bigdata/redis_cluster&quot;</span><br>logfile <span class="hljs-string">&quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;</span><br>cluster-enabled yes<br>cluster-config-file nodes-<span class="hljs-number">6379.</span>conf<br>cluster-node-timeout <span class="hljs-number">15000</span><br></code></pre></td></tr></table></figure><p>（4）修 改 好 redis6379.conf 文 件 ， 拷 贝 多 个redis.conf 文件  ，分别对应（ 6379,6380,6381,6389,6390,6391.conf）</p><p>（5）使用查找替换修改另外 5 个文件  ：<code>%s/6379/6380</code>  </p><p>（6）启动 6 个 redis 服务  </p><p>（7）将六个节点合成一个集群  ：组合之前，请确保所有 redis 实例启动后，nodes-xxxx.conf 文件都生成正常  </p><ul><li>合体： <code>cd /opt/redis-6.2.1/src</code>  redis文件的位置中的src</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">redis</span>-cli --cluster create --cluster-replicas <span class="hljs-number">1</span> <span class="hljs-number">192.168.11.101:6379</span><br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">11</span>.<span class="hljs-number">101</span>:<span class="hljs-number">6380</span> <span class="hljs-number">192.168.11.101:6381</span> <span class="hljs-number">192.168.11.101:6389</span><br><span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">11</span>.<span class="hljs-number">101</span>:<span class="hljs-number">6390</span> <span class="hljs-number">192.168.11.101:6391</span><br></code></pre></td></tr></table></figure><p><strong>此处不要用 127.0.0.1， 请用真实 IP 地址</strong><br><strong>–replicas 1 :采用最简单的方式配置集群，一台主机，一台从机，正好三组。</strong>  </p><p>（8）采用集群的方式连接</p><p><img src="/2022/06/07/redis/image-20220610124129675.png" alt="image-20220610124129675"></p><p>（9）通过 <code>cluster nodes</code> 命令查看集群信息  </p><p><strong>redis cluster 如何分配这六个节点?</strong>  </p><p>（1）一个集群至少要有三个主节点  </p><p>（2）选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点  </p><p>（3）分配原则尽量保证每个主数据库运行在不同的 IP 地址，每个从库和主库不在一个 IP 地址上。  （因为当一台主机挂掉之后，从机可以变为主机，如果都在一台服务器上时，则从机也挂掉了）</p><h2 id="什么是-slots"><a href="#什么是-slots" class="headerlink" title="什么是 slots"></a>什么是 slots</h2><p>一个 Redis 集群包含 16384 个插槽（hash slot）（为了集群平均分配）， 数据库中的每个键都属于这 16384个插槽的其中一个  </p><p><img src="/2022/06/07/redis/image-20220610131018008.png" alt="image-20220610131018008"></p><p><strong>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</strong>  </p><p><strong>集群中的每个节点负责处理一部分插槽</strong>  </p><p><strong>在集群中录入值：</strong>自动分配到键所对应的插槽中，</p><p><img src="/2022/06/07/redis/image-20220610130004189.png" alt="image-20220610130004189"></p><p><strong>不能进行 <code>mget</code> 和 mset 操作，可以通过{}来定义组的概念，从而使 key 中{}内相同内容的键值对放到一个 slot 中去。</strong>  </p><p><img src="/2022/06/07/redis/image-20220610130140398.png" alt="image-20220610130140398"></p><p><strong>查询集群中的值  （计算插槽值）：</strong></p><p><img src="/2022/06/07/redis/image-20220610130257347.png" alt="image-20220610130257347"></p><p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code> <strong>返回 count 个 slot 槽中的键。</strong>  </p><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p><strong>如果主节点下线，则从节点自动上位为主节点，</strong></p><p><strong>当主节点恢复回来后，变为从节点，</strong></p><p><strong>如果所有某一段插槽的主从节点都宕掉，redis 服务是否还能继续?</strong>  </p><ul><li>如果某一段插槽的主从都挂掉，而<strong>redis.conf中的</strong> <strong>cluster-require-full-coverage 为 yes</strong> ，那么 ，<strong>整个集群都挂掉</strong></li><li>如果某一段插槽的主从都挂掉，而 <strong>redis.conf中的cluster-require-full-coverage 为 no</strong> ，那么，该插槽数据全都不能使用，也无法存储。<strong>但其他插槽还可以继续使用</strong></li></ul><h2 id="集群的-Jedis-开发"><a href="#集群的-Jedis-开发" class="headerlink" title="集群的 Jedis 开发"></a>集群的 Jedis 开发</h2><p><img src="/2022/06/07/redis/image-20220610132151742.png" alt="image-20220610132151742"></p><h2 id="Redis集群的好处和不足"><a href="#Redis集群的好处和不足" class="headerlink" title="Redis集群的好处和不足"></a>Redis集群的好处和不足</h2><p><strong>好处：</strong></p><ul><li>实现扩容  （用集群实现扩容  ）</li><li>分摊压力  （用多台机器分担某一台机器（插槽）  ）</li><li>无中心配置相对简单  （任何一个节点都能进入到集群，之间能够互相切换  ）</li></ul><p><strong>不足”：</strong></p><ul><li>多键操作是不被支持的  </li><li>多键的 Redis 事务是不被支持的。lua 脚本不被支持  </li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至 redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</li></ul><h1 id="Redis应用问题的解决"><a href="#Redis应用问题的解决" class="headerlink" title="Redis应用问题的解决"></a>Redis应用问题的解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>问题描述</strong></p><p>key 对应的数据在数据源并不存在，<strong>每次针对此 key 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</strong>比如用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库  </p><p><img src="/2022/06/07/redis/image-20220610143457717.png" alt="image-20220610143457717"></p><p><strong>解决方案</strong></p><p>最终解决的方式就是，不安全的连接不能进入数据库，拦到外面</p><p>（1）<strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟  .</p><p>（2）<strong>设置可访问的名单（白名单）  ：</strong>使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。  </p><p>（3）<strong>采用布隆过滤器</strong>  ：将所有可能存在的数据哈希到一个足够大的 bitmaps 中，一个一定不存在的数据会被 这个 bitmaps 拦截掉，从而避免了对底层存储系统的查询压力。  </p><p>（4）<strong>进行实时监控</strong>：当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务  </p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮 。</p><p><img src="/2022/06/07/redis/image-20220610144458611.png" alt="image-20220610144458611"></p><p><strong>解决方案：</strong></p><p>（1）<strong>预先设置热门数据</strong>：在 redis 高峰访问之前，把一些热门数据提前存入到redis 里面，加大这些热门数据 key 的时长<br>（2）<strong>实时调整</strong>：现场监控哪些数据热门，实时调整 key 的过期时长<br>（3）<strong>使用锁：</strong>（效率低）</p><ul><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX）去 set 一个 mutex key  </li><li>当操作返回成功时，再进行 load db 的操作，并回设缓存,最后删除 mutexkey；  </li><li>当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个 get 缓存的方法  </li><li><img src="/2022/06/07/redis/image-20220610144742863.png" alt="image-20220610144742863"></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。<br><strong>缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key</strong>  </p><p><img src="/2022/06/07/redis/image-20220610145205724.png" alt="image-20220610145205724"></p><p><strong>解决方案：“</strong></p><p>（1） <strong>构建多级缓存架构：</strong>nginx 缓存 + redis 缓存 +其他缓存（ehcache 等）<br>（2） <strong>使用锁或队列</strong>：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况<br>（3） <strong>设置过期标志更新缓存</strong>：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。<br>（4） <strong>将缓存失效时间分散开</strong>：比如我们可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。  </p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的 Java API 并不能提供分布式锁的能力。为了解决这个问题就需要一种跨 JVM 的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！  </p><p><img src="/2022/06/07/redis/image-20220610150150521.png" alt="image-20220610150150521"></p><p><img src="/2022/06/07/redis/image-20220610150026377.png" alt="image-20220610150026377"></p><p><strong>编写代码：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">GetMapping(<span class="hljs-string">&quot;testLock&quot;</span>)</span><br>public void test<span class="hljs-constructor">Lock()</span>&#123;<br><span class="hljs-comment">//1 获取锁， setne</span><br>Boolean lock = redisTemplate.ops<span class="hljs-constructor">ForValue()</span>.set<span class="hljs-constructor">IfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>)</span>;<br><span class="hljs-comment">//2 获取锁成功、 查询 num 的值if(lock)&#123;</span><br>Object value = redisTemplate.ops<span class="hljs-constructor">ForValue()</span>.get(<span class="hljs-string">&quot;num&quot;</span>);<br><span class="hljs-comment">//2.1 判断 num 为空 return</span><br><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StringUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">value</span>)</span>)&#123;<br>return;<br>&#125; <br><span class="hljs-comment">//2.2 有值就转成成 int</span><br><span class="hljs-built_in">int</span> num = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">value</span>+<span class="hljs-string">&quot;&quot;</span>)</span>;<br><span class="hljs-comment">//2.3 把 redis 的 num 加 1</span><br>redisTemplate.ops<span class="hljs-constructor">ForValue()</span>.set(<span class="hljs-string">&quot;num&quot;</span>, ++num);<br><span class="hljs-comment">//2.4 释放锁， del</span><br>redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//3 获取锁失败、 每隔 0.1 秒再获取</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">100</span>);<br>test<span class="hljs-constructor">Lock()</span>;<br>&#125; catch (InterruptedException e) &#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题1：</strong> setnx 刚好获取到锁， 业务逻辑出现异常， 导致锁无法释放<br><strong>解决：</strong> 设置过期时间， 自动释放锁  </p><p>**优化之设置锁的过期时间  **</p><p>两种方式：</p><p>（1）首先想到通过 expire 设置过期时间（缺乏原子性： 如果在 setnx 和 expire 之<br>间出现异常， 锁也无法释放）<br>（2） 在 set 时指定过期时间（推荐）  </p><p><img src="/2022/06/07/redis/image-20220610152715911.png" alt="image-20220610152715911"></p><p><strong>问题2： 可能会释放其他服务器的锁。</strong>  </p><p><strong>场景：</strong></p><p><img src="/2022/06/07/redis/image-20220610152828761.png" alt="image-20220610152828761"></p><p><strong>代码：</strong></p><p><img src="/2022/06/07/redis/image-20220610152957380.png" alt="image-20220610152957380"></p><p><img src="/2022/06/07/redis/image-20220610153011261.png" alt="image-20220610153011261"></p><p><strong>但是使用了UUID之后不具有原子性：</strong></p><p><img src="/2022/06/07/redis/image-20220610153713549.png" alt="image-20220610153713549"></p><p><strong>使用LUA脚本保证删除的原子性</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;testLockLua&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLockLua</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//1 声明一个 uuid ,将做为一个 value 放入我们的 key 所对应的值中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br><span class="hljs-comment">//2 定义一个锁： lua 脚本可以使用同一把锁， 来实现删除！</span><br><span class="hljs-type">String</span> <span class="hljs-variable">skuId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;25&quot;</span>; <span class="hljs-comment">// 访问 skuId 为 25 号的商品 100008348542</span><br><span class="hljs-type">String</span> <span class="hljs-variable">locKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span> + skuId; <span class="hljs-comment">// 锁住的是每个商品的数据// 3 获取锁</span><br><span class="hljs-type">Boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(locKey, uuid, <span class="hljs-number">3</span>,<br>TimeUnit.SECONDS);<br><span class="hljs-comment">// 第一种： lock 与过期时间中间不写任何的代码。</span><br><span class="hljs-comment">// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间</span><br><span class="hljs-comment">// 如果 true</span><br><span class="hljs-keyword">if</span> (lock) &#123;<br><span class="hljs-comment">// 执行的业务逻辑开始</span><br><span class="hljs-comment">// 获取缓存中的 num 数据</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;num&quot;</span>);<br><span class="hljs-comment">// 如果是空直接返回</span><br><span class="hljs-keyword">if</span> (StringUtils.isEmpty(value)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125; <br><span class="hljs-comment">// 不是空 如果说在这出现了异常！ 那么 delete 就删除失败！ 也就是说锁永远存在！</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(value + <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 使 num 每次+1 放入缓存</span><br>redisTemplate.opsForValue().set(<span class="hljs-string">&quot;num&quot;</span>, String.valueOf(++num));<br><span class="hljs-comment">/*使用 lua 脚本来锁*/</span><br><span class="hljs-comment">// 定义 lua 脚本</span><br><span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return</span><br><span class="hljs-string">redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;<br><span class="hljs-comment">// 使用 redis 执行 lua 执行</span><br>DefaultRedisScript&lt;Long&gt; redisScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>redisScript.setScriptText(script);<br><span class="hljs-comment">// 设置一下返回值类型 为 Long</span><br><span class="hljs-comment">// 因为删除判断的时候， 返回的 0,给其封装为数据类型。 如果不封装那么默认返回 String 类型，</span><br><span class="hljs-comment">// 那么返回字符串与 0 会有发生错误。</span><br>redisScript.setResultType(Long.class);<br><span class="hljs-comment">// 第一个要是 script 脚本 ， 第二个需要判断的 key， 第三个就是 key 所对应的值。</span><br>redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 其他线程等待</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 睡眠</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 睡醒了之后， 调用方法。</span><br>testLockLua();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LUA脚本详解</strong></p><p><img src="/2022/06/07/redis/image-20220610154032749.png" alt="image-20220610154032749"></p><p><img src="/2022/06/07/redis/image-20220610154103532.png" alt="image-20220610154103532"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小栈</title>
    <link href="/2022/06/06/%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2022/06/06/%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–155-最小栈"><a href="#leetCode–155-最小栈" class="headerlink" title="leetCode–155(最小栈)"></a>leetCode–155(最小栈)</h1><h1 id="解法一：辅助栈"><a href="#解法一：辅助栈" class="headerlink" title="解法一：辅助栈"></a>解法一：辅助栈</h1><p><strong>使用一个辅助栈来存储所扫描元素的最小值。</strong></p><p><img src="/2022/06/06/%E6%9C%80%E5%B0%8F%E6%A0%88/155_fig1.gif" alt="fig1"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-comment">//使用辅助栈</span><br>    Stack&lt;Integer&gt; stack;<br>    Stack&lt;Integer&gt; minStack;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        stack.push(val);<br>        <span class="hljs-keyword">if</span> (minStack.isEmpty()) minStack.push(val);<br>        <span class="hljs-comment">//最小栈，每次添加所遍历到的最小值</span><br>        <span class="hljs-keyword">else</span> minStack.push(Math.min(val,minStack.peek()));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        stack.pop();<br>        <span class="hljs-comment">//这一步千万不要忘记，存储最小值的栈也要出栈</span><br>        minStack.pop();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> minStack.peek();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(val);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="解法二：不使用额外空间"><a href="#解法二：不使用额外空间" class="headerlink" title="解法二：不使用额外空间"></a>解法二：不使用额外空间</h1><p><strong>数组栈，栈中每个元素都是一个数组，数组长度为2，第一个元素是遍历到数的值，第二个元素是所遍历的最小值。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    Stack&lt;<span class="hljs-type">int</span>[]&gt; stack;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(stack.isEmpty()) stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;val,val&#125;);<br>        <span class="hljs-keyword">else</span>&#123;<br>            stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;val,Math.min(val,stack.peek()[<span class="hljs-number">1</span>])&#125;);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        stack.pop();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> stack.peek()[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack obj = new MinStack();</span><br><span class="hljs-comment"> * obj.push(val);</span><br><span class="hljs-comment"> * obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * int param_4 = obj.getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环形链表</title>
    <link href="/2022/06/06/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/06/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–141-环形链表"><a href="#leetCode–141-环形链表" class="headerlink" title="leetCode–141(环形链表)"></a>leetCode–141(环形链表)</h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p>示例 1：</p><p><img src="/2022/06/06/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/image-20220606185854338.png" alt="image-20220606185854338"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="/2022/06/06/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/image-20220606185909591.png" alt="image-20220606185909591"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p>示例 3：</p><p><img src="/2022/06/06/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/image-20220606185915956.png" alt="image-20220606185915956"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><h1 id="解法一：set集合"><a href="#解法一：set集合" class="headerlink" title="解法一：set集合"></a>解法一：set集合</h1><p>使用set集合进行判断是否有环，因为如果有环存在，则一定会访问到重复的元素，由于set中不能存储重复元素，所以遇到重复元素就说明有环。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">if</span> (!set.add(head))&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           &#125;<br>           head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>之前写的时候，是想到用值来判断set集合中是否有该节点，但是用例没有过去，因为节点的值也有可能相等，所以，set的类型要为ListNode才可以。</strong></p><h1 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h1><p>我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。如果有环 则快指针和慢指针一定会相遇，如果没有环，则快指针为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123;</span><br><span class="hljs-comment"> *         val = x;</span><br><span class="hljs-comment"> *         next = null;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">while</span> (fast!=<span class="hljs-literal">null</span> &amp;&amp; slow!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (fast.next!=<span class="hljs-literal">null</span>) &#123;<br>                fast = fast.next.next;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (slow.next!=<span class="hljs-literal">null</span>) &#123;<br>                slow = slow.next;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (fast==slow) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fast==<span class="hljs-literal">null</span> || slow==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="/2022/06/06/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/06/06/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–136-只出现一次的数字"><a href="#leetCode–136-只出现一次的数字" class="headerlink" title="leetCode–136(只出现一次的数字)"></a>leetCode–136(只出现一次的数字)</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br><br><br></code></pre></td></tr></table></figure><h1 id="解法一：自己"><a href="#解法一：自己" class="headerlink" title="解法一：自己"></a>解法一：自己</h1><p>利用Hash表进行计算，使用一个map来存储数据    <strong>key：</strong>数的大小  <strong>value：</strong>该数的个数，再遍历map。值为1 的就是结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span> (map.containsKey(nums[i]))&#123;<br>                map.put(nums[i],map.get(nums[i])+<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                map.put(nums[i],<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Integer i:map.keySet())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> map.get(i);<br>            <span class="hljs-keyword">if</span> (a==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解法二：排序-遍历"><a href="#解法二：排序-遍历" class="headerlink" title="解法二：排序+遍历"></a>解法二：排序+遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//排列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//数组进行排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">//排序后进行遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i=i+<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-comment">//如果已经遍历到最后一个元素，则最后一个元素就是结果</span><br>            <span class="hljs-keyword">if</span> (i==n-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[i];<br>            <span class="hljs-keyword">if</span> (nums[i]!=nums[i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解法三：异或-简直妙妙妙！！"><a href="#解法三：异或-简直妙妙妙！！" class="headerlink" title="解法三：异或  简直妙妙妙！！"></a>解法三：异或  简直妙妙妙！！</h1><p>打死我也想不到用这种方法，简直是太牛了！！！</p><p>这也是为什么要记录这题的原因，太妙了！！要记住哈~~</p><p><strong>异或运算有以下三个性质：</strong></p><ul><li>任何数和 0 做异或运算，结果仍然是原来的数， 即 a ⊕ 0 &#x3D; a</li><li>任何数和其自身做异或运算，结果是 0 ，即 a ⊕ a &#x3D; 0</li><li>异或运算满足交换律和结合律,即a ⊕ b ⊕ a &#x3D; b ⊕ a ⊕ a &#x3D; b ⊕ (a ⊕ a) &#x3D; b ⊕ 0 &#x3D; b</li></ul><p>有了以上三个性质，可以得出—-&gt;<strong>所有的数异或之后所得的数就是结果，因为其他的数两两相等，异或为0，0再和一个元素异或等于本身！</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//异或</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            res = res^nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
      <category>简单题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot入门</title>
    <link href="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/"/>
    <url>/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-特性"><a href="#SpringBoot-特性" class="headerlink" title="SpringBoot 特性"></a>SpringBoot 特性</h1><p><strong>简介：</strong></p><p>Spring Boot 框架对此开发过程进行了革命性的颠覆，完全抛弃了繁琐的 xml 配置过程，采用大量的默认配置简化我们的开发过程。  </p><p><strong>特性</strong></p><ul><li>能够快速创建基于 Spring 的应用程序  </li><li>能够直接使用 java main 方法启动内嵌的 Tomcat 服务器运行 Spring Boot 程序，不需要部署 war 包文件  </li><li>提供约定的 starter POM 来简化 Maven 配置，让 Maven 的配置变得简单  </li><li>自动化配置，根据项目的 Maven 依赖配置， Spring boot 自动配置 Spring、 Spring mvc等  </li><li>提供了程序的健康检查等功能  </li><li>基本可以完全不使用 XML 配置文件，采用注解配置</li></ul><h1 id="SpringBoot入门案例"><a href="#SpringBoot入门案例" class="headerlink" title="SpringBoot入门案例"></a>SpringBoot入门案例</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606150222302.png" alt="image-20220606150222302"></p><p><strong>static：</strong> 存放静态资源，如图片、 CSS、 JavaScript 等<br><strong>templates：</strong>存放 Web 页面的模板文件<br><strong>application.properties&#x2F;application.yml</strong> 用于存放程序的各种依赖模块的配置信息，比如 服务端口，数据库连接配置等  </p><h2 id="pom-xml配置文件解读"><a href="#pom-xml配置文件解读" class="headerlink" title="pom.xml配置文件解读"></a>pom.xml配置文件解读</h2><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--继承 SpringBoot 框架的一个父项目，所有自己开发的 Spring Boot 都必须的继承--&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zlw.springboot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--maven 属性配置，可以在其它地方通过$</span></span><span class="hljs-template-variable">&#123;&#125;</span><span class="language-xml"><span class="hljs-comment">方式进行引用--&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--SpringBoot 框架 web 项目起步依赖，通过该依赖自动关联其它依赖，不需要我们一个一个去添加了--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--SpringBoot 框架的测试起步依赖，例如： junit 测试，如果不需要的话可以删除--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--MyBatis 整合 SpringBoot 的起步依赖--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!--MySQL 的驱动依赖--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xmlunit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xmlunit-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 第一种做法  手动指定文件夹为resource,因为Idea规定所有的配置文件应该在resources里面，但是mybatis中mapper和mapper.xml都要在mapper文件中实现，</span></span><br><span class="hljs-comment"><span class="language-xml">所以要配置这个--&gt;</span></span><br><span class="language-xml"><span class="hljs-comment">&lt;!--        第二种做法，直接将xml文件放入到resources目录中--&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--SpringBoot 提供的打包编译等插件--&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--mybatis 代码自动生成插件--&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-comment">&lt;!--配置文件的位置--&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>GeneratorMapper.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>16<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>16<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p><strong>Application.java</strong>： SpringBoot 程序执行的入口，执行该程序中的 main 方法， SpringBoot就启动了  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">//开启spring配置</span><br><span class="hljs-meta">@MapperScan(&quot;com.zlw.springboot.mapper&quot;)</span> <span class="hljs-comment">//开启扫描Mapper接口的包以及子目录</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootMybatisApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringbootMybatisApplication.class, args);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p><strong>在实际开发的过程中，我们的项目会经历很多的阶段（开发-&gt;测试-&gt;上线），每个阶段的配置也会不同，例如：端口、上下文根、数据库等，那么这个时候为了方便在不同的环境之间切换， SpringBoot 提供了多环境配置，具体步骤如下</strong>  </p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606150842297.png" alt="image-20220606150842297"></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606150854255.png" alt="image-20220606150854255"></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606150901205.png" alt="image-20220606150901205"></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606150911624.png" alt="image-20220606150911624"></p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>（1）在 SpringBoot 的核心配置文件中，除了使用内置的配置项之外，我们还可以在自定义配置，然后采用如下注解去读取配置的属性值  </p><p><strong>使用注解@Value</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606151028561.png" alt="image-20220606151028561"></p><p>Java代码中要使用配置文件中的自定义配置：（@Value注解（”${}”））</p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606151107078.png" alt="image-20220606151107078"></p><p>（2）将整个文件映射成一个对象，用于自定义配置项比较多的情况  </p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606151150537.png" alt="image-20220606151150537"></p><p>school映射的是一个java类，里面有name和websit属性，因为配置文件中不一定只有一个name和websit，所以要加上前缀名，</p><p>在 com.abc.springboot.config 包下创建 ConfigInfo 类，并为该类加上 Component 和ConfigurationProperties 注解，并在ConfigurationProperties 注解中添加属性prefix  </p><p><strong>school类上面要添加如下：</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606151426368.png" alt="image-20220606151426368"></p><h1 id="SpringBoot框架Web开发"><a href="#SpringBoot框架Web开发" class="headerlink" title="SpringBoot框架Web开发"></a>SpringBoot框架Web开发</h1><h2 id="Spring-Boot-集成-MyBatis"><a href="#Spring-Boot-集成-MyBatis" class="headerlink" title="Spring Boot 集成 MyBatis"></a>Spring Boot 集成 MyBatis</h2><p><strong>（1）添加MyBatis 整合 SpringBoot 的起步依赖和MySQL 的驱动依赖</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--MyBatis 整合 SpringBoot 的起步依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;!--MySQL 的驱动依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;mysql&lt;/groupId&gt;<br>            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p><strong>（2）配置核心文件（application.properties   ）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.datasource.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/springboot?useUnicode=true&amp;characterEncoding=UTF8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8</span><br>spring.datasource.username=root<br>spring.datasource.password=Zlw0502<br></code></pre></td></tr></table></figure><p><strong>（3）Mybatis逆向生成（mapper.java 和 mapper.xml）：</strong></p><p>​<strong>（1）引入逆向生成插件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mybatis 代码自动生成插件--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!--配置文件的位置--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>GeneratorMapper.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：SpringBoot集成Mybatis时，最重要的两个注解，@Mapper 和 @MapperScan</strong></p><ul><li><p>@Mapper：需要在每个Mapper接口类上添加，作用是扫描dao接口</p></li><li><p>@MapperScan：在SpringBoot启动入口类上添加，指定扫描路径，扫描包下的所有mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.zlw.springboot.mapper&quot;)</span> <span class="hljs-comment">//开启扫描Mapper接口的包以及子目录</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>关于Mapper映射文件存放的位置写法有两种：</strong></p><ul><li><p>将Mapper接口和映射文件都放在src&#x2F;main&#x2F;java同一目录下，添加pom文件手动指定资源文件路径resources</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 第一种做法  手动指定文件夹为resource,因为Idea规定所有的配置文件应该在resources里面，但是mybatis中mapper和mapper.xml都要在mapper文件中实现，</span><br><span class="hljs-comment">所以要配置这个--&gt;</span><br><span class="hljs-comment">&lt;!--        第二种做法，直接将xml文件放入到resources目录中--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>将Mapper接口和Mapper映射文件分开存放，在SpringBoot启动入口类上添加@MapperScan注解，并在springboot配置文件中指定mapper配置文件所在的位置。</p></li></ul><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606152712722.png" alt="image-20220606152712722"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">#第二种方式:指定MyBatis映射文件的路径<br>mybatis-plus.mapper-locations=classpath:mapper<span class="hljs-comment">/*.xml</span><br></code></pre></td></tr></table></figure><p><strong>逆向工程所需要的配置文件：（GeneratorMapper.xml  ）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;!DOCTYPE generatorConfiguration<br>        PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration</span><br><span class="hljs-string">1.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;<br>&lt;generatorConfiguration&gt;<br>&lt;!-- 指定连接数据库的 JDBC 驱动包所在位置，指定到你本机的完整路径 --&gt;<br>&lt;classPathEntry location=<span class="hljs-string">&quot;E:\java_jar\mysql-connector-java-8.0.26\mysql-connector-java-8.0.26.jar&quot;</span>/&gt;<br>&lt;!-- 配置 table 表信息内容体， targetRuntime 指定采用 MyBatis3 的版本 --&gt;<br>&lt;context id=<span class="hljs-string">&quot;tables&quot;</span> targetRuntime=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;<br>        &lt;!-- 抑制生成注释，由于生成的注释都是英文的，可以不让它生成 --&gt;<br>        &lt;commentGenerator&gt;<br>        &lt;property name=<span class="hljs-string">&quot;suppressAllComments&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span>/&gt;<br>        &lt;/commentGenerator&gt;<br>        &lt;!-- 配置数据库连接信息 --&gt;<br>        &lt;jdbcConnection driverClass=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span><br>        connectionURL=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/springboot&quot;</span><br>        userId=<span class="hljs-string">&quot;root&quot;</span><br>        password=<span class="hljs-string">&quot;Zlw0502&quot;</span>&gt;<br>        &lt;/jdbcConnection&gt;<br>        &lt;!-- 生成 model 类， targetPackage 指定 model 类的包名， targetProject<br>指定生成的 model 放在 eclipse 的哪个工程下面--&gt;<br>        &lt;javaModelGenerator targetPackage=<span class="hljs-string">&quot;com.zlw.springboot.model&quot;</span><br>        targetProject=<span class="hljs-string">&quot;src\main\java&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;enableSubPackages&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span>/&gt;<br>        &lt;property name=<span class="hljs-string">&quot;trimStrings&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span>/&gt;<br>        &lt;/javaModelGenerator&gt;<br>        &lt;!-- 生成 MyBatis 的 Mapper.xml 文件， targetPackage 指定 mapper.xml 文<br>件的包名， targetProject 指定生成的 mapper.xml 放在 eclipse 的哪个工程下面 --&gt;<br>        &lt;sqlMapGenerator targetPackage=<span class="hljs-string">&quot;com.zlw.springboot.mapper&quot;</span><br>        targetProject=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;enableSubPackages&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span>/&gt;<br>        &lt;/sqlMapGenerator&gt;<br>        &lt;!-- 生成 MyBatis 的 Mapper 接口类文件,targetPackage 指定 Mapper 接口类<br>的包名， targetProject 指定生成的 Mapper 接口放在 eclipse 的哪个工程下面 --&gt;<br>        &lt;javaClientGenerator type=<span class="hljs-string">&quot;XMLMAPPER&quot;</span>  targetPackage=<span class="hljs-string">&quot;com.zlw.springboot.mapper&quot;</span> targetProject=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;<br>        &lt;property name=<span class="hljs-string">&quot;enableSubPackages&quot;</span> value=<span class="hljs-string">&quot;false&quot;</span>/&gt;<br>        &lt;/javaClientGenerator&gt;<br>        &lt;!-- 数据库表名及对应的 Java 模型类名 --&gt;<br>        &lt;table tableName=<span class="hljs-string">&quot;t_student&quot;</span> domainObjectName=<span class="hljs-string">&quot;Student&quot;</span><br>        enableCountByExample=<span class="hljs-string">&quot;false&quot;</span><br>        enableUpdateByExample=<span class="hljs-string">&quot;false&quot;</span><br>        enableDeleteByExample=<span class="hljs-string">&quot;false&quot;</span><br>        enableSelectByExample=<span class="hljs-string">&quot;false&quot;</span><br>        selectByExampleQueryId=<span class="hljs-string">&quot;false&quot;</span>/&gt;<br>    &lt;/context&gt;<br>&lt;/generatorConfiguration&gt;<br></code></pre></td></tr></table></figure><h2 id="Spring-Boot-事务支持"><a href="#Spring-Boot-事务支持" class="headerlink" title="Spring Boot 事务支持"></a>Spring Boot 事务支持</h2><p>只需要在访问数据库的Service方法上添加<code>@Transactional</code>即可，会自动进行回滚。</p><p>哪种方法需要，就在哪种方法上加<code>@Transactional</code>注解。（一般是增删改）</p><h1 id="Spring-Boot-下的-Spring-MVC"><a href="#Spring-Boot-下的-Spring-MVC" class="headerlink" title="Spring Boot 下的 Spring  MVC"></a>Spring Boot 下的 Spring  MVC</h1><p><strong>Spring Boot 下的 Spring MVC 和之前的 Spring MVC 使用是完全一样的，主要有以下注解</strong>  </p><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p><strong>是@Controller 注解功能的增强  ，是 @Controller 与@ResponseBody 的组合注解</strong>  </p><p>如果一个 Controller 类添加了@RestController，那么该 Controller 类下的所有方法都相当于添加了@ResponseBody 注解  ，<strong>也就说明了，这个Controller类中的所有方法返回的都是json字符串的格式。</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220606205214351.png" alt="image-20220606205214351"></p><h2 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h2><p>只支持 Get 请求， <strong>Get 请求主要用于查询操作</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)</span><br><span class="hljs-meta">@GetMapping(value = &quot;/user&quot;)</span>  <span class="hljs-comment">//相当于上一句话，只接受get请求，如果请求方式部队，报405错误</span><br></code></pre></td></tr></table></figure><h2 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h2><p>只支持 Post 请求 <strong>Post 请求主要用户新增数据</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)</span><br><span class="hljs-meta">@PostMapping(value = &quot;/user&quot;)</span>  <span class="hljs-comment">//相当于上一句话，只接受post请求</span><br></code></pre></td></tr></table></figure><h2 id="PutMapping"><a href="#PutMapping" class="headerlink" title="@PutMapping"></a>@PutMapping</h2><p>只支持 Put 请求   <strong>Put 通常用于修改数据</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)</span><br><span class="hljs-meta">@PutMapping(value = &quot;/user&quot;)</span>  <span class="hljs-comment">//相当于上一句话，只接受post请求</span><br></code></pre></td></tr></table></figure><h2 id="DeleteMapping"><a href="#DeleteMapping" class="headerlink" title="@DeleteMapping"></a>@DeleteMapping</h2><p>只支持 Delete 请求  <strong>通常用于删除数据</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)</span><br><span class="hljs-meta">@DeleteMapping(value = &quot;/user&quot;)</span>  <span class="hljs-comment">//相当于上一句话，只接受post请求</span><br></code></pre></td></tr></table></figure><h1 id="Spring-Boot-开发-RESTFul"><a href="#Spring-Boot-开发-RESTFul" class="headerlink" title="Spring Boot 开发 RESTFul"></a>Spring Boot 开发 RESTFul</h1><p>将请求参数使用 &#x2F; 来隔开</p><p>Spring boot 开发 RESTFul 主要是几个注解实现  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RESTfulController</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 添加学生</span><br><span class="hljs-comment">* 请求地址：</span><br><span class="hljs-comment">http://localhost:9090/014-springboot-restful/springBoot/student/wangpeng/23</span><br><span class="hljs-comment">* 请求方式： POST</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> age</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@PostMapping(value = &quot;/springBoot/student/&#123;name&#125;/&#123;age&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">addStudent</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name,<span class="hljs-meta">@PathVariable(&quot;age&quot;)</span> Integer age)</span> &#123;<br>Map&lt;String,Object&gt; retMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>retMap.put(<span class="hljs-string">&quot;name&quot;</span>,name);<br>retMap.put(<span class="hljs-string">&quot;age&quot;</span>,age);<br><span class="hljs-keyword">return</span> retMap;<br>&#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">* 删除学生</span><br><span class="hljs-comment">* 请求地址：</span><br><span class="hljs-comment">http://localhost:9090/014-springboot-restful/springBoot/student/1</span><br><span class="hljs-comment">* 请求方式： Delete</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@DeleteMapping(value = &quot;/springBoot/student/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">removeStudent</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;删除的学生 id 为： &quot;</span> + id;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 修改学生信息</span><br><span class="hljs-comment">* 请求地址：</span><br><span class="hljs-comment">http://localhost:9090/014-springboot-restful/springBoot/student/2</span><br><span class="hljs-comment">* 请求方式： Put</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@PutMapping(value = &quot;/springBoot/student/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">modifyStudent</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;修改学生的 id 为&quot;</span> + id;<br>&#125;<br><span class="hljs-meta">@GetMapping(value = &quot;/springBoot/student/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryStudent</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;查询学生的 id 为&quot;</span> + id;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用Postman 模拟发送请求，进行测试  。</p><p><strong>好处：</strong></p><ul><li>传递参数变简单了  </li><li>服务提供者对外只提供了一个接口服务，而不是传统的 CRUD 四个接口</li></ul><p><strong>当请求路径冲突时：</strong></p><ul><li>修改请求方式：可以通过（post添加，put修改，get查询，delete删除）进行标识</li><li>修改请求路径（例如：顺序）</li></ul><p><strong>RESTful 原则</strong>  </p><ul><li><strong>增：</strong> post 请求、<strong>删：</strong> delete 请求、<strong>改 ：</strong>put 请求、<strong>查 ：</strong>get 请求  </li><li>请求路径不要出现动词  eg： &#x2F;boot&#x2F;order&#x2F;1021&#x2F;1（推荐）   &#x2F;boot&#x2F;queryOrder&#x2F;1021&#x2F;1（不推荐）  </li><li>分页、排序等操作，不需要使用斜杠传参数  （<strong>一般传的参数如果不是数据库表的字段，可以不采用斜杠</strong>  ）</li></ul><h1 id="Spring-Boot-集成-Redis"><a href="#Spring-Boot-集成-Redis" class="headerlink" title="Spring Boot 集成 Redis"></a>Spring Boot 集成 Redis</h1><p><strong>先去学redis了</strong>。。。。。</p><p><strong>回来了。。。</strong></p><p><strong>设计一个案例：</strong>向redis中存入值，和取值。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><strong>（1）引入SpringBoot集成Redis依赖</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 加载 spring boot redis 包 --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p><strong>（2）SpringBoot核心配置文件，配置redis信息</strong>（application.properties）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">spring.redis.host=<span class="hljs-number">192.168</span><span class="hljs-number">.86</span><span class="hljs-number">.129</span><br>spring.redis.port=<span class="hljs-number">6379</span><br>spring.redis.password=Zlw199805<br></code></pre></td></tr></table></figure><p><strong>（3）开启redis</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220611221056248.png" alt="image-20220611221056248"></p><p><strong>要想连接成功，要关闭防火墙！</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220612105454576.png" alt="image-20220612105454576"></p><p><strong>（4）编写RedisController类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisService redisService;<br><br>    <span class="hljs-comment">//存入数据</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/put&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> Object <span class="hljs-title function_">put</span><span class="hljs-params">(String key,String value)</span>&#123;<br>        redisService.putRedis(key,value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功加入&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//获取数据</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/get&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisService.getRedis(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;名字为:&quot;</span>+name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）编写RedisService接口和实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RedisService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;Object,Object&gt; redisTemplate;<br><br>    <span class="hljs-comment">//存入数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putRedis</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        redisTemplate.opsForValue().set(key,value);<br>    &#125;<br>    <span class="hljs-comment">//获取数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRedis</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(name);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Spring-Boot-集成-Dubbo"><a href="#Spring-Boot-集成-Dubbo" class="headerlink" title="Spring Boot 集成 Dubbo"></a>Spring Boot 集成 Dubbo</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p><strong>（1）分别创建dubbo服务接口工程、服务提供者工程 和 消费者工程。</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220613220234550.png" alt="image-20220613220234550"></p><h2 id="接口工程"><a href="#接口工程" class="headerlink" title="接口工程"></a>接口工程</h2><p>因为接口工程里面不用web项目，所以只创建一个普通的maven工程就可以了。</p><p>创建service接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentService</span> &#123;<br>    Integer <span class="hljs-title function_">queryStudentCount</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="服务提供者工程"><a href="#服务提供者工程" class="headerlink" title="服务提供者工程"></a>服务提供者工程</h2><p><strong>（1）引入依赖</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--Dubbo 集成 SpringBoot 框架起步依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;!--Zookeeper 客户端依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.101tec&lt;/groupId&gt;<br>            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">0.10</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;!--Dubbo 接口工程--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.zlw.springboot&lt;/groupId&gt;<br>            &lt;artifactId&gt;springboot-dubbo-interface&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT&lt;/version&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p><strong>（2）核心配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">server.port=<span class="hljs-number">8081</span><br>server.servlet.context-path=/<br><br>#设置dubbo的配置<br>spring.application.name=springboot-dubbo-providers<br>#设置当前工程是一个服务提供者<br>spring.dubbo.server=<span class="hljs-literal">true</span><br>#设置注册中心<br>spring.dubbo.registry=zookeeper:<span class="hljs-comment">//192.168.86.129:2181</span><br><br></code></pre></td></tr></table></figure><p><strong>（3）StudentServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.dubbo.config.annotation.Service;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> service.StudentService;<br><br><span class="hljs-meta">@Component</span> <br><span class="hljs-meta">@Service(interfaceClass = StudentService.class, version = &quot;1.0.0&quot;, timeout=1500)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentService</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StudentMapper studentMapper;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">queryStudent</span><span class="hljs-params">(Integer id)</span> &#123;<br><span class="hljs-keyword">return</span> studentMapper.selectByPrimaryKey(id);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消费者工程。"><a href="#消费者工程。" class="headerlink" title="消费者工程。"></a>消费者工程。</h2><p><strong>（1）引入依赖</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--Dubbo 集成 SpringBoot 框架起步依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;!--Zookeeper 客户端依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.101tec&lt;/groupId&gt;<br>            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">0.10</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;!--Dubbo 接口工程--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.zlw.springboot&lt;/groupId&gt;<br>            &lt;artifactId&gt;springboot-dubbo-interface&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT&lt;/version&gt;<br>        &lt;/dependency&gt;同上<br></code></pre></td></tr></table></figure><p><strong>（2）核心配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">#设置内嵌Tomcat端口号<br>server.port=<span class="hljs-number">8080</span><br>server.servlet.context-path=/<br><br>#设置dubbo设置<br>spring.application.name=springboot-dubbo-consumers<br>#指定注册中心<br>spring.dubbo.registry=zookeeper:<span class="hljs-comment">//192.168.86.129:2181</span><br><br></code></pre></td></tr></table></figure><p><strong>（3）Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentController</span> &#123;<br><span class="hljs-meta">@Reference(interfaceClass = StudentService.class, version = &quot;1.0.0&quot;, check = false)</span><br><span class="hljs-keyword">private</span> StudentService studentService;<br><span class="hljs-meta">@RequestMapping(value = &quot;/student&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">queryStudent</span><span class="hljs-params">(Integer id)</span> &#123;<br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> studentService.queryStudent(id);<br><span class="hljs-keyword">return</span> student;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在-SpringBoot-入口程序类上加开启-Dubbo-配置支持注解"><a href="#在-SpringBoot-入口程序类上加开启-Dubbo-配置支持注解" class="headerlink" title="在 SpringBoot 入口程序类上加开启 Dubbo 配置支持注解"></a>在 SpringBoot 入口程序类上加开启 Dubbo 配置支持注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDubboConfiguration</span> <span class="hljs-comment">//开启 Dubbo 配置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SpringApplication.run(Application.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Springboot集成Dubbo，Redis，Mybatis，Spring，SpringMVC，jsp"><a href="#Springboot集成Dubbo，Redis，Mybatis，Spring，SpringMVC，jsp" class="headerlink" title="Springboot集成Dubbo，Redis，Mybatis，Spring，SpringMVC，jsp"></a>Springboot集成Dubbo，Redis，Mybatis，Spring，SpringMVC，jsp</h1><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220614163546726.png" alt="image-20220614163546726"></p><h2 id="接口工程-1"><a href="#接口工程-1" class="headerlink" title="接口工程"></a>接口工程</h2><p>创建一个简单的maven工程，什么都不用配置和依赖，里面存放的是接口和实体bean</p><p>使用mybatis逆向工程生成的bean，和StudentService接口</p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220615113520979.png" alt="image-20220615113520979"></p><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p><strong>（1）提供依赖：Dubbo、zookeeper、redis、mybatis、mysql、接口工程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--        dubbo集成springboot依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>&lt;!--zookeeper 注册中心--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.101tec&lt;/groupId&gt;<br>            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">0.10</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>&lt;!--mybatis--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">2.0</span><span class="hljs-number">.1</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>&lt;!--mysql数据库驱动--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;mysql&lt;/groupId&gt;<br>            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>&lt;!--        集成redis--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>&lt;!--接口工程--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.zlw.springboot&lt;/groupId&gt;<br>            &lt;artifactId&gt;springboot-ssm-interface&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">1.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p><strong>mybatis逆向工程插件：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--mybatis 代码自动生成插件--&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;<br>                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;<br>                &lt;version&gt;<span class="hljs-number">1.3</span><span class="hljs-number">.6</span>&lt;/version&gt;<br>                &lt;configuration&gt;<br>                    &lt;!--配置文件的位置--&gt;<br>                    &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt;<br>                    &lt;verbose&gt;<span class="hljs-literal">true</span>&lt;/verbose&gt;<br>                    &lt;overwrite&gt;<span class="hljs-literal">true</span>&lt;/overwrite&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br></code></pre></td></tr></table></figure><p><strong>（2）配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">server.port=<span class="hljs-number">8081</span><br>server.servlet.context-path=/<br><br><br>spring.application.name=springboot-ssm-provider<br>spring.dubbo.server=<span class="hljs-literal">true</span><br>spring.dubbo.registry=zookeeper:<span class="hljs-comment">//192.168.86.129:2181</span><br><br>#mybatis核心配置<br>spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver<br>spring.datasource.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/springbootuse?Unicode=true&amp;characterEncoding=UTF8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8</span><br>spring.datasource.username=root<br>spring.datasource.password=Zlw0502<br><br>#redis<br>spring.redis.host=<span class="hljs-number">192.168</span><span class="hljs-number">.86</span><span class="hljs-number">.129</span><br>spring.redis.port=<span class="hljs-number">6379</span><br>spring.redis.password=Zlw199805<br></code></pre></td></tr></table></figure><p><strong>（3）使用mybatis逆向工程生成的mapper接口和mapper.xml文件，以及StudentServiceImpl.java</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220615113656884.png" alt="image-20220615113656884"></p><p><strong>StudentServiceImpl.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Service(interfaceClass = StudentService.class, version = &quot;1.0.0&quot;, timeout=15000)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentService</span>&#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;Object,Object&gt; redisTemplate;<br>    <br>    <span class="hljs-comment">//根据学生id查询学生信息</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">queryDetail</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> studentMapper.selectByPrimaryKey(id);<br>        <span class="hljs-keyword">return</span> student;<br>    &#125;<br><br>    <span class="hljs-comment">//使用到redis，查询所有学生的个数</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">queryCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">studentCount</span> <span class="hljs-operator">=</span> (Integer) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;studentCount&quot;</span>);<br>        <span class="hljs-keyword">if</span> (studentCount==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> studentMapper.queryStudentCount();<br>            redisTemplate.opsForValue().set(<span class="hljs-string">&quot;studentCount&quot;</span>,i,<span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> studentCount;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p><strong>（1）配置依赖</strong>（Dubbo、zookeeper、jsp依赖、接口工程依赖）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.101tec&lt;/groupId&gt;<br>            &lt;artifactId&gt;zkclient&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">0.10</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br><br>&lt;!--        Springboot集成jsp，仅仅只是需要展示JSP页面需要添加解析jsp页面依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;<br>            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        <br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.zlw.springboot&lt;/groupId&gt;<br>            &lt;artifactId&gt;springboot-ssm-interface&lt;/artifactId&gt;<br>            &lt;version&gt;<span class="hljs-number">1.0</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>        &lt;/dependency&gt;<br>   <br></code></pre></td></tr></table></figure><p>找到jsp文件的资源路径配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;resources&gt;<br>            &lt;resource&gt;<br>                &lt;directory&gt;src/main/webapp&lt;/directory&gt;<br>                &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;<br>                &lt;includes&gt;<br>                    &lt;include&gt;*.*&lt;/include&gt;<br>                &lt;/includes&gt;<br>            &lt;/resource&gt;<br>        &lt;/resources&gt;<br></code></pre></td></tr></table></figure><p><strong>（2）配置核心配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>server.port=<span class="hljs-number">8080</span><br>server.servlet.context-path=/<br><br>spring.application.name=springboot-ssm-customer<br>spring.dubbo.registry=zookeeper:<span class="hljs-comment">//192.168.86.129:2181</span><br><br>#配置视图解析器<br>spring.mvc.view.prefix=/<br>spring.mvc.view.suffix=.jsp<br>    <br>#设置请求响应的字符编码<br>server.servlet.encoding.enabled=<span class="hljs-literal">true</span><br>server.servlet.encoding.force=<span class="hljs-literal">true</span><br>server.servlet.encoding.charset=UTF-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>（3）Contorller层和jsp文件</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220615114401829.png" alt="image-20220615114401829"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentController</span> &#123;<br><br>    <span class="hljs-meta">@Reference(interfaceClass = StudentService.class, version = &quot;1.0.0&quot;, check = false)</span><br>    <span class="hljs-keyword">private</span> StudentService studentService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/student/detail/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">StudentDetail</span><span class="hljs-params">(Model model, <span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;<br>       <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span>  studentService.queryDetail(id);<br>       model.addAttribute(<span class="hljs-string">&quot;student&quot;</span>,student);<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用redis</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/student/count&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> Object <span class="hljs-title function_">StudentCount</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> studentService.queryCount();<br>      <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;学生信息&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h3&gt;学生编号为：$&#123;student.id&#125;&lt;/h3&gt;<br>&lt;h3&gt;学生姓名为：$&#123;student.name&#125;&lt;/h3&gt;<br>&lt;h3&gt;学生年龄为：$&#123;student.age&#125;&lt;/h3&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure><h1 id="springboot-非web应用程序（了解）"><a href="#springboot-非web应用程序（了解）" class="headerlink" title="springboot 非web应用程序（了解）"></a>springboot 非web应用程序（了解）</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p><strong>在 Application 类的 main 方法中，获取容器，调用业务 bean</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * SpringBoot 程序启动后，返回值是 ConfigurableApplicationContext，它也是一个</span><br><span class="hljs-comment">        Spring 容器对象</span><br><span class="hljs-comment">        * 它其它相当于原来 Spring 中启动容器 ClassPathXmlApplicationContext context =</span><br><span class="hljs-comment">        new ClassPathXmlApplicationContext(&quot;&quot;);</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//获取 SpringBoot 程序启动后的 Spring 容器</span><br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span>SpringApplication.run(Application.class, args);<br>        <span class="hljs-comment">//从 Spring 容器中获取指定 bean 的对象</span><br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> (UserService) context.getBean(<span class="hljs-string">&quot;userServiceImpl&quot;</span>);<br>        <span class="hljs-comment">//调用业务 bean 的方法</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sayHello</span> <span class="hljs-operator">=</span> userService.sayHello();<br>        System.out.println(sayHello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>**实现 CommandLineRunner 接口  **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;<br>    <span class="hljs-comment">//第二步：通过容器获取 bean，并注入给 userService</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//第一步： SpringBoot 的启动程序，会初始化 spring 容器</span><br>        SpringApplication.run(Application2.class,args);<br>    &#125;<br>    <span class="hljs-comment">//覆盖接口中的 run 方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//第三步：容器启动后调用 run 方法，在该方法中调用业务方法</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sayHello</span> <span class="hljs-operator">=</span> userService.sayHello();<br>        System.out.println(sayHello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SpringBoot使用拦截器"><a href="#SpringBoot使用拦截器" class="headerlink" title="SpringBoot使用拦截器"></a>SpringBoot使用拦截器</h1><p><strong>（1）创建拦截器类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;--------编写拦截规则-------&quot;</span>);<br>        <span class="hljs-comment">//编写拦截规则</span><br>        <span class="hljs-comment">//true：通过</span><br>        <span class="hljs-comment">//false：不通过</span><br>        <span class="hljs-comment">//从 session 中获取结果</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> (Integer) request.getSession().getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == code) &#123;<br>        response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/user/error&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span><br><span class="hljs-params">    Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span><br><span class="hljs-params">    Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）@Configuration 定义配置类-拦截器</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//用于定义配置类，可替换 xml 文件；定义一个拦截器，相当于之前的mvc 里的配置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//定义需要拦截的路径</span><br>        String[] addPathPatterns = &#123;<br>        <span class="hljs-string">&quot;/user/**&quot;</span>,<br>        &#125;;<br>        <span class="hljs-comment">//定义不需要拦截的路径</span><br>        String[] excludePathPatterns = &#123;<br>        <span class="hljs-string">&quot;/user/error&quot;</span>,<br>        <span class="hljs-string">&quot;/user/verifyRealName&quot;</span><br>        &#125;;<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInterceptor</span>()) <span class="hljs-comment">//添加要注册的拦截器对象</span><br>    .addPathPatterns(addPathPatterns) <span class="hljs-comment">//添加需要拦截的路径</span><br>    .excludePathPatterns(excludePathPatterns); <span class="hljs-comment">//添加不需要拦截的路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Spring-Boot-中使用-Servlet（了解）"><a href="#Spring-Boot-中使用-Servlet（了解）" class="headerlink" title="Spring Boot 中使用 Servlet（了解）"></a>Spring Boot 中使用 Servlet（了解）</h1><h2 id="方式一：通过注解扫描方式实现"><a href="#方式一：通过注解扫描方式实现" class="headerlink" title="方式一：通过注解扫描方式实现"></a>方式一：通过注解扫描方式实现</h2><p><strong>（1）创建 MyServlet.class</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(urlPatterns = &quot;/myServlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse esponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        response.getWriter().print(<span class="hljs-string">&quot;My SpringBoot Servlet&quot;</span>);<br>        response.getWriter().flush();<br>        response.getWriter().close();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(request,response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**（2）在 主 应 用 程 序 Application 类 上 添 加@ServletComponentScan(“com.abc.springboot.servlet”)  **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@ServletComponentScan(basePackages = &quot;com.abc.springboot.servlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方式二：通过-SpringBoot-的配置类实现（组件注册）"><a href="#方式二：通过-SpringBoot-的配置类实现（组件注册）" class="headerlink" title="方式二：通过 SpringBoot 的配置类实现（组件注册）"></a>方式二：通过 SpringBoot 的配置类实现（组件注册）</h2><p><strong>（1）创建一个普通的 Servlet</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.getWriter().print(<span class="hljs-string">&quot;Hello,SpringBoot Servlet!&quot;</span>);<br>        resp.getWriter().flush();<br>        resp.getWriter().close();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req,resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）编写一个 Spring Boot 的配置类，在该类中注册 Servlet</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//将此类作为配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletConfig</span> &#123;<br>    <span class="hljs-comment">//@Bean 是一个方法级别上的注解，主要用在配置类里</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 相当于一个&lt;beans&gt;</span><br><span class="hljs-comment">    * &lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br><span class="hljs-comment">    * &lt;/beans&gt;</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title function_">myServletRegistrationBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//将自定义 servlet 注册到注册 Servlet 类中，并指定访问路径</span><br>        <span class="hljs-type">ServletRegistrationBean</span> <span class="hljs-variable">servletRegistrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>        <span class="hljs-title class_">ServletRegistrationBean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServlet</span>(), <span class="hljs-string">&quot;/springboot/myServlet&quot;</span>);<br>        <span class="hljs-keyword">return</span> servletRegistrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Spring-Boot-中使用-Filter（了解）"><a href="#Spring-Boot-中使用-Filter（了解）" class="headerlink" title="Spring Boot 中使用 Filter（了解）"></a>Spring Boot 中使用 Filter（了解）</h1><h2 id="方式一：通过注解方式实现"><a href="#方式一：通过注解方式实现" class="headerlink" title="方式一：通过注解方式实现"></a>方式一：通过注解方式实现</h2><p><strong>（1）通过注解方式创建一个 Filer</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(urlPatterns = &quot;/springboot/myFilter&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse,FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;-------------您已进入过滤器---------------&quot;</span>);<br>        filterChain.doFilter(servletRequest,servletResponse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）在 主 应 用 程 序 Application 类 上 添 加@ServletComponentScan(“basePackages &#x3D; “com.abc.springboot.filter”)</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ServletComponentScan(basePackages = &quot;com.abc.springboot.filter&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方式二-通过-Spring-Boot-的配置类实现"><a href="#方式二-通过-Spring-Boot-的配置类实现" class="headerlink" title="方式二 通过 Spring Boot 的配置类实现"></a>方式二 通过 Spring Boot 的配置类实现</h2><p><strong>（1）创建 MyFilter 类</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse,FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;---------------通过配置类注册过滤器-------------------&quot;</span>);<br>        filterChain.doFilter(servletRequest,servletResponse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）编写一个 Spring Boot 的配置类，在该类中注册 Filter</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//定义为配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">myFilterRegistration</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//注册过滤器</span><br>        <span class="hljs-type">FilterRegistrationBean</span> <span class="hljs-variable">filterRegistrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFilter</span>());<br>        <span class="hljs-comment">//添加过滤路径</span><br>        filterRegistrationBean.addUrlPatterns(<span class="hljs-string">&quot;/springboot/*&quot;</span>,<span class="hljs-string">&quot;/user/*&quot;</span>);<br>        <span class="hljs-keyword">return</span> filterRegistrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Spring-Boot-项目配置字符编码"><a href="#Spring-Boot-项目配置字符编码" class="headerlink" title="Spring Boot 项目配置字符编码"></a>Spring Boot 项目配置字符编码</h2><p><strong>响应到html页面的时候，中文会出现乱码，解决这个问题：</strong></p><h2 id="方式一：使用传统的-Spring-提供的字符编码过滤器"><a href="#方式一：使用传统的-Spring-提供的字符编码过滤器" class="headerlink" title="方式一：使用传统的 Spring 提供的字符编码过滤器"></a>方式一：使用传统的 Spring 提供的字符编码过滤器</h2><p><strong>（1）创建一个 Servlet</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.getWriter().print(<span class="hljs-string">&quot;Hello World，世界您好！ &quot;</span>);<br>        <span class="hljs-comment">//设置浏览器编码格式</span><br>        resp.setContentType(<span class="hljs-string">&quot;text/html;character=utf-8&quot;</span>);<br>        resp.getWriter().flush();<br>        resp.getWriter().close();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）创建配置类 SystemConfig</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//设置为配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title function_">myServletRegistration</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ServletRegistrationBean</span> <span class="hljs-variable">servletRegistrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRegistrationBean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServlet</span>(),<br>    <span class="hljs-string">&quot;/springboot/myServlet&quot;</span>);<br>    <span class="hljs-keyword">return</span> servletRegistrationBean;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">characterFilterRegistration</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//设置字符编码过滤器</span><br>        <span class="hljs-comment">//CharacterEncoding 是由 Spring 提供的一个字符编码过滤器，之前是配置在</span><br>        web.xml 文件中<br>        <span class="hljs-type">CharacterEncodingFilter</span> <span class="hljs-variable">characterEncodingFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>        <span class="hljs-title class_">CharacterEncodingFilter</span>();<br>        <span class="hljs-comment">//强制使用指定字符编码</span><br>        characterEncodingFilter.setForceEncoding(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//设置指定字符编码</span><br>        characterEncodingFilter.setEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-comment">//创建过滤器注册 bean</span><br>        <span class="hljs-type">FilterRegistrationBean</span> <span class="hljs-variable">filterRegistrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>        <span class="hljs-title class_">FilterRegistrationBean</span>();<br>        <span class="hljs-comment">//设置字符编码过滤器</span><br>        filterRegistrationBean.setFilter(characterEncodingFilter);<br>        <span class="hljs-comment">//设置字符编码过滤器路径</span><br>        filterRegistrationBean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        <span class="hljs-keyword">return</span> filterRegistrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）关闭 SpringBoot 的 http 字符编码支持</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">#关闭 springboot 的 http 字符编码支持<br>#只有关闭该选项后， spring 字符编码过滤器才生效<br>spring.http.encoding.enabled=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="方式二-在-application-properties-中配置字符编码（推荐）"><a href="#方式二-在-application-properties-中配置字符编码（推荐）" class="headerlink" title="方式二 在 application.properties 中配置字符编码（推荐）"></a>方式二 在 application.properties 中配置字符编码（推荐）</h2><p><strong>（1）SpringBoot 核心配置文件添加字符编码设置</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">#设置请求响应的字符编码<br>server.servlet.encoding.enabled=<span class="hljs-literal">true</span><br>server.servlet.encoding.force=<span class="hljs-literal">true</span><br>server.servlet.encoding.charset=UTF-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>（2）创建 Servlet</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.getWriter().print(<span class="hljs-string">&quot;Hello World!世界您真好！ &quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;character=utf-8&quot;</span>);<br>        resp.getWriter().flush();<br>        resp.getWriter().close();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）创建配置类 ServletConfig</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title function_">myServletRegistration</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ServletRegistrationBean</span> <span class="hljs-variable">servletRegistrationBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRegistrationBean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServlet</span>(),<span class="hljs-string">&quot;/myservlet&quot;</span>);<br>    <span class="hljs-keyword">return</span> servletRegistrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Springboot-打war包"><a href="#Springboot-打war包" class="headerlink" title="Springboot 打war包"></a>Springboot 打war包</h1><p><strong>（1）程序入口类需扩展继承 SpringBootServletInitializer类并覆盖 configure 方法</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootServletInitializer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    SpringApplication.run(Application.class, args);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> SpringApplicationBuilder<br>        <span class="hljs-title function_">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> &#123;<br>        <span class="hljs-comment">//参数为当前 SpringBoot 启动类</span><br>        <span class="hljs-keyword">return</span> builder.sources(Application.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）在 pom.xml 中添加（修改）打包方式为 war</strong>  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>（3）在 pom.xml 中配置将配置文件编译到类路径</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;resource&gt;<br>    &lt;!--源文件夹--&gt;<br>    &lt;directory&gt;src/main/webapp&lt;/directory&gt;<br>    &lt;!--目标文件夹--&gt;<br>    &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;<br>    &lt;!--包含的文件--&gt;<br>    &lt;includes&gt;<br>    &lt;include&gt;**<span class="hljs-comment">/*.*&lt;/include&gt;</span><br><span class="hljs-comment">    &lt;/includes&gt;</span><br><span class="hljs-comment">&lt;/resource&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;!--mybatis 的 mapper.xml--&gt;</span><br><span class="hljs-comment">&lt;resource&gt;</span><br><span class="hljs-comment">    &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="hljs-comment">    &lt;includes&gt;</span><br><span class="hljs-comment">    &lt;include&gt;**/</span>*.xml&lt;/include&gt;<br>    &lt;/includes&gt;<br>&lt;/resource&gt;<br><br>&lt;!--src/main/resources 下的所有配置文件编译到 classes 下面去--&gt;<br>&lt;resource&gt;<br>    &lt;directory&gt;src/main/resources&lt;/directory&gt;<br>    &lt;includes&gt;<br>    &lt;include&gt;**<span class="hljs-comment">/*.*&lt;/include&gt;</span><br><span class="hljs-comment">    &lt;/includes&gt;</span><br><span class="hljs-comment">&lt;/resource&gt;</span><br></code></pre></td></tr></table></figure><p><strong>（4）在 pom.xml 的 build 标签下通过 finalName 指定打 war包的名字</strong>  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定打 war 包的名字--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>springboot<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220615151757874.png" alt="image-20220615151757874"></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220615151803259.png" alt="image-20220615151803259"></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220615151818090.png" alt="image-20220615151818090"></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220615151833364.png" alt="image-20220615151833364"></p><p><strong>linux中也是同样的操作</strong></p><h1 id="Spring-Boot-程序打-Jar-包与运行"><a href="#Spring-Boot-程序打-Jar-包与运行" class="headerlink" title="Spring Boot 程序打 Jar 包与运行"></a>Spring Boot 程序打 Jar 包与运行</h1><p><strong>在 pom.xml 文件中添加 resources 配置，以后为了保险起见，大家在打包的时候，建议把下面的配置都加上</strong>  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--源文件夹--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/webapp<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--目标文件夹--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>META-INF/resources<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--包含的文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--mybatis 的 mapper.xml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--src/main/resources 下的所有配置文件编译到 classes 下面去--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>修改 pom.xml 文件中打包插件的版本</strong>  </p><p>(默认 SpingBoot 提供的打包插件版本为 2.2.2.RELEASE，这个版本打的 jar 包 jsp 不能访问，我们这里修改为 1.4.2.RELEASE（其它版本测试都有问题）  )</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringBoot 提供打包编译插件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>将jar包拷贝到一个目录，在该目录下面 执行jar包。</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220618163502536.png" alt="image-20220618163502536"></p><p><strong>在linux中的运行:</strong></p><p>(1)写一个 shell 脚本(run.sh)：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>java -jar xxx.jar<br></code></pre></td></tr></table></figure><p>(2)赋权限 <code>chmod 777 run.sh</code>  </p><p>(3)启动 shell 脚本： <code>./run.sh</code>  </p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220618163724892.png" alt="image-20220618163724892"></p><h1 id="SpringBoot-集成-logback-日志"><a href="#SpringBoot-集成-logback-日志" class="headerlink" title="SpringBoot 集成 logback 日志"></a>SpringBoot 集成 logback 日志</h1><p><strong>（1）添加日志依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--@Slf4j 自动化日志对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>（2）添加 lombok 插件</strong>  </p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220618163956006.png" alt="image-20220618163956006"></p><p><strong>（3）添加logback.xml  配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;!-- 日志级别从低到高分为 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为 WARN，则低于 WARN 的信息都不会输出 --&gt;<br>&lt;!-- scan:当此属性设置为 <span class="hljs-literal">true</span> 时，配置文件如果发生改变，将会被重新加载，默认值为<span class="hljs-literal">true</span> --&gt;<br>&lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当 scan 为 <span class="hljs-literal">true</span> 时，此属性生效。默认的时间间隔为 <span class="hljs-number">1</span> 分钟。 --&gt;<br>&lt;!-- debug:当此属性设置为 <span class="hljs-literal">true</span> 时，将打印出 logback 内部日志信息，实时查看 logback运行状态。默认值为 <span class="hljs-literal">false</span>。通常不打印 --&gt;<br>&lt;configuration scan=<span class="hljs-string">&quot;true&quot;</span> scanPeriod=<span class="hljs-string">&quot;10 seconds&quot;</span>&gt;<br>    &lt;!--输出到控制台--&gt;<br>    &lt;appender name=<span class="hljs-string">&quot;CONSOLE&quot;</span> class=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;<br>        &lt;!--此日志 appender 是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;<br>        &lt;filter class=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;<br>            &lt;level&gt;debug&lt;/level&gt;<br>        &lt;/filter&gt;<br>        &lt;encoder&gt;<br>            &lt;Pattern&gt;%date [%-5p] [%thread] %logger&#123;<span class="hljs-number">60</span>&#125;[%file : %line] %msg%n&lt;/Pattern&gt;<br>            &lt;!-- 设置字符集 --&gt;<br>            &lt;charset&gt;UTF-<span class="hljs-number">8</span>&lt;/charset&gt;<br>        &lt;/encoder&gt;<br>    &lt;/appender&gt;<br>    &lt;appender name=<span class="hljs-string">&quot;FILE&quot;</span> class=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;<br>        &lt;!--&lt;File&gt;/home/log/stdout.log&lt;/File&gt;--&gt;<br>        &lt;File&gt;E:/java-log/springboot&lt;/File&gt;<br>        &lt;encoder&gt;<br>            &lt;pattern&gt;%date [%-5p] %thread %logger&#123;<span class="hljs-number">60</span>&#125; [%file : %line] %msg%n&lt;/pattern&gt;<br>        &lt;/encoder&gt;<br>        &lt;rollingPolicy class=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;<br>            &lt;!-- 添加.gz 历史日志会启用压缩 大大缩小日志文件所占空间 --&gt;<br>            &lt;!--&lt;fileNamePattern&gt;/home/log/stdout.log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;--&gt;<br>            &lt;fileNamePattern&gt;D:/log/stdout.log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;<br>            &lt;maxHistory&gt;<span class="hljs-number">30</span>&lt;/maxHistory&gt;&lt;!-- 保留 <span class="hljs-number">30</span> 天日志 --&gt;<br>        &lt;/rollingPolicy&gt;<br>    &lt;/appender&gt;<br>    &lt;logger name=<span class="hljs-string">&quot;com.zlw.springboot.mapper&quot;</span> level=<span class="hljs-string">&quot;DEBUG&quot;</span> /&gt;<br>    &lt;root level=<span class="hljs-string">&quot;INFO&quot;</span>&gt;<br>        &lt;appender-ref ref=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;<br>        &lt;appender-ref ref=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;<br>    &lt;/root&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure><p><strong>控制台的效果：</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220618180520506.png" alt="image-20220618180520506"></p><p><strong>打印输出的log文件：</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220618180548192.png" alt="image-20220618180548192"></p><h1 id="SpringBoot-集成-Thymeleaf-模板"><a href="#SpringBoot-集成-Thymeleaf-模板" class="headerlink" title="SpringBoot 集成 Thymeleaf 模板"></a>SpringBoot 集成 Thymeleaf 模板</h1><p>它是基于 HTML 的，以 HTML 标签为载体，Thymeleaf 要寄托在 HTML 标签下实现。  </p><p>在过去的 Java Web 开发中，我们往往会选择使用 Jsp 去完成页面的动态渲染， 但是 jsp 需要翻译编译运行，效率低  </p><p><strong>（1）创建springboot工程的时候，选择</strong></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220618212058705.png" alt="image-20220618212058705"></p><p><strong>（2）按照这种方式创建后， pom.xml 文件下会自动添加如下依赖</strong>  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringBoot 集成 Thymeleaf 的起步依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--SpringBoot 开发 web 项目的起步依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>（3）在 Spring boot 的核心配置文件 application.properties 中对Thymeleaf 进行配置</strong>  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#thymeleaf 页面的缓存开关，默认 true 开启缓存</span><br><span class="hljs-comment">#建议在开发阶段关闭 thymeleaf 页面缓存，目的实时看到页面</span><br>spring.thymeleaf.<span class="hljs-attribute">cache</span>=<span class="hljs-literal">false</span><br>前缀：<br><span class="hljs-comment">#thymeleaf 模版前缀,默认可以不写</span><br>spring.thymeleaf.<span class="hljs-attribute">prefix</span>=classpath:/templates/<br>后缀：<br><span class="hljs-comment">#thymeleaf 模版后缀,默认可以不写</span><br>spring.thymeleaf.<span class="hljs-attribute">suffix</span>=.html<br></code></pre></td></tr></table></figure><p><strong>（4）在src&#x2F;main&#x2F;resources 的 templates 下  创建html页面，</strong></p><p><strong>注意：</strong>要在html页面的开头加上：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;html <span class="hljs-attribute">lang</span>=<span class="hljs-string">&quot;en&quot;</span> xmlns:<span class="hljs-attribute">th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="Thymeleaf表达式"><a href="#Thymeleaf表达式" class="headerlink" title="Thymeleaf表达式"></a>Thymeleaf表达式</h2><h2 id="标准表达式"><a href="#标准表达式" class="headerlink" title="标准表达式"></a>标准表达式</h2><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220618222710429.png" alt="image-20220618222710429"></p><h2 id="URL路径表达式"><a href="#URL路径表达式" class="headerlink" title="URL路径表达式"></a>URL路径表达式</h2><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220618222827595.png" alt="image-20220618222827595"></p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220618222414089.png" alt="image-20220618222414089"></p><h2 id="内敛脚本"><a href="#内敛脚本" class="headerlink" title="内敛脚本"></a>内敛脚本</h2><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220619102916847.png" alt="image-20220619102916847"></p><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220619104001736.png" alt="image-20220619104001736"></p><p><img src="/2022/06/06/SpringBoot%E5%85%A5%E9%97%A8/image-20220619105847364.png" alt="image-20220619105847364"></p><h1 id="补充-Data"><a href="#补充-Data" class="headerlink" title="补充@Data"></a>补充@Data</h1><p><strong>@Data注解放在类上面，并且加上配置文件的时候，在IDEA中下载插件lombok。定义的实体类可以不用实现，set和get方法，。</strong></p><p><strong>加上其中的配置文件：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h1>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的深度</title>
    <link href="/2022/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
    <url>/2022/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–104-（简单）"><a href="#leetCode–104-（简单）" class="headerlink" title="leetCode–104 （简单）"></a>leetCode–104 （简单）</h1><p><strong>给定一个二叉树，找出其最大深度。</strong></p><p><strong>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</strong></p><p><strong>说明: 叶子节点是指没有子节点的节点。</strong></p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h2 id="解法一：深度优先遍历"><a href="#解法一：深度优先遍历" class="headerlink" title="解法一：深度优先遍历"></a>解法一：深度优先遍历</h2><p><strong>先判断根节点是否为空，如果为空直接返回0。</strong></p><p><strong>之后在判断，根节点的左子树和右子树的最大深度+1（加1表示根节点）</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：广度优先遍历"><a href="#解法二：广度优先遍历" class="headerlink" title="解法二：广度优先遍历"></a>解法二：广度优先遍历</h2><p><strong>一般广度优先遍历都要维护一个队列</strong></p><p><strong>在本题中有一个不同与广度优先搜索中的每次只拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展</strong></p><p><strong>就是队列中存放的是，当前层的所有节点。每次循环遍历，将移除该层的所有节点，再把下一层的所有节点全部放入到队列中。</strong></p><p><strong>这也就形成了，我们是按照层来遍历的，每遍历一层，结果的数量就+1</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        deque.addLast(root);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> deque.size();<br>            <span class="hljs-keyword">while</span> (size&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> deque.removeFirst();<br>                <span class="hljs-keyword">if</span> (t.left!=<span class="hljs-literal">null</span>) deque.addLast(t.left);<br>                <span class="hljs-keyword">if</span> (t.right!=<span class="hljs-literal">null</span>) deque.addLast(t.right);<br>                size--;<br>            &#125;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称二叉树</title>
    <link href="/2022/06/04/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/06/04/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="leetCode–101（简单）"><a href="#leetCode–101（简单）" class="headerlink" title="leetCode–101（简单）"></a>leetCode–101（简单）</h1><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="/2022/06/04/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220606144805694.png" alt="image-20220606144805694"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2022/06/04/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220606144812289.png" alt="image-20220606144812289"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="解法一：自己"><a href="#解法一：自己" class="headerlink" title="解法一：自己"></a>解法一：自己</h2><p>哈哈哈哈，笑死了   我这算是什么解法~~</p><p>前序遍历，后序遍历，之后将后序遍历逆转，比较两个list是否相等。后来发现使用我这种方法，[1,2,2,null,3,null,3]这个用例过不去，因此将null值也加入了进去，瞎整~~过了。太菜了太菜了  不要看这个了  ，还是看大佬们的题解把</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>    List&lt;Integer&gt; prelist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; laselist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.left==<span class="hljs-literal">null</span> &amp;&amp; root.right==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root.left==<span class="hljs-literal">null</span> || root.right==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root;<br>        last = root;<br>        <span class="hljs-comment">//前序排列</span><br>        <span class="hljs-keyword">if</span> (pre!=<span class="hljs-literal">null</span>)&#123;<br>            preSort(pre);<br>        &#125;<br>        <span class="hljs-comment">//后序排序</span><br>        <span class="hljs-keyword">if</span> (last!=<span class="hljs-literal">null</span>)&#123;<br>            lastSort(last);<br>        &#125;<br>        Collections.reverse(laselist);<br>        <span class="hljs-keyword">return</span> prelist.equals(laselist);<br>    &#125;<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preSort</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>            prelist.add(root.val);<br>            <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>) preSort(root.left);<br>            <span class="hljs-keyword">else</span> prelist.add(<span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (root.right!=<span class="hljs-literal">null</span>) preSort(root.right);<br>            <span class="hljs-keyword">else</span> prelist.add(<span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//中序遍历</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lastSort</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>) lastSort(root.left);<br>            <span class="hljs-keyword">else</span>  laselist.add(<span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (root.right!=<span class="hljs-literal">null</span>) lastSort(root.right);<br>            <span class="hljs-keyword">else</span> laselist.add(<span class="hljs-literal">null</span>);<br>            laselist.add(root.val);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>如果一个数是对称的，则左子树和右子树互为镜像。因此可以转化为，两个树在什么情况下互为镜像？</p><p>两个树互为镜像？</p><ul><li>它们的两个根结点具有相同的值</li><li>每个树的右子树都与另一个树的左子树镜像对称</li></ul><p><img src="/2022/06/04/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/image-20220606144835399.png" alt="image-20220606144835399"></p><p>​也就是将一个树变成两个树进行比较。</p><p><img src="/2022/06/04/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/2449af8862537df2cbbc45a07764415c1a10769677c822fa271ea7447c8fa128-2.gif" alt="2.gif"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//比较两个树是否互为镜像</span><br>        <span class="hljs-keyword">return</span> check(root, root);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(TreeNode p,TreeNode q)</span>&#123;<br>        <span class="hljs-comment">//都没有元素  说明相等</span><br>        <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">null</span> &amp;&amp; q==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//一个有，一个没有  不相等</span><br>        <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">null</span> || q==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (p.val==q.val) &#123;<br>            <span class="hljs-comment">//值相等  可以进行下一步比较</span><br>            <span class="hljs-keyword">return</span> check(p.left,q.right) &amp;&amp; check(p.right,q.left);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//值不相等 直接return false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：迭代"><a href="#解法三：迭代" class="headerlink" title="解法三：迭代"></a>解法三：迭代</h2><p><strong>将递归程序转换为迭代程序，最常用的方法就是引入一个队列。</strong></p><p><img src="/2022/06/04/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/45a663b08efaa14193d63ef63ae3d1d130807467d13707f584906ad3af4adc36-1.gif" alt="1.gif"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root.left==<span class="hljs-literal">null</span> &amp;&amp; root.right==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root.left==<span class="hljs-literal">null</span> || root.right==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//用队列保存节点</span><br>        Deque&lt;TreeNode&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">//将左右节点加入队列中</span><br>        deque.addLast(root.left);<br>        deque.addLast(root.right);<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty())&#123;<br>            <span class="hljs-comment">//从队列中取出两个节点，再比较这两个节点</span><br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> deque.removeFirst();<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> deque.removeFirst();<br>            <span class="hljs-comment">//两个都为空值 则继续进行下面的比较， 两者有一个为空就返回false</span><br>            <span class="hljs-keyword">if</span> (l==<span class="hljs-literal">null</span> &amp;&amp; r==<span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (l==<span class="hljs-literal">null</span> || r==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (l.val!=r.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">//值相等 继续进行下面的比较</span><br>            <span class="hljs-comment">//将左节点的左孩子， 右节点的右孩子放入队列</span><br>            deque.addLast(l.left);<br>            deque.addLast(r.right);<br>            <span class="hljs-comment">//将左节点的右孩子，右节点的左孩子放入队列</span><br>            deque.addLast(l.right);<br>            deque.addLast(r.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> deque.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十大排序算法</title>
    <link href="/2022/06/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/06/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>两两进行比较，进行一遍遍历就将最大的数放到最右端。放在最右端的数在下一次遍历中不用遍历，因为已经是有序的。<br><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 冒泡排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n-<span class="hljs-number">1</span>-i;j++)&#123;<br>            <span class="hljs-keyword">if</span> (arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>也可以进行一下简单的优化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 冒泡排序的优化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        f = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n-<span class="hljs-number">1</span>-i;j++)&#123;<br>            <span class="hljs-keyword">if</span> (arr[j]&gt;arr[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[j];<br>                arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>] = t;<br>                f = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (f== <span class="hljs-literal">false</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><strong>将第一个元素看作有序序列，从数组的第二个位置进行扫描，依次与它之前的数字进行比较，如果遍历到的数字小于前面已经遍历过的数，则前面的数依次后移，直到找到不大于该数的位置，停止本次的遍历，讲该数放入得到这个位置中。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">插入排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[j];<br>        <span class="hljs-keyword">if</span> (t&lt;arr[j-<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">while</span> (j-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; t&lt;arr[j-<span class="hljs-number">1</span>])&#123;<br>                arr[j] = arr[j-<span class="hljs-number">1</span>];<br>                j--;<br>            &#125;<br>        &#125;<br>        arr[j] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p><strong>如果是从小到大的排序，从序列中找到最小元素放入开头，再从剩下的序列中找到最小元素，依次放入之后，依次进行。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 选择排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> min;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>        min = arr[j];<br>        t = j;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> j+<span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;<br>                min = arr[i];<br>                t = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t!=j)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> arr[j];<br>            arr[j] = arr[t];<br>            arr[t] = m;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p><strong>与插入排序类似，插入排序是每次与它前一个元素进行比较，而希尔排序是每次进行几跳的元素比较。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 希尔排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> n/<span class="hljs-number">2</span>;gap&gt;<span class="hljs-number">0</span>;gap = gap/<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap;i&lt;n;i++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>                <span class="hljs-keyword">if</span> (arr[j-gap]&gt;t)&#123;<br>                    <span class="hljs-keyword">while</span> (j-gap&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j-gap]&gt;t)&#123;<br>                        arr[j] = arr[j-gap];<br>                        j = j-gap;<br>                    &#125;<br>                &#125;<br>                arr[j] = t;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>找到一个基准值，每次将比基准值小的数放在基准值的左边，比基准值大的数放在基准值的右边。</strong><br><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 快速排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> l</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-keyword">if</span> (l&lt;r)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> sort(arr,l,r);<br>            quickSort(arr,l,index-<span class="hljs-number">1</span>);<br>            quickSort(arr,index+<span class="hljs-number">1</span>,r);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[l];<br>        <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>            <span class="hljs-keyword">while</span> (l&lt;r &amp;&amp; arr[r]&gt;=t)&#123;<br>                r--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[r]&lt;t)&#123;<br>                arr[l] = arr[r];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (l&lt;r &amp;&amp; arr[l]&lt;=t)&#123;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (arr[l]&gt;t)&#123;<br>                arr[r] = arr[l];<br>            &#125;<br>        &#125;<br>        arr[l] = t;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="解法一：递归写法"><a href="#解法一：递归写法" class="headerlink" title="解法一：递归写法"></a>解法一：递归写法</h2><p><strong>把一组n个数的序列，折半分为两个序列，然后再将这两个序列再分，一直分下去，直到分为n个长度为1的序列。然后两两按大小归并。如此反复，直到最后形成包含n个数的一个数组。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">归并排序，递归写法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span>&#123;<br>    <span class="hljs-keyword">if</span> (l&lt;r)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l+r)/<span class="hljs-number">2</span>;<br>        mergeSort(arr,l,mid);<br>        mergeSort(arr,mid+<span class="hljs-number">1</span>,r);<br>        merge(arr,l,r,mid);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> mid)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> temp[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=r)&#123;<br>        <span class="hljs-keyword">if</span> (arr[i]&lt;arr[j])&#123;<br>            temp[index++] = arr[i];<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            temp[index++] = arr[j];<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i&lt;=mid)&#123;<br>        temp[index++] = arr[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j&lt;=r)&#123;<br>        temp[index++] = arr[j++];<br>    &#125;<br>    <span class="hljs-comment">//临时数组复制到原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;a&lt;index;a++)&#123;<br>        arr[l++] = temp[a];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：非递归解法"><a href="#解法二：非递归解法" class="headerlink" title="解法二：非递归解法"></a>解法二：非递归解法</h2><p><img src="/2022/06/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220810100711112.png" alt="image-20220810100711112"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 归并排序，非递归写法</span><br><span class="hljs-comment">    * 递归方法的归并是，将原始数组一点一点缩小，而非递归相当于二叉树，从数的叶子节点开始合并</span><br><span class="hljs-comment">    * 合并时，数组的个数为1，2，4，8，。。。</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>       <span class="hljs-type">int</span> l,mid,r;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i = i+i)&#123;<br>           l = <span class="hljs-number">0</span>;<br>           mid = l+i-<span class="hljs-number">1</span>;<br>           r = mid+i;<br>           <span class="hljs-keyword">while</span> (r&lt;n)&#123;<br>               <span class="hljs-comment">//合并数组</span><br>               merge(arr,l,r,mid);<br>               l = r+<span class="hljs-number">1</span>;<br>               mid = l+i-<span class="hljs-number">1</span>;<br>               r = mid+i;<br>           &#125;<br>           <span class="hljs-comment">//还有一些被遗漏的数组没合并，因为不可能每个数组的大小都刚好为i</span><br>           <span class="hljs-keyword">if</span> (l&lt;n &amp;&amp; mid&lt;n)&#123;<br>               merge(arr,l,n-<span class="hljs-number">1</span>,mid);<br>           &#125;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> mid)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> mid+<span class="hljs-number">1</span>;<br>       <span class="hljs-type">int</span> temp[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>       <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=r)&#123;<br>           <span class="hljs-keyword">if</span> (arr[i]&lt;arr[j])&#123;<br>               temp[index++] = arr[i];<br>               i++;<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               temp[index++] = arr[j];<br>               j++;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">while</span> (i&lt;=mid)&#123;<br>           temp[index++] = arr[i++];<br>       &#125;<br>       <span class="hljs-keyword">while</span> (j&lt;=r)&#123;<br>           temp[index++] = arr[j++];<br>       &#125;<br>       <span class="hljs-comment">//临时数组复制到原数组</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;a&lt;index;a++)&#123;<br>           arr[l++] = temp[a];<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序的时间复杂度的计算"><a href="#归并排序的时间复杂度的计算" class="headerlink" title="归并排序的时间复杂度的计算"></a>归并排序的时间复杂度的计算</h2><p>归并排序的总时间复杂度 &#x3D; 分解时间 + 子序列排序的时间 + 合并时间</p><p>因为每次都是从数组的中间分解所以，分解的时间复杂度为常数，可以忽略。</p><p><strong>因此 归并排序的时间复杂度 &#x3D; 子序列排序的时间 + 合并时间</strong></p><p><strong>那么我们将n个数的序列，分为两个(n&#x2F;2)的序列。</strong></p><p><img src="/2022/06/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20190429110939184.png" alt="img"></p><p>因为合并时组内已经排序完成，所以时间复杂度为<code>n</code>，那么<code>T(n)=2*T(n/2)+n</code></p><p><strong>我们再将两个n&#x2F;2个序列再分成4个(n&#x2F;4)的序列。</strong></p><p><img src="/2022/06/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20190429111349924.png" alt="img"></p><p>一个（n&#x2F;2）序列排序时间 &#x3D; 两个(n&#x2F;4)的序列排序时间 + 两个(n&#x2F;4)的序列的合并为一个（n&#x2F;2）的序列时间</p><p><code>T(n/2)=2*T(n/4)+n/2</code></p><p>将<code>T(n/2</code>)带入到<code>T(n)</code>中，<code>T(n)=2*(2*T(n/4)+n/2)+n</code>，</p><p>通过化简<code>T(n)=4*T(n/4)+2n</code></p><p><strong>依次计算为：</strong></p><p><img src="/2022/06/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/20190429113910450.png" alt="img"></p><p>这个图就像二叉树一样，我们知道，一个n个结点的二叉树层数为<code>(log2n)+1</code></p><p>根据这个图的n前面的系数可以得出，n前面的系数为层数-1。<code>(log2n)+1-1=log2n</code></p><p>因此log2n就是最底层n的系数。</p><p>那么我们最后一层是不是可以这样表示</p><p><code>T(n)=n*T(1)+(log2n)*n</code></p><p><code>T(1)=0</code>，那么<code>T(n)=(log2n)*n</code></p><p><strong>所以归并排序的时间复杂度为<code>nlog2n</code></strong></p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p><strong>每次遍历依次将元素放入到10个桶中，0–9，进行遍历的次数由最大值的位数决定，</strong></p><p><strong>基数排序的思想是先以个位数的大小进行排序，再以十位数大小进行排序。。。。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基数排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (max&lt;arr[i])&#123;<br>            max = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> (max+<span class="hljs-string">&quot;&quot;</span>).length();<br>    <span class="hljs-type">int</span> bucket[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][n];<br>    <span class="hljs-type">int</span> bucketSize[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,gap = <span class="hljs-number">1</span>;l&lt;len;gap = gap*<span class="hljs-number">10</span>,l++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> arr[i] / gap % <span class="hljs-number">10</span>;<br>            bucket[a][bucketSize[a]] = arr[i];<br>            bucketSize[a]++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历桶中的元素加入到arr中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (bucketSize[i]!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;bucketSize[i];j++)&#123;<br>                    arr[index++] = bucket[i][j];<br>                &#125;<br>            &#125;<br>            bucketSize[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p><strong>先将数组变成大顶堆的数组，之后将第一个元素和最后一个元素进行交换，再对前n-1个元素进行循环大顶堆的操作，每次循环都将第一个元素与n-i个位置的元素进行交换。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 堆排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>    <span class="hljs-comment">//最后一个非叶子节点开始进行大顶堆的操作，最后一个非叶子节点为：arr.length/2-1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        bigHeap(arr,i,arr.length);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>         <span class="hljs-comment">//将第一个元素与最后一个元素进行交换，也就是把最大的元素放到数组的最后</span><br>        <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>]&gt;arr[i])&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>            arr[<span class="hljs-number">0</span>] = arr[i];<br>            arr[i] = t;<br>        &#125;<br>         <span class="hljs-comment">//将最后一个元素剩下的，前面的元素进行大顶堆的操作</span><br>        bigHeap(arr,<span class="hljs-number">0</span>,i);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//大顶堆</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bigHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> arr[i];<br>     <span class="hljs-comment">//节点的左子树：i*2+1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>;a&lt;n;a = a*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&#123;<br>         <span class="hljs-comment">//判断左子树和右子树节点哪个大，选择大的哪个</span><br>        <span class="hljs-keyword">if</span> (a+<span class="hljs-number">1</span>&lt;n &amp;&amp; arr[a]&lt;arr[a+<span class="hljs-number">1</span>])&#123;<br>            a++;<br>        &#125;<br>        <span class="hljs-comment">//如果当前节点没有左子树或者右子树中最大的节点大</span><br>        <span class="hljs-keyword">if</span> (arr[i]&lt;arr[a])&#123;<br>            arr[i] = arr[a];<span class="hljs-comment">//将左子树和右子树中大的节点与它的根节点（也就是当前的节点进行交换）</span><br>            i = a;<span class="hljs-comment">//接着将节点赋予左右子树中大的节点继续后面的操作，为了判断它下面是否还有子树</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        arr[a] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">heap</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> h[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> a;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span>*a&lt;=size &amp;&amp; h[u]&gt;h[<span class="hljs-number">2</span>*a]) u = <span class="hljs-number">2</span>*a;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span>*a+<span class="hljs-number">1</span>&lt;=size &amp;&amp; h[u]&gt;h[<span class="hljs-number">2</span>*a+<span class="hljs-number">1</span>]) u = <span class="hljs-number">2</span>*a+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (u!=a)&#123;<br>            swap(u,a);<br>            down(u);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> h[x];<br>        h[x] = h[y];<br>        h[y] = temp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span>  <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            h[i] = scanner.nextInt();<br>        &#125;<br>        size = n;<br>        <span class="hljs-comment">//构造一个堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            down(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (m--&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.print(h[<span class="hljs-number">1</span>]+<span class="hljs-string">&quot; &quot;</span>);<br>            h[<span class="hljs-number">1</span>] = h[size];<br>            size--;<br>            down(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p><strong>元素的大小对应数组的下标。</strong><br><strong>新建数组将遍历原数组元素，将原数组的元素存放对应的新建数组下标中。新建数组表示：temp[5] &#x3D; 2：5这个数有2个。</strong><br><strong>最后依次遍历新建数组放入原数组中。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计数排序，普通方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (max&lt;arr[i])&#123;<br>            max = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> bucket[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        bucket[arr[i]]++;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j&lt;=max;j++)&#123;<br>        <span class="hljs-keyword">if</span> (bucket[j]!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;a&lt;bucket[j];a++)&#123;<br>                arr[index++] = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优化后的代码：</strong></p><p><strong>优化一：</strong>当使用普通方法进行计数排序时，浪费了很多资源，例如，排序300-900之间的元素，而要建立大小为900的数组，其中前300没有数字，所以浪费了300个数组位置，最好的办法就是只定义300-900之间的这些长度的数组，所以不仅要求出最大值还要求出最小值来定义。</p><p><strong>优化二：</strong>还有一个问题就是对于普通数进行排序时是可以的，但是在真实的场景中，值相等的数并不能区分谁在前谁在后，对于这个问题，我们在新建的数组上加入偏移量，偏移量等于前面元素的个数+数组的数（这个值表示了排序后数组的位置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 优化的计数排序，主要用于这种情况：</span><br><span class="hljs-comment"> * 当要排序的数在200-300之内时如果没有优化之前  新建数组的长度为300 但是前200个空间浪费</span><br><span class="hljs-comment"> * 数组的长度只需要100即可，所以算出最小值，数组的大小在最小值和最大值之间.</span><br><span class="hljs-comment"> * 还有一个问题就是对于普通数进行排序时是可以的，但是在真实的场景中，值相等的数并不能区分谁在前谁在后</span><br><span class="hljs-comment"> * 对于这个问题，我们在新建的数组上加入偏移量，偏移量等于前面元素的个数+数组的数（这个值表示了排序后数组的位置）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countSortGood(<span class="hljs-type">int</span> arr[])&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (max&lt;arr[i])&#123;<br>            max = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min&gt;arr[i])&#123;<br>            min = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> bucket[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max-min+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        bucket[arr[i]-min]++;<br>    &#125;<br>    <span class="hljs-comment">//向后叠加，后面元素等于前面元素之和，。里面的值就是排序后数组的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;j&lt;bucket.length;j++)&#123;<br>        bucket[j] = bucket[j-<span class="hljs-number">1</span>] + bucket[j];<br>    &#125;<br>    <span class="hljs-type">int</span> sort[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">//逆序遍历原数组，从统计数组中找到正确的位置，放到结果数组中</span><br>    <span class="hljs-comment">//用例子模拟一遍就知道了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span> (bucket[arr[i]-min]!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//因为temp[arr[i]-min]代表位置，sort里面存放是下标，所以减 1</span><br>            sort[bucket[arr[i]-min]-<span class="hljs-number">1</span>] = arr[i];<br>            bucket[arr[i]-min]--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sort;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p><strong>与计数排序和基数排序都是同等类型，但是它处理的问题更加广泛，可以处理非整数数字的排序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 桶排序</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (max&lt;arr[i])&#123;<br>            max = arr[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min&gt;arr[i])&#123;<br>            min = arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//计算桶的数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> (max-min+<span class="hljs-number">1</span>)/n;<br>    List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;range;i++)&#123;<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());<br>    &#125;<br>    <span class="hljs-comment">//将每个元素放入桶中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> (arr[i]-min+<span class="hljs-number">1</span>)/range;<br>        list.get(l).add(arr[i]);<br>    &#125;<br>    <span class="hljs-comment">//对每个桶进行排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;range;i++)&#123;<br>        Collections.sort(list.get(i));<br>    &#125;<br>    <span class="hljs-comment">// 将桶中的元素赋值到原序列</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;range;i++)&#123;<br>        <span class="hljs-keyword">if</span> (list.get(i)!=<span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; list.get(i).size(); j++) &#123;<br>                arr[index++] = list.get(i).get(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="排序算法的分类和复杂度"><a href="#排序算法的分类和复杂度" class="headerlink" title="排序算法的分类和复杂度"></a>排序算法的分类和复杂度</h1><p><img src="/2022/06/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220603151000661.png" alt="image-20220603151000661"></p><p><img src="/2022/06/02/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20220603151011686.png" alt="image-20220603151011686"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><p><strong>根据leetCode中94题的二叉树中序遍历而整理</strong></p><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/inorder_1.jpg" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>​最简单的方法，也是很好想到的解法，一开始只会这个 ，哈哈哈。。但总是在进步嘛</p><p><strong>中序遍历的访问顺序是：</strong>左子树—-&gt;根节点—-&gt;右子树（在代码中就是<strong>左  -  打印  -  右</strong>）</p><p>由于 访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。所以具有递归的性质，可以直接用递归函数来模拟这一过程。</p><p><strong>递归函数实现：</strong></p><ul><li>终止条件：当前节点为空时</li><li>函数内：递归的调用左节点，打印当前节点，再递归调用右节点。</li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//递归的方式实现</span><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//左子树</span><br>            <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>) inorderTraversal(root.left);<br>            <span class="hljs-comment">//打印</span><br>            list.add(root.val);<br>            <span class="hljs-comment">//右子树</span><br>            <span class="hljs-keyword">if</span> (root.right!=<span class="hljs-literal">null</span>) inorderTraversal(root.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><p>一开是不会这个方法，但是看了官方题解中的动图步骤，竟然自己写出来了！~~加鸡腿！！哈哈</p><p>觉得官方题解的步骤太好了，清晰明了，在这里显示一下吧，以免过后忘记了~~记性太差了！！</p><p><strong>在递归的过程中，操作系统&#x2F;虚拟机自动帮我们用栈来保存，所以在迭代的过程中需要自己手动维护一个栈进行实现。</strong></p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20220602091512478.png" alt="image-20220602091512478"></p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20220602091528495.png" alt="image-20220602091528495"></p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20220602091612672.png" alt="image-20220602091612672"></p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20220602091649940.png" alt="image-20220602091649940"><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20220602091714841.png" alt="image-20220602091714841"></p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20220602091731552.png" alt="image-20220602091731552"></p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20220602091807918.png" alt="image-20220602091807918"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//迭代</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        Deque&lt;TreeNode&gt; stk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span> || !stk.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">null</span>) &#123;<br>                stk.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stk.pop();<br>            res.add(root.val);<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：Morris"><a href="#解法三：Morris" class="headerlink" title="解法三：Morris"></a>解法三：Morris</h2><p>这个算法，由于不需要维护一个栈，所以空间复杂度为O(1)。<strong>优点是节省了空间，缺点是改变了整个树的结构，强行把一棵二叉树改成一段链表结构。</strong></p><p><strong>Morris 遍历算法</strong>整体步骤如下（假设当前遍历到的节点为 x）：</p><p>（1）如果x没有左孩子，则加入答案组，再访问x的右节点，即：<code>x=x.rigth</code></p><p>（2）如果x有左孩子，则找到x左子树上最右的节点（<strong>即左子树中序遍历的最后一个节点，x在中序遍历中的前驱节点</strong>），我们记作 <code>predecdssor</code>。根据<code>predecdssor</code>的右孩子是否为空，进行如下操作。</p><ul><li>如果<code>predecdssor</code>的右孩子为空，则将其右孩子指向x，然后访问x的左孩子，即<code>x=x.left</code>。</li><li>如果<code>predecdssor</code>的右孩子不为空，则此时右孩子指向x，说明我们已经遍历完x的左子树，我们将<code>predecdssor</code>的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 <code>x=x.right</code>。</li></ul><p><strong>其实整个过程我们就多做一步：假设当前遍历到的节点为 x，将 x 的左子树中最右边的节点的右孩子指向 x，这样在左子树遍历完成后我们通过这个指向走回了 x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</strong></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-comment">//Morris方法</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//如果root有左子树，则寻找左子树的最右节点，也就当前root节点的前驱节点</span><br>            <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//找左子树的最后节点，从左子树的根找起</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> root.left;<br>                <span class="hljs-comment">//一次找取最右节点，这个找取是再原树上找取，所以之前添加的pre.right = root;不能算，所以pre.right!=root</span><br>                <span class="hljs-keyword">while</span> (pre.right!=<span class="hljs-literal">null</span> &amp;&amp; pre.right!=root)&#123;<br>                    pre = pre.right;<br>                &#125;<br>                <span class="hljs-comment">//判断pre 的右孩子是否为空，不为空说明右节点已经指向root，已经在原来的树上改变了，说明已经遍历完成root的左子树了</span><br>                <span class="hljs-keyword">if</span> (pre.right!=<span class="hljs-literal">null</span>)&#123;<br>                    list.add(root.val);<br>                    root = root.right;<br>                    pre.right = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-comment">//让 pre 的右指针指向 root，继续遍历左子树</span><br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    pre.right = root;<br>                    root = root.left;<br>                &#125;<br>            <span class="hljs-comment">//root没有左子树，则访问右子树</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                list.add(root.val);<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><p><strong>leetCode144题</strong></p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/inorder_1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><h2 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p><strong>前序遍历的访问顺序是：</strong>根节点—-&gt;左子树—-&gt;右子树（<strong>在代码中就是打印  - 左  -  右</strong>）</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-comment">//前序遍历：递归</span><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>            list.add(root.val);<br>            <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>) preorderTraversal(root.left);<br>            <span class="hljs-keyword">if</span> (root.right!=<span class="hljs-literal">null</span>) preorderTraversal(root.right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：迭代-1"><a href="#解法二：迭代-1" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><p>前序遍历的迭代，就是先加入list。</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-comment">//迭代</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>                list.add(root.val);<br>                stack.add(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            root = root.right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：Morris-1"><a href="#解法三：Morris-1" class="headerlink" title="解法三：Morris"></a>解法三：Morris</h2><p>哇塞<del>今天是很开心的一天呀</del>有着中序遍历中Morris方法的经验，看着下图就爽了，希望不要忘记把，咋可能呢，明天估计就不会了。</p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/image-20220602113552988.png" alt="image-20220602113552988"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-comment">//Mirros</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>            list.add(root.val);<br>            <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>)&#123;<br>                pre = root.left;<br>                <span class="hljs-keyword">while</span> (pre.right!=<span class="hljs-literal">null</span> &amp;&amp; pre.right!=root.right)&#123;<br>                    pre = pre.right;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (pre.right==<span class="hljs-literal">null</span>) &#123;<br>                    pre.right = root.right;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    pre = pre.right;<br>                    list.add(pre.val);<br>                &#125;<br>                root = root.left;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><p><strong>leetCode145题：</strong></p><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="/2022/06/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/pre1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><h2 id="解法一：递归-2"><a href="#解法一：递归-2" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p><strong>后序遍历的访问顺序是：</strong>左子树—-&gt;右子树—-&gt;根节点（<strong>在代码中就是左  -  右  -  打印</strong>）</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//递归</span><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (root.left!=<span class="hljs-literal">null</span>) postorderTraversal(root.left);<br>            <span class="hljs-keyword">if</span> (root.right!=<span class="hljs-literal">null</span>) postorderTraversal(root.right);<br>            list.add(root.val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：迭代-2"><a href="#解法二：迭代-2" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><p>后序遍历真难呀！</p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//迭代</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-comment">//从栈中弹出的节点，我们只能确定其左子树肯定访问完了，但是无法确定右子树是否访问过。因此，我们在后序遍历中，引入了一个prev来记录历史访问记录。</span><br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">null</span> || !stack.isEmpty())&#123;<br>            <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>                stack.push(root);<br>                root = root.left;<br>            &#125;<br>            root = stack.pop();<br>            <span class="hljs-comment">//这步就是要判断一下是不是左右子树都已经遍历完成</span><br>             <span class="hljs-comment">//如果没有右子树，或者右子树访问完了，也就是上一个访问的节点是右子节点时</span><br>            <span class="hljs-comment">//说明可以访问当前节点</span><br>            <span class="hljs-keyword">if</span> (root.right==<span class="hljs-literal">null</span> || root.right==pre)&#123;<br>                list.add(root.val);<br>                <span class="hljs-comment">//更新历史访问记录，这样回溯的时候父节点可以由此判断右子树是否访问完成</span><br>                pre = root;<br>                root = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//如果没有，则要继续进行右子树的遍历，但根节点在右子树之后，所以要再次入队</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                stack.push(root);<br>                root = root.right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：Morris-2"><a href="#解法三：Morris-2" class="headerlink" title="解法三：Morris"></a>解法三：Morris</h2><p>不会！不会！不会！ 要了命了</p><p>但是可以把前序遍历的<code>left</code>变为<code>right</code>  <code>right</code>变为<code>left</code>  最后输出的list进行逆转，<code>Collections.recerse(list);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>     <span class="hljs-comment">//Mirros</span><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>();<br>        <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">null</span>)&#123;<br>            list.add(root.val);<br>            <span class="hljs-keyword">if</span> (root.right!=<span class="hljs-literal">null</span>)&#123;<br>                pre = root.right;<br>                <span class="hljs-keyword">while</span> (pre.left!=<span class="hljs-literal">null</span> &amp;&amp; pre.left!=root.left)&#123;<br>                    pre = pre.left;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (pre.left==<span class="hljs-literal">null</span>) &#123;<br>                    pre.left = root.left;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    pre = pre.left;<br>                    list.add(pre.val);<br>                &#125;<br>                root = root.right;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                root = root.left;<br>            &#125;<br>        &#125;<br>        Collections.reverse(list);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文串</title>
    <link href="/2022/05/30/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <url>/2022/05/30/%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="最长回文子串-leetCode-5"><a href="#最长回文子串-leetCode-5" class="headerlink" title="最长回文子串(leetCode_5)"></a>最长回文子串(leetCode_5)</h1><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：s = <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><h2 id="解法一：暴力解法"><a href="#解法一：暴力解法" class="headerlink" title="解法一：暴力解法"></a>解法一：暴力解法</h2><p>通过两个for循环遍历字符串s所有的子字符串。定义一个方法，用来判断是否是回文串，如果是，则记录回文串的长度(len)和开始的位置(begin)。因此 最长的回文子串为：<code>s.substring(begin,begin+len);</code></p><ul><li>可以只针对大于「当前得到的最长回文子串长度」的子串进行回文验证；</li><li>当得到了一个更长的回文时，不需要真的做截取。只需要记录「当前子串的起始位置」和「子串长度」。</li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-comment">//暴力解法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span>[] ss = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">//如果是回文字符串并且长度比之前的长度大，则改变长度，记录开始位置</span><br>                <span class="hljs-keyword">if</span> (j-i+<span class="hljs-number">1</span>&gt;res &amp;&amp; just(ss,i,j))&#123;<br>                    res = j-i+<span class="hljs-number">1</span>;<br>                    begin = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//回文字符串就是开始位置-开始位置+长度</span><br>        <span class="hljs-keyword">return</span> s.substring(begin,begin+res);<br>    &#125;<br>    <span class="hljs-comment">//判断是不是回文字符串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">just</span><span class="hljs-params">(<span class="hljs-type">char</span> []ss,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-keyword">while</span> (i&lt;j) &#123;<br>            <span class="hljs-keyword">if</span> (ss[i] != ss[j]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法二：动态规划方法"><a href="#解法二：动态规划方法" class="headerlink" title="解法二：动态规划方法"></a>解法二：动态规划方法</h2><p><img src="/2022/05/30/%E5%9B%9E%E6%96%87%E4%B8%B2/image-20220530195946114.png" alt="image-20220530195946114"></p><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>   <span class="hljs-comment">//动态规划 dp[i][j]:表示位置i到位置j是否是回文串</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">char</span>[] ss = s.toCharArray();<br>        <span class="hljs-type">boolean</span> dp[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br>        <span class="hljs-comment">//处理动态规划的边界条件，本身到本身都是回文串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;r&lt;n;r++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;l&lt;r;l++)&#123;<br>                <span class="hljs-comment">//如果左端和右端不相等，则直接为false</span><br>                <span class="hljs-keyword">if</span> (ss[l]!=ss[r])&#123;<br>                    dp[l][r] = <span class="hljs-literal">false</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//如果是同一个元素或者两个相等的元素，则为true</span><br>                    <span class="hljs-keyword">if</span> (r-l&lt;<span class="hljs-number">3</span>)&#123;<br>                        dp[l][r] = <span class="hljs-literal">true</span>;<br>                    &#125;<span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">//否则根据dp[l+1][r-1]来判断</span><br>                        dp[l][r] = dp[l+<span class="hljs-number">1</span>][r-<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//如果是回文串，并且比最大长度大，则更新最大值，记录开始位置</span><br>                <span class="hljs-keyword">if</span> (dp[l][r] &amp;&amp; r-l+<span class="hljs-number">1</span>&gt;res)&#123;<br>                    res = r-l+<span class="hljs-number">1</span>;<br>                    begin = l;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(begin,begin+res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解法三：中心扩散法"><a href="#解法三：中心扩散法" class="headerlink" title="解法三：中心扩散法"></a>解法三：中心扩散法</h2><p>「中心扩散法」的基本思想是：遍历每一个下标，以这个下标为中心，利用「回文串」中心对称的特点，往两边扩散，看最多能扩散多远。</p><p><strong>注意：</strong> 扩散时，回文串长度是奇数或偶数时，中心扩散不一样，所以要分开研究。</p><blockquote><p>奇数时：中心字符串为一个字符，</p><p>偶数时：中心字符串为两个字符。</p></blockquote><p><strong>可以设计为：</strong></p><ul><li>如果传入重合的下标，进行中心扩散，此时得到的回文子串的长度是奇数；</li><li>如果传入相邻的下标，进行中心扩散，此时得到的回文子串的长度是偶数。</li></ul><p><strong>代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-comment">// 回文子串长度是奇数,最中间是同一个数,所以取一个就行</span><br>            helper(i, i, s);<br>            <span class="hljs-comment">// 回文子串长度是偶数,取两个数字</span><br>            helper(i, i + <span class="hljs-number">1</span>, s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, String s)</span> &#123;<br>        <span class="hljs-keyword">while</span> (m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; s.length() &amp;&amp; s.charAt(m) == s.charAt(n)) &#123;<br>            m--;<br>            n++;<br>        &#125;<br>        <span class="hljs-comment">// 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻</span><br>        <span class="hljs-comment">// 此时m到n的距离为n-m+1，但是mn两个边界不能取 所以应该取m+1到n-1的区间  长度是n-m-1</span><br>        <span class="hljs-keyword">if</span> (n - m - <span class="hljs-number">1</span> &gt; ans.length()) &#123;<br>            <span class="hljs-comment">//substring要取[m+1,n-1]这个区间 </span><br>            <span class="hljs-comment">//end处的值不取,所以下面写的是n不是n-1</span><br>            ans = s.substring(m + <span class="hljs-number">1</span>, n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetCode</tag>
      
      <tag>回文串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM学习</title>
    <link href="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​Java Virtual Machine - java 程序的运行环境（java 二进制字节码的运行环境）<br>​将java的字节码加载到虚拟机里面，就可以运行了</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>一次编写，到处运行（正式jvm屏蔽了字节码和底层操作系统的差异，对外提供了统一 的运行环境）</li><li>自动内存管理，垃圾回收功能 （不需要自己释放内存，减轻了内存的泄露）</li><li>数组下标越界检查 </li><li>多态（可扩展性，虚方法表）</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><strong>jvm jre jdk的区别</strong><br><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/ec558bf48ffd4140bff688629457c357.png" alt="在这里插入图片描述"></p><ul><li>jvm：屏蔽java代码与底层的差异 ，Java Virtual Machine</li><li>jre：jvm+基础类（集合类，日期类，线程类，IO类。。）Java Runtime Environment</li><li>jdk：jvm+基础类+编译工具（javac）Java Development Kit</li></ul><h3 id="学习JVM-有什么用"><a href="#学习JVM-有什么用" class="headerlink" title="学习JVM 有什么用"></a>学习JVM 有什么用</h3><ul><li>面试 </li><li>理解底层的实现原理 </li><li>中高级程序员的必备技能（是否能用jvm相关的知识解决实际的问题 ）</li></ul><h3 id="常见的-JVM"><a href="#常见的-JVM" class="headerlink" title="常见的 JVM"></a>常见的 JVM</h3><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/4630aac079d3457bb2d87de74e967daa.png" alt="在这里插入图片描述"></p><h3 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h3><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/c2f8f119700440b2a83ddc8ec5a1b259.png" alt="在这里插入图片描述"><br><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/cd4030cd2e3e49408bbc9d751bc087c7.png" alt="在这里插入图片描述"></p><h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><p><strong>作用</strong>：字节码解释器⼯作时通过改变这个计数器的值来选取下⼀条需要执⾏的字节码指令，分⽀、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成  。因为JVM中多线程采用时间片轮转的方式实现，所以当一个线程时间片用完之后，要交给其它线程使用，为了下一次分配到该线程时，能够继续执行，所以需要程序计数器。</p><p><strong>是记住下一条jvm指令的执行地址</strong><br><strong>特点：</strong></p><ul><li>是线程私有的</li><li>唯一一个内存结构中，不会存在内存溢出</li></ul><p><strong>Program Counter Register 程序计数器（寄存器）</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/74fd150755c14204b7964999b90b8350.png" alt="在这里插入图片描述"></p><p><strong>在物理上 程序计数器是通过寄存器来实现的，因为寄存器是cpu组件里，读取速度最快的。因为程序计数器的读取指令是非常频繁的，</strong>。</p><h2 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h2><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p><strong>描述的是 Java⽅法执⾏的内存模型，每次⽅法调⽤的数据都是通过栈传递的。</strong>  </p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈</li><li><strong>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</strong></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法，也就是栈的顶部</li><li>栈帧中都拥有：局部变量表、操作数栈、动态链接（指向常量池方法的引用）、⽅法出⼝信息  （方法返回地址和一些附加信息）</li><li>每一个<a href="https://so.csdn.net/so/search?q=%E6%A0%88%E5%B8%A7&spm=1001.2101.3001.7020">栈帧</a>内部都包含一个<strong>指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现<a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5&spm=1001.2101.3001.7020">动态链接</a>。</li><li><em><strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></em>。</li><li><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/3a7ed696a2a0420c90de84d577563033.png" alt="在这里插入图片描述"></li></ul><p>Java ⽅法有两种返回⽅式：</p><ol><li>return 语句。</li><li>抛出异常。</li></ol><p>不管哪种返回⽅式都会导致栈帧被弹出。</p><p><strong>问题辨析</strong></p><ol><li><strong>垃圾回收是否涉及栈内存？</strong></li></ol><blockquote><p>不涉及，栈内存就是一次一次的方法调用，所产生的栈帧内存，栈帧内存每次在方法调用之后，都会弹出栈，自动的回收，不需要垃圾回收，垃圾回收只回收堆内存中的无用对象</p></blockquote><ol start="2"><li><strong>栈内存分配越大越好吗？</strong></li></ol><blockquote><p>不，栈大，线程数变少，栈多，只会进行更多次的方法调用，不会影响速度，反而影响线程数目的减少<br>如果内存为500M，每个线程占用1M，可以运行500个线程，如果栈内存分配2M，则只能运行250个线程。</p></blockquote><ol start="3"><li><strong>方法内的局部变量是否线程安全？</strong></li></ol><blockquote><p> 是线程安全的，每个线程的局部变量是线程私有的。</p></blockquote><p><strong>判断一个变量是否是线程安全的</strong></p><blockquote><p>不仅要看它是否是方法内的局部变量，还要看它是否逃离了方法的作用范围（例如返回值，其他线程可以操作，不安全）</p></blockquote><ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的 </li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul><h4 id="2-2-栈内存溢出（java-lang-StackOverflowError）"><a href="#2-2-栈内存溢出（java-lang-StackOverflowError）" class="headerlink" title="2.2 栈内存溢出（java.lang.StackOverflowError）"></a>2.2 栈内存溢出（<code>java.lang.StackOverflowError</code>）</h4><p> （1）栈帧过多导致栈内存溢出（方法没有终止条件下）<br> <img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/54e0e9028156426eb86f46b108a0fc55.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示栈内存溢出 java.lang.StackOverflowError</span><br><span class="hljs-comment"> * -Xss256k</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            method1();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>            System.out.println(count);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        count++;<br>        method1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）栈帧过大导致栈内存溢出</p><h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><p>调用不是java代码编写的方法，一般由C语言编写或者C++编写。</p><h2 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h2><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><p><strong>Heap 堆：通过 new 关键字，创建对象都会使用堆内存</strong><br>特点：（1）它是线程共享的，堆中对象都需要考虑线程安全的问题（2）有垃圾回收机制</p><h4 id="4-2-堆内存的溢出"><a href="#4-2-堆内存的溢出" class="headerlink" title="4.2 堆内存的溢出"></a>4.2 堆内存的溢出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">java.lang.OutOfMemoryError:Java heap space<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示堆内存溢出 java.lang.OutOfMemoryError: Java heap space</span><br><span class="hljs-comment"> * -Xmx8m</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_5</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                list.add(a); <span class="hljs-comment">// hello, hellohello, hellohellohellohello ...</span><br>                a = a + a;  <span class="hljs-comment">// hellohellohellohello</span><br>                i++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-JVM指针碰撞和空闲列表"><a href="#4-3-JVM指针碰撞和空闲列表" class="headerlink" title="4.3 JVM指针碰撞和空闲列表"></a>4.3 JVM指针碰撞和空闲列表</h4><p>当类加载检查通过后，接下来虚拟机将为新生对象分配内存，堆主要就是用于存放对象的实例，在堆上为对象分配内存空间，将对象放进去，常用的方法有指针碰撞（java堆中内存是规整的）和空闲列表（java堆中内存是不规整的）两种方法。</p><p><strong>指针碰撞</strong></p><p>​适用于堆内存完整的情况，已分配的内存和空闲的内存分别在不同的一侧，指针指向分界点，当需要分配内存的时候，将指针向空闲区域的方向移动与对象大小相等的距离即可，用于串行回收器（Serial）和 并行收集器（ParNew）不会产生碎片的垃圾收集器。</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/20210310004922185.png" alt="image-20200512111153143"></p><p><strong>空闲列表</strong></p><p>​适用于堆内存不完整的情况，已分配的内存和空闲的内存相互交错，JVM通过一张内存列表记录可用的内存信息，当分配内存时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的数据，最常用此方案的是CMS垃圾回收器。</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/20210310004912404.png" alt="image-20200512111650404"></p><h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>⽅法区与 Java 堆⼀样，是各个线程共享的内存区域，它⽤于存储已被虚拟机加载的类信息、常<br>量、静态变量、即时编译器编译后的代码等数据。</p><p><strong>1.8的时候，方法区被彻底移除，取而代之的是元空间，元空间使用的是直接内存。</strong></p><h4 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h4><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/41d31e224bdd4d30ba0d1487ea4d9d20.png" alt="在这里插入图片描述"><br><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/94649e3f6c414f55b5ff1d2cd050efae.png" alt="在这里插入图片描述"><br>方法区也被称为永久代。<br>⽅法区和永久代的关系：</p><blockquote><p>⽅法区和永久代的关系很像Java 中接⼝和类的关系，类实现了接⼝，⽽永久代就是 HotSpot 虚拟机对虚拟机规范中⽅ 法区的⼀种实现⽅式。</p></blockquote><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="5-3-常量池和运行时常量池"><a href="#5-3-常量池和运行时常量池" class="headerlink" title="5.3 常量池和运行时常量池"></a>5.3 常量池和运行时常量池</h4><p><strong>（1）常量池</strong></p><p>程序在运行之前要编译成二进制字节码，</p><p>其中二进制字节码包含</p><ul><li><p>类基本信息</p></li><li><p>常量池</p></li><li><p>类方法定义（包含了虚拟机指令）</p></li></ul><p>将class文件解析后可以看到这些二进制代码包含的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac test1.java<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javap -v .class<br></code></pre></td></tr></table></figure><p>类基本信息：</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603190959878.png" alt="image-20220603190959878"></p><p><strong>常量池：</strong>俗称静态常量池，又称常量池表(Constant Pool Table)，存在于*.class文件中，就是一张表，<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>指令根据这张表找到要执行的类名、类方法、参数类型、字面量等信息</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191047403.png" alt="image-20220603191047403"></p><p><strong>类方法定义：</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191109581.png" alt="image-20220603191109581"></p><p><strong>（2）运行时常量池</strong></p><p>​<strong>当该类被加载</strong>，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址  。（<strong>也就是将常量池中的内容放入到内存中运行称为运行时常量池。并把里面的#1，#2等等变为真实的地址</strong>）</p><h4 id="5-4-StringTable–字符串池（运行时常量池中的一部分）"><a href="#5-4-StringTable–字符串池（运行时常量池中的一部分）" class="headerlink" title="5.4 StringTable–字符串池（运行时常量池中的一部分）"></a>5.4 StringTable–字符串池（运行时常量池中的一部分）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringTable [ &quot;a&quot;, &quot;b&quot; ,&quot;ab&quot; ]  hashtable 结构，不能扩容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_22</span> &#123;<br>    <span class="hljs-comment">// 常量池中的信息，都会被加载到运行时常量池中， 当类被加载时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</span><br>    <span class="hljs-comment">// ldc #2 会把 a 符号变为 &quot;a&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #3 会把 b 符号变为 &quot;b&quot; 字符串对象</span><br>    <span class="hljs-comment">// ldc #4 会把 ab 符号变为 &quot;ab&quot; 字符串对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2; <span class="hljs-comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()  new String(&quot;ab&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span><br><br>        System.out.println(s3 == s5);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特性：</strong></p><ul><li><p>StringTable数据结构为hash表（数组加链表），不可扩容，存字符串常量，唯一不重复。</p></li><li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串变量拼接的原理是 StringBuilder （1.8），new一个String对象，创建在堆中</p></li><li><p>字符串常量拼接的原理是编译期优化，因为常量在编译器就决定了值，不会改变，所以在串池中寻找和创建。</p></li><li><p>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池</p><blockquote><p>（1）1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串<br>池中的对象返回<br>（2）1.6 将这个字符串对象尝试放入串池 ，如果有则并不会放入，如果没有会把此对象复制一份，<br>放入串池， 会把串池中的对象返回 （<strong>也就是放入串池中的对象和当初创建的对象是两个对象</strong>）</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//举例一（1.8）：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_23</span> &#123;<br>    <span class="hljs-comment">// 串池  [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]  hashtable</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>        <br>        <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern(); <span class="hljs-comment">// 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回</span><br><br>        System.out.println( s2 == <span class="hljs-string">&quot;ab&quot;</span>);  <span class="hljs-comment">//true</span><br>        System.out.println( s == <span class="hljs-string">&quot;ab&quot;</span> );  <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析如上代码：</strong></p><blockquote><p>当执行第一行时，创建了<code>“a”</code>，<code>“b”</code>字符串，在串池中搜索，查找是否有该字符串，如果没有则创建，继续执行。</p></blockquote><blockquote><p>同时在堆中也创建了<code>new String(&quot;a&quot;)</code>   和 <code>new String(&quot;b&quot;)</code></p></blockquote><blockquote><p>执行<code>s.intern()</code>的时候，发现串池中没有<code>“ab”</code>字符串，则将s所引用的字符串放入串池，所以下面的执行结果都为true。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//举例二（1.8）：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_23</span> &#123;<br>    <span class="hljs-comment">//  [&quot;ab&quot; ,&quot;a&quot;, &quot;b&quot;]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>        <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;)  new String(&quot;ab&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern(); <span class="hljs-comment">// 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回</span><br><br>        System.out.println( s2 == x);  <span class="hljs-comment">//true</span><br>        System.out.println( s == x );  <span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析如上代码：</strong></p><blockquote><p>当执行第一行时，在字符串常量池中创建了<code>“ab”</code>字符串。</p><p>第二行时在字符串中创建了<code>“a”</code> 和 <code>“b”</code> ，以及在堆中创建 <code>new String(&quot;a&quot;)</code>   <code>new String(&quot;b&quot;)</code>  <code>new String(&quot;ab&quot;)</code></p><p>通过执行<code>s.intern（）</code>想将s加入到常量池中，但是s的字符串常量池中已经存在不会放入。</p><p>所以  <code>s</code>不等于<code>x</code>，<code>s2</code>是常量池中返回的对象<code>“ab”</code>，所以相等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//举例：（jdk1.6）中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1_23</span> &#123;<br>    <span class="hljs-comment">//  [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><br>        <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;)  new String(&quot;ab&quot;)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern(); <span class="hljs-comment">//s 拷贝一份，放入串池中，不是原来的s</span><br>        <span class="hljs-comment">// 将这个字符串对象尝试放入串池 ，如果有则并不会放入，如果没有会把此对象复制一份，放入串池， 会把串池中的对象返回</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        System.out.println( s2 == x);  <span class="hljs-comment">//true</span><br>        System.out.println( s == x );  <span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析如上代码：</strong></p><blockquote><p>当执行第一行的时候，在串池中创建两个常量 <code>&quot;a&quot;</code> 和 <code>&quot;b&quot;</code>，在堆中创建 <code>new String(&quot;a&quot;)</code>   <code>new String(&quot;b&quot;)</code>  <code>new String(&quot;ab&quot;)</code></p><p>执行第二行的时候，查看串池中是否有<code>“ab”</code>，如果有则不放入，和jdk1.8中的一样，如果没有，则拷贝一分，放入串池中，不是原先的变量s。</p><p>因此在执行<code>s == x</code>时为<code>false</code>，因为<code>s</code>中字符串对象还是堆中的。</p></blockquote><h4 id="5-5-StringTable存在的位置"><a href="#5-5-StringTable存在的位置" class="headerlink" title="5.5 StringTable存在的位置"></a>5.5 StringTable存在的位置</h4><p>在jdk1.6时，StringTable属于常量池中的一部分，存放于永久代中</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191146879.png" alt="image-20220603191146879"></p><p>在jdk1.7之后存放于 堆内存中</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191157423.png" alt="image-20220603191157423"></p><p><strong>为什么要更改：</strong></p><blockquote><p>因为在永久代中，垃圾回收很慢。导致StringTable回收效率很低。而StringTable中存放的都是字符串常量，需要及时清理，如果不清理需要占用大量的内存。所以考虑移动到堆内存中，垃圾回收效率高，减轻了字符串对内存的占用。</p></blockquote><h4 id="5-6-StringTable垃圾回收"><a href="#5-6-StringTable垃圾回收" class="headerlink" title="5.6 StringTable垃圾回收"></a>5.6 StringTable垃圾回收</h4><p>可以被垃圾回收</p><h4 id="5-7-StringTable-性能调优"><a href="#5-7-StringTable-性能调优" class="headerlink" title="5.7 StringTable 性能调优"></a>5.7 StringTable 性能调优</h4><p>调整 -XX:StringTableSize&#x3D;桶个数  </p><h2 id="什么是方法区"><a href="#什么是方法区" class="headerlink" title="什么是方法区"></a>什么是方法区</h2><p>当虚拟机要使用一个类时，要读取并解析class文件获取相关的信息，再将信息存入到方法区域中，方法区会存储已经被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量等。</p><h2 id="方法区和永久代以及元空间有什么关系"><a href="#方法区和永久代以及元空间有什么关系" class="headerlink" title="方法区和永久代以及元空间有什么关系"></a>方法区和永久代以及元空间有什么关系</h2><p>永久代和元空间是方法区的两种实现方式，相当于java中的接口和类，类实现了接口&#x3D;&#x3D;&#x3D;永久代和元空间实现了方法区。</p><p>并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现便成为元空间。</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/611a22dff05598703c47ba0b6c77771a.png" alt="img"></p><h2 id="为什么要将永久代替换为元空间"><a href="#为什么要将永久代替换为元空间" class="headerlink" title="为什么要将永久代替换为元空间"></a>为什么要将永久代替换为元空间</h2><p>（1）<strong>因为永久代设置空间大小是很难确定的</strong>，在某些场景中，如果动态加载类过多，容易产生OOM，比如某个实际的web工程中，因为功能点比较多，在运行过程中，要不断的动态加载很多类，导致OOM，而元空间和永久代最大的区别在于：<strong>元空间并不在虚拟机中，而是使用本地的内存，因此，默认情况下，元空间的大小受本地内存的限制，所以出现OOM的情况变小，并且能加载更多的类</strong></p><p>（2）永久代的对象是通过Full GC进行垃圾回收的，也就是和老年代一起进行垃圾回收的，<strong>替换元空间以后，简化了 FullGC</strong>。<br>（3）在 JDK8，<strong>合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西</strong>, 合并之后就没有必要额外的设置这么一个永久代的地方了</p><h2 id="运行时常量池和字符串常量池"><a href="#运行时常量池和字符串常量池" class="headerlink" title="运行时常量池和字符串常量池"></a>运行时常量池和字符串常量池</h2><blockquote><p>jdk1.7之前，运行时常量池所包含的字符串常量池和静态变量全部都存放在方法区中也就是永久代。</p></blockquote><blockquote><p>jdk1.7时，字符串常量池和静态变量移动到堆中，运行时常量池中所剩下的东西还在方法区中也就是永久代中，</p></blockquote><blockquote><p>jdk1.8时，方法区的实现从永久代变为了元空间。</p></blockquote><p>运行时常量池中存放的是对象的引用，字符串常量池中存放的是对象，存放在堆中。</p><p>在声明一个字符串字面量时，如果字符串常量池中能够找到该字符串字面量，则直接返回该引用。如果找不到的话，则在常量池中创建该字符串字面量的对象并返回其引用。</p><h2 id="jdk7中为什么把字符串常量池移动到堆中"><a href="#jdk7中为什么把字符串常量池移动到堆中" class="headerlink" title="jdk7中为什么把字符串常量池移动到堆中"></a>jdk7中为什么把字符串常量池移动到堆中</h2><p>因为永久代的GC回收率太低，只有在整个堆收集的时候（Full GC）才会发生GC，而JAVA程序通常有大量创建的字符串等待回收，将字符串常量放入到堆中，可以更高效的回收字符串。</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/5d7c7705b051b5a10e84dcfb14036c7f.png" alt="img"></p><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6 直接内存"></a>6 直接内存</h2><p>不是<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>的内存，是系统内存。<code>Direct Memory</code></p><p><strong>定义：</strong></p><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191211665.png" alt="image-20220603191211665"></p><p>当<code>java</code>读取磁盘文件时，会从用户态切换到内核态，才能去操作系统<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>。读取时，系统内存先开辟一块缓存空间，磁盘文件分块读取。然后java虚拟机内存再开辟缓存空间<code>new Byte[]</code>来读取系统内存的文件。由于有从系统内存读取到java虚拟机的内存，所以效率较低。</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191226097.png" alt="image-20220603191226097"></p><p>读取磁盘文件时，会有一块直接内存，<code>Java</code>虚拟机和系统内存都能访问使用，所以效率更高。</p><blockquote><p> 它可以直接使⽤ Native 函数库直接分配堆外内存，然后通过⼀个存储在 Java 堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引⽤进⾏操作。这样就能在⼀些场景中显著提⾼性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据  </p></blockquote><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h3><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220604115140591.png" alt="image-20220604115140591"></p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1 如何判断对象可以回收"></a>1 如何判断对象可以回收</h2><h3 id="1-2-引用计数法"><a href="#1-2-引用计数法" class="headerlink" title="1.2 引用计数法"></a>1.2 引用计数法</h3><p>给对象添加一个引用计数器，每当有引用它的地方，就将计数器加 1 ，当引用失效后，引用计数器减1，当计数器为 0 时，说明对象不会被引用了，可以进行回收。</p><p><strong>弊端：</strong> 就是当对象A和B互相引用的时候，对象A和对象B的计数器都为1</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191323953.png" alt="image-20220603191323953"></p><p>但这两个对象没有被其他对象引用，应该进行垃圾回收，但由于对象A和对象B的计数器都为1，回收失败。</p><h3 id="1-2-可达性分析法"><a href="#1-2-可达性分析法" class="headerlink" title="1.2 可达性分析法"></a>1.2 可达性分析法</h3><ul><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收</li><li>哪些对象可以作为 GC Root ?</li></ul><p><strong>哪些对象可以作为 GC Root ?</strong>  </p><ul><li><p><strong>方法区静态属性引用的对象</strong><br>全局对象的一种，Class对象本身很难被回收，回收的条件非常苛刻，只要Class对象不被回收，静态成员就不能被回收。</p></li><li><p><strong>方法区常量池引用的对象</strong><br>也属于全局对象，例如字符串常量池，常量本身初始化后不会再改变，因此作为GC Roots也是合理的。</p></li><li><p><strong>方法栈中栈帧本地变量表引用的对象</strong><br>属于执行上下文中的对象，线程在执行方法时，会将方法打包成一个栈帧入栈执行，<strong>方法里用到的局部变量会存放到栈帧的本地变量表中</strong>。只要方法还在运行，还没出栈，就意味这本地变量表的对象还会被访问，GC就不应该回收，所以这一类对象也可作为GC Roots。</p></li><li><p><strong>JNI本地方法栈中引用的对象</strong><br>和上一条本质相同，无非是一个是Java方法栈中的变量引用，一个是native方法(C、C++)方法栈中的变量引用。</p></li><li><p><strong>被同步锁持有的对象</strong><br>被synchronized锁住的对象也是绝对不能回收的，当前有线程持有对象锁呢，GC如果回收了对象，锁不就失效了嘛。</p></li></ul><p><strong>总结：</strong></p><p><strong>可达性分析就是JVM枚举根节点，找到程序能正常运行所必须存活的对象，然后以这些对象为根，根据引用关系开始向下搜寻。存在直接或间接引用链的对象就存活，不存在引用链的对象就回收。</strong></p><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191333535.png" alt="image-20220603191333535"></p><p><strong>（1）强引用</strong></p><p>​以前我们使⽤的⼤部分引⽤实际上都是强引⽤，这是使⽤最普遍的引⽤。<strong>如果⼀个对象具有强引⽤，那就类似于必不可少的⽣活⽤品，垃圾回收器绝不会回收它。</strong>当内存空间不⾜， Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终⽌，也不会靠随意回收具有强引⽤的对象来解决内存不⾜问题。</p><p>​当强引用都断开时，才可以被回收。例如:<code>String a = new String(&quot;hello world&quot;);</code></p><p><strong>（2）软引用</strong>  </p><p>​如果⼀个对象只具有软引⽤，<strong>那就类似于可有可⽆的⽣活⽤品</strong>。如果内存空间⾜够，垃圾回收器就不会回收它，<strong>如果内存空间不⾜了，就会回收这些对象的内存</strong>。只要垃圾回收器没有回收它，该对象就可以被程序使⽤。软引⽤可⽤来实现内存敏感的⾼速缓存。</p><p>​软引⽤可以和⼀个引⽤队列（ReferenceQueue）联合使⽤，如果软引⽤所引⽤的对象被垃圾回收， JAVA虚拟机就会把这个软引⽤加⼊到与之关联的引⽤队列中。</p><p><strong>（3）弱引用</strong></p><p>​如果⼀个对象只具有弱引⽤<strong>，那就类似于可有可⽆的⽣活⽤品</strong>。弱引⽤与软引⽤的区别在于：在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>⼀旦发现了只具有弱引⽤的对象，不管当前内存空间⾜够与否，都会回收它的内存</strong>。不过，<strong>由于垃圾回收器是⼀个优先级很低的线程， 因此不⼀定会很快发现那些只具有弱引⽤的对象。</strong></p><p>​弱引⽤可以和⼀个引⽤队列（ReferenceQueue）联合使⽤，如果弱引⽤所引⽤的对象被垃圾回收， Java虚拟机就会把这个弱引⽤加⼊到与之关联的引⽤队列中。  </p><p><strong>为什么软引用和弱引用要使用引用队列？</strong></p><p> 因为软引用和弱引用本身也是一个对象，也占有一定的内存，所以要释放它们两个时，就要扫描引用队列进行释放。</p><p><strong>（4）虚引用</strong></p><p>​就是形同虚设 .如果⼀个对象仅持有虚引⽤，<strong>那么它就和没有任何引⽤⼀样，在任何时候都可能被垃圾回收</strong>。</p><p>​<strong>虚引⽤主要⽤来跟踪对象被垃圾回收的活动。</strong>  </p><p>​虚引⽤必须和引⽤队列（ReferenceQueue）联合使⽤。<strong>当垃 圾回收器准备回收⼀个对象时，如果发现它还有虚引⽤，就会在回收对象的内存之前，把这个虚引⽤加⼊到与之关联的引⽤队列中。</strong>程序可以通过判断引⽤队列中是 否已经加⼊了虚引⽤，来了解被引⽤的对象是否将要被垃圾回收。程序如果发现某个虚引⽤已经被加⼊到引⽤队列，那么就可以在所引⽤的对象的内存被回收之前采取必要的⾏动。  </p><p>​虚引用引用的对象被垃圾回收时，把这个虚引⽤加⼊到与之关联的引⽤队列中。调用<code>Unsafe.freeMemory()</code>来释放直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示软引用, 配合引用队列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2_4</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_4MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;SoftReference&lt;<span class="hljs-type">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 引用队列</span><br>        ReferenceQueue&lt;<span class="hljs-type">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span><br>            SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[_4MB], queue);<br>            System.out.println(ref.get());<br>            list.add(ref);<br>            System.out.println(list.size());<br>        &#125;<br><br>        <span class="hljs-comment">// 从队列中获取无用的 软引用对象，并移除</span><br>        Reference&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">byte</span>[]&gt; poll = queue.poll();<br>        <span class="hljs-keyword">while</span>( poll != <span class="hljs-literal">null</span>) &#123;<br>            list.remove(poll);<br>            poll = queue.poll();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>        <span class="hljs-keyword">for</span> (SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; reference : list) &#123;<br>            System.out.println(reference.get());<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（5）终结器引用</strong></p><ul><li>无需手动编码，但其内部配合引用队列使用，</li><li>在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），</li><li>再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法，</li><li>第二次 GC 时才能回收被引用对象</li></ul><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2 垃圾回收算法"></a>2 垃圾回收算法</h2><h4 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h4><p><strong>是最基础的收集算法，⾸先标记出所有不需要回收的对象，在标记完成后统⼀回收掉所有没有被标记的对象。</strong>  </p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191350783.png" alt="image-20220603191350783"></p><p><strong>优点：</strong></p><blockquote><p>速度较快</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>标记清除后会产⽣⼤量不连续的碎⽚ ，</p></blockquote><h4 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h4><p><strong>对标记后，垃圾回收的空间进行整理。</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191400545.png" alt="image-20220603191400545"></p><p><strong>优点：</strong></p><blockquote><p>没有内存碎片的问题</p></blockquote><p>缺点：</p><blockquote><p>时间慢</p></blockquote><h4 id="2-3-复制算法"><a href="#2-3-复制算法" class="headerlink" title="2.3 复制算法"></a>2.3 复制算法</h4><p><strong>将内存区域划分成了大小相等的两个区域。To是空闲的，一个对象都没有</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191408841.png" alt="image-20220603191408841"></p><p><strong>标记内存中要回收的对象：</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191415683.png" alt="image-20220603191415683"></p><p><strong>将from中存活的对象复制到To中</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191422234.png" alt="image-20220603191422234"></p><p><strong>清空From</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191429522.png" alt="image-20220603191429522"></p><p><strong>交换From 和 To ，To总是空闲的一块</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191436488.png" alt="image-20220603191436488"></p><p><strong>优点：</strong></p><blockquote><p>不会产生内存碎片</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>占用双倍的内存空间</p></blockquote><h4 id="2-4-分代回收算法"><a href="#2-4-分代回收算法" class="headerlink" title="2.4 分代回收算法"></a>2.4 分代回收算法</h4><p>​当前虚拟机的垃圾收集都采⽤分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为⼏块。⼀般将 java 堆分为新⽣代和⽼年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。  </p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191445299.png" alt="image-20220603191445299"></p><p><strong>步骤：</strong></p><ul><li><p>对象首先分配在伊甸园区域</p></li><li><p>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to</p></li><li><p>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行（因为垃圾回收时，会进行地址的交换，如果线程同时执行的话会找不到地址，出现混乱）</p></li><li><p>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</p></li><li><p>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW（stop the world）的时间更长  </p><p><strong>⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</strong></p></li></ul><h2 id="3-垃圾回收器"><a href="#3-垃圾回收器" class="headerlink" title="3 垃圾回收器"></a>3 垃圾回收器</h2><h3 id="3-1-串行（serial）"><a href="#3-1-串行（serial）" class="headerlink" title="3.1 串行（serial）"></a>3.1 串行（serial）</h3><p>​看名字就知道是“单线程”收集器，它的 “单线程” 的意义不仅仅意味着它只会使⽤⼀条垃圾收集线程去完成垃圾收集⼯作<strong>，更重要的是它在进⾏垃圾收集⼯作的时候必须暂停其他所有的⼯作线程（ “StopThe World” ），直到它收集结束。</strong>  </p><p>​<strong>新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。</strong>  </p><blockquote><p> 缺点就是：STP时间太长，用户体验不佳</p></blockquote><blockquote><p>优点就是：简单而高效，没有线程之间交互的开销</p></blockquote><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191456131.png" alt="image-20220603191456131"></p><p><strong>Serial Old 收集器</strong><br>Serial 收集器的⽼年代版本，它同样是⼀个单线程收集器。它主要有两⼤⽤途：⼀种⽤途是在JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使⽤，另⼀种⽤途是作为 CMS 收集器的后备⽅案。  </p><h3 id="3-2-ParNew-收集器"><a href="#3-2-ParNew-收集器" class="headerlink" title="3.2 ParNew 收集器"></a>3.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本</strong>，除了使⽤多线程进⾏垃圾收集外，其余⾏为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全⼀样。  </p><p>新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。  </p><p><strong>它是许多运⾏在 Server 模式下的虚拟机的⾸要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后⾯会介绍到）配合⼯作。</strong></p><h3 id="3-2-吞吐量优先"><a href="#3-2-吞吐量优先" class="headerlink" title="3.2 吞吐量优先"></a>3.2 吞吐量优先</h3><p>​Parallel Scavenge 收集器关注点是吞吐量（⾼效率的利⽤ CPU）。  <strong>所谓吞吐量就是 CPU 中⽤于运⾏⽤户代码的时间与 CPU 总消耗时间的⽐值。  垃圾回收器并行工作。Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量</strong></p><p><strong>新⽣代采⽤复制算法，⽼年代采⽤标记-整理算法。</strong>  </p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191505250.png" alt="image-20220603191505250"></p><p><strong>并发（Concurrent）    ：</strong>指⽤户线程与垃圾收集线程同时执⾏（但不⼀定是并⾏，可能会交替执⾏），⽤户程序在继续运⾏，⽽垃圾收集器运⾏在另⼀个 CPU 上  </p><p><strong>并行（Parallel）  ：</strong>指多条垃圾收集线程并⾏⼯作，但此时⽤户线程仍然处于等待状态。  </p><h3 id="3-3-CMS响应时间优先"><a href="#3-3-CMS响应时间优先" class="headerlink" title="3.3 CMS响应时间优先"></a>3.3 CMS响应时间优先</h3><p>CMS（Concurrent Mark Sweep）收集器是⼀种<strong>以获取最短回收停顿时间为⽬标的收集器</strong>。它⾮常符合在注重⽤户体验的应⽤上使⽤。  </p><p>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第⼀款真正意义上的<strong>并发收集器</strong>，<strong>它第⼀次实现了让垃圾收集线程与⽤户线程（基本上）同时⼯作。</strong>  </p><p>从名字中的Mark Sweep这两个词可以看出， CMS 收集器是⼀种 <strong>“标记-清除</strong>”算法实现的，它的运作过程相⽐于前⾯⼏种垃圾收集器来说更加复杂⼀些。整个过程分为四个步骤：  </p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191515127.png" alt="image-20220603191515127"></p><ul><li><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；  </p></li><li><p><strong>并发标记：</strong> 同时开启 GC 和⽤户线程，⽤⼀个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。<strong>因为⽤户线程可能会不断的更新引⽤域，所以 GC 线程⽆法保证可达性分析的实时性。所以这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅。</strong>  </p></li><li><p><strong>重新标记：</strong> <strong>重新标记阶段就是为了修正并发标记期间因为用户程序运行导致标记记录改变的标记</strong>，这个阶段的停顿时间⼀般会⽐初始标记阶段的时间稍⻓，远远⽐并发标记阶段时间短。</p></li><li><p><strong>并发清除：</strong> 开启⽤户线程，同时 GC 线程开始对未标记的区域做清扫。</p></li></ul><p><strong>主要优点：</strong> 并发收集、低停顿。</p><p><strong>三个明显缺点：</strong></p><ul><li>对 CPU 资源敏感；</li><li>⽆法处理浮动垃圾；  </li><li>它使⽤的回收算法-“标记-清除”算法会导致收集结束时会有⼤量空间碎⽚产⽣。</li></ul><h3 id="3-4-G1（Garbage-First-）"><a href="#3-4-G1（Garbage-First-）" class="headerlink" title="3.4 G1（Garbage-First  ）"></a>3.4 G1（Garbage-First  ）</h3><p><strong>适用场景</strong></p><ul><li><strong>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</strong></li><li><strong>超大堆内存，会将堆划分为多个大小相等的 Region</strong></li><li><strong>整体上是 标记+整理 算法，两个区域之间是 复制 算法</strong>  </li><li><strong>G1 收集器在后台维护了⼀个优先列表，每次根据允许的收集时间，优先选择回收价值最⼤的Region(这也就是它的名字 Garbage-First 的由来)。这种使⽤ Region 划分内存空间以及有优先级的区域回收⽅式，保证了 G1 收集器在有限时间内可以尽可能⾼的收集效率（把内存化整为零）。</strong></li></ul><p><strong>（1）G1垃圾回收的整个阶段</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191526911.png" alt="image-20220603191526911"></p><p><strong>（2）第一个阶段（ Young Collection  ）</strong></p><ul><li><strong>G1垃圾回收器将堆内存划分为多个大小相同的区域，每个区域都可以独立的作为新生代，幸存区或老年代</strong></li></ul><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191536263.png" alt="image-20220603191536263"></p><p>其中：白色表示空闲区，E表示新生代的区域  ，S表示幸存区，O表示老年代的区域</p><ul><li><strong>当内存逐渐占满，新生代将会进行一次垃圾回收，将幸存的对象以复制的算法放入幸存区</strong></li></ul><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191543901.png" alt="image-20220603191543901"></p><ul><li><strong>当幸存区对象的存活超过一定的时间，则幸存区中的一部分对象会晋升到老年代 ，不够年龄的拷贝到另一个幸存空间中去，新生代的幸存对象也会被拷贝到幸存空间中去</strong></li></ul><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191552734.png" alt="image-20220603191552734"></p><p><strong>（2）第二阶段（Young Collection + CM  ）：新生代垃圾回收+并发标记</strong></p><ul><li><p>在 Young GC 时会进行 GC Root 的<strong>初始标记</strong></p></li><li><p>老年代占用堆空间比例达到阈值时，进行<strong>并发标记</strong>（不会 STW），由下面的 JVM 参数决定  </p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191601802.png" alt="image-20220603191601802"></p></li></ul><p>同时并发标记过程中，会计算每个region存活对象的比例（G1垃圾回收的时候根据回收的价值高低来优先回收价值较高的region）</p><p><strong>（3）第三个阶段（Mixed Collection  ）</strong></p><p>会对 E、S、O 进行全面垃圾回收</p><ul><li><strong>最终标记</strong>（Remark）会 STW</li><li><strong>拷贝存活</strong>（Evacuation）会 STW</li></ul><p><strong>拷贝存活时：对老年代来说，首先对各个Regin的回收价值和成本进行排序，优先回收垃圾最多的区域，主要为了达到暂停时间短的目标</strong>  </p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191612170.png" alt="image-20220603191612170"></p><p><strong>标记的一些概念：</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191617970.png" alt="image-20220603191617970"></p><p>其中：黑色表示已经处理完成的，表示结束时会被存活下来的对象，灰色表示正在处理的，白色表示还没有处理的。</p><p><strong>垃圾回收的时候通过颜色来判断是否存活还是回收</strong>，图中的灰色的有强引用引用着它，也会变成黑色。下一个白色也有引用应用引用着它，最终也会存活下来，而上面的白色没有引用，一直是白色，最后被垃圾回收掉。</p><p><strong>例如：</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191624470.png" alt="image-20220603191624470"></p><p>上图：</p><ul><li>情况一：当处理到B时，发现有强引用引用着它，所以它变成灰色，由于是并发标记，垃圾回收线程和用户线程同时执行，当用户取消了B引用C这条线，C则一直为白色。所以当并发标记结束后 ，C被当作垃圾被回收。</li></ul><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191631341.png" alt="image-20220603191631341"></p><ul><li>情况二：下图：当C和B 标记处理完成之后，并发标记还没有结束之前，用户线程又改变了引用地址，A引用了C，C的引用又发生了改变。但由与C和B已经处理完成，C标记为白色，A是黑色已经处理完成，不会再进行处理。则C就会被漏掉，因为我们仍然认为C是白色的，应该被垃圾回收，但是不正确，因为A引用了C，这样就发生了错误。</li><li><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191637135.png" alt="image-20220603191637135"></li></ul><p>根据以上的分析，为了防止并发标记阶段出现这种错误，所以要进行重新标记阶段。</p><p><strong>JVM的解决方法：如果引用变化，则加入到队列中</strong></p><p><strong>当引用发生改变时，JVM就会给它加入一个写屏障，就会将C加入到队列当中并把C变成灰色表示还没有处理完</strong>，接下来进行重新标记的过程，Stop The World，重新标记的过程会将队列中的元素取出来，在进行一次检查，发现灰色，并且有强引用，。则变为黑色，不会进行垃圾回收。</p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191644707.png" alt="image-20220603191644707"></p><h3 id="3-5-FullGC概念"><a href="#3-5-FullGC概念" class="headerlink" title="3.5 FullGC概念"></a>3.5 FullGC概念</h3><ul><li>SerialGC<br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集 - full gc</li><li>ParallelGC<br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足发生的垃圾收集 - full gc</li><li>CMS<br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足</li><li>G1<br>新生代内存不足发生的垃圾收集 - minor gc<br>老年代内存不足  （触发并发标记和混合收集，这个时候都进行的是并发收集，还没有到FullGC的程度），当垃圾回收的速度跟不上产生的垃圾，则并发收集失败，这个时候会触发串行收集（FullGC）</li></ul><h3 id="3-6-CMS和G1的区别"><a href="#3-6-CMS和G1的区别" class="headerlink" title="3.6 CMS和G1的区别"></a>3.6 CMS和G1的区别</h3><p>相对于 CMS 回收器来说，G1 回收器有下面几个不同的地方：</p><ul><li>采用化整为零的分区思想</li><li>采用标记 - 整理的垃圾回收算法</li><li>可预测的 GC 停顿时间</li></ul><p><strong>（1）采用化整为零的分区思想</strong></p><p>因为G1垃圾回收器使用的是标记-整理算法，而CMS使用的是标记-清除算法，所以CMS会产生大量的内存碎片，而G1不会。</p><p>但为什么CMS不使用标记-整理算法呢？</p><blockquote><p>因为CMS的老年代区域很大，使用标记-整理算法要花费很长的时间，导致接口响应时间变长</p></blockquote><p>因为G1中采用分区的思想，将大块的内存化整为零成为region，此外还维护了一个带回收区域的列表，优先回收性价比高的区域。</p><p><strong>（2）可预测的停顿时间</strong></p><p>能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p><h3 id="3-7-GC调优-没看，应该面试没有"><a href="#3-7-GC调优-没看，应该面试没有" class="headerlink" title="3.7 GC调优  没看，应该面试没有"></a>3.7 GC调优  没看，应该面试没有</h3><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="1-类文件结构和字节码指令"><a href="#1-类文件结构和字节码指令" class="headerlink" title="1 类文件结构和字节码指令"></a>1 类文件结构和字节码指令</h2><p><strong>从字节码的方式来解释程序的运行</strong></p><p><strong>这一部分先简单了解一下，面试好像不需要</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220622145501331.png" alt="image-20220622145501331"></p><h3 id="对于i-i"><a href="#对于i-i" class="headerlink" title="对于i++,++i"></a>对于i++,++i</h3><p><strong>从字节码角度分析，下列代码运行的结果：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_6_1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br>x = x++;<br>i++;<br>&#125;<br>    System.out.println(x); <span class="hljs-comment">// 结果是 0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果为：0</strong></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191704808.png" alt="image-20220603191704808"></p><p><strong>因为x++操作：是先iload（将变量加载到操作数栈中）再进行iinc（在局部变量表中进行加1），</strong></p><p><strong>++x操作是：先iinc（在局部变量表中加1）再进行iload（将加1后的变量加载到操作数栈中）。</strong></p><p><strong>注意：iinc：是在局部变量表中加1的，而不是在操作数栈中加1</strong></p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_9</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Demo3_9</span><span class="hljs-params">()</span> &#123; &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123; &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123; &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123; &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123; &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Demo3_9</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo3_9</span>();<br>        d.test1();<br>        d.test2();<br>        d.test3();<br>        d.test4();<br>        Demo3_9.test4();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字节码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> <span class="hljs-comment">// class cn/itcast/jvm/t3/bytecode/Demo3_9</span><br><span class="hljs-number">3</span>: dup<br><span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">7</span>: astore_1<br><span class="hljs-number">8</span>: aload_1<br><span class="hljs-number">9</span>: invokespecial #<span class="hljs-number">4</span> <span class="hljs-comment">// Method test1:()V</span><br><span class="hljs-number">12</span>: aload_1<br><span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">5</span> <span class="hljs-comment">// Method test2:()V</span><br><span class="hljs-number">16</span>: aload_1<br><span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">6</span> <span class="hljs-comment">// Method test3:()V</span><br><span class="hljs-number">20</span>: aload_1<br><span class="hljs-number">21</span>: pop<br><span class="hljs-number">22</span>: invokestatic #<span class="hljs-number">7</span> <span class="hljs-comment">// Method test4:()V</span><br><span class="hljs-number">25</span>: invokestatic #<span class="hljs-number">7</span> <span class="hljs-comment">// Method test4:()V</span><br><span class="hljs-number">28</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈</li><li><strong>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配</strong><br><strong>合 invokespecial 调用该对象的构造方法 “<init>“:()V （会消耗掉栈顶一个引用），另一个要</init></strong><br><strong>配合 astore_1 赋值给局部变量</strong></li><li>最终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静<br>态绑定</li><li>普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态</li><li>成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li><li>比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用<br>invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了😂</li><li>还有一个执行 invokespecial 的情况是通过 super 调用父类方法</li></ul><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_12_2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> test();<br>System.out.println(result);<br>&#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>descriptor: ()I<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">0</span><br><span class="hljs-number">0</span>: bipush <span class="hljs-number">10</span> <span class="hljs-comment">// &lt;- 10 放入栈顶</span><br><span class="hljs-number">2</span>: istore_0 <span class="hljs-comment">// 10 -&gt; slot 0 (从栈顶移除了)</span><br><span class="hljs-number">3</span>: bipush <span class="hljs-number">20</span> <span class="hljs-comment">// &lt;- 20 放入栈顶</span><br><span class="hljs-number">5</span>: ireturn <span class="hljs-comment">// 返回栈顶 int(20)</span><br><span class="hljs-number">6</span>: astore_1 <span class="hljs-comment">// catch any -&gt; slot 1</span><br><span class="hljs-number">7</span>: bipush <span class="hljs-number">20</span> <span class="hljs-comment">// &lt;- 20 放入栈顶</span><br><span class="hljs-number">9</span>: ireturn <span class="hljs-comment">// 返回栈顶 int(20)</span><br>Exception table:<br>from to target type<br><span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> any<br>LineNumberTable: ...<br>StackMapTable: ...<br></code></pre></td></tr></table></figure><ul><li>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准</li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li><li>跟上例中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会<br>吞掉异常😱😱😱。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3_12_2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> test();<br>System.out.println(result);<br>&#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>i = <span class="hljs-number">20</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果：</strong> 10</p><p>因为执行<code>return i</code>的时候进行的暂存，等到finally中的代码执行完成之后，再将暂存结果返回。</p><p><strong>因此：如果在try中return了，则在finally做出的变化将不会影响返回值结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>descriptor: ()I<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span><br><span class="hljs-number">0</span>: bipush <span class="hljs-number">10</span> <span class="hljs-comment">// &lt;- 10 放入栈顶</span><br><span class="hljs-number">2</span>: istore_0 <span class="hljs-comment">// 10 -&gt; i</span><br><span class="hljs-number">3</span>: iload_0 <span class="hljs-comment">// &lt;- i(10)</span><br><span class="hljs-number">4</span>: istore_1 <span class="hljs-comment">// 10 -&gt; slot 1，暂存至 slot 1，目的是为了固定返回值</span><br><span class="hljs-number">5</span>: bipush <span class="hljs-number">20</span> <span class="hljs-comment">// &lt;- 20 放入栈顶</span><br><span class="hljs-number">7</span>: istore_0 <span class="hljs-comment">// 20 -&gt; i</span><br><span class="hljs-number">8</span>: iload_1 <span class="hljs-comment">// &lt;- slot 1(10) 载入 slot 1 暂存的值</span><br><span class="hljs-number">9</span>: ireturn <span class="hljs-comment">// 返回栈顶的 int(10)</span><br><span class="hljs-number">10</span>: astore_2<br><span class="hljs-number">11</span>: bipush <span class="hljs-number">20</span><br><span class="hljs-number">13</span>: istore_0<br><span class="hljs-number">14</span>: aload_2<br><span class="hljs-number">15</span>: athrow<br>Exception table:<br>from to target type<br><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">10</span> any<br>LineNumberTable: ...<br>LocalVariableTable:<br>Start Length Slot Name Signature<br><span class="hljs-number">3</span> <span class="hljs-number">13</span> <span class="hljs-number">0</span> i I2<span class="hljs-number">.13</span> <span class="hljs-keyword">synchronized</span><br>注意<br>StackMapTable: ...<br></code></pre></td></tr></table></figure><h3 id="synchronized-。。。"><a href="#synchronized-。。。" class="headerlink" title="synchronized  。。。"></a>synchronized  。。。</h3><h2 id="2-编译期处理"><a href="#2-编译期处理" class="headerlink" title="2 编译期处理"></a>2 编译期处理</h2><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <code>*.java</code> 源码编译为 <code>*.class</code> 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛）  </p><h3 id="2-1-默认构造器"><a href="#2-1-默认构造器" class="headerlink" title="2.1 默认构造器"></a>2.1 默认构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy1</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编译成class后的代码：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy1</span> &#123;<br><span class="hljs-comment">// 这个无参构造是编译器帮助我们加上的</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Candy1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>(); <span class="hljs-comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;</span><br>&lt;init&gt;<span class="hljs-string">&quot;:()V</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-自动拆装箱"><a href="#2-2-自动拆装箱" class="headerlink" title="2.2 自动拆装箱"></a>2.2 自动拆装箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x.intValue();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-泛型集合"><a href="#2-3-泛型集合" class="headerlink" title="2.3 泛型集合"></a>2.3 泛型集合</h3><p>java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy3</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 实际调用的是 List.add(Object e)</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 实际调用的是 Object obj = List.get(int index);</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-可变参数"><a href="#2-4-可变参数" class="headerlink" title="2.4 可变参数"></a>2.4 可变参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy4</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(String... args)</span> &#123;<br>String[] array = args; <span class="hljs-comment">// 直接赋值</span><br>System.out.println(array);<br>&#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>foo(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可变参数 String… args 其实是一个 String[] args</strong> ，从代码中的赋值语句中就可以看出来。同样 java 编译器会在编译期间将上述代码变换为：  </p><p><strong>创建数组的大小由调用的参数决定。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy4</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(String[] args)</span> &#123;<br>String[] array = args; <span class="hljs-comment">// 直接赋值</span><br>System.out.println(array);<br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>foo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-foreach循环"><a href="#2-5-foreach循环" class="headerlink" title="2.5 foreach循环"></a>2.5 foreach循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy5_1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 数组赋初值的简化写法也是语法糖哦</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e : array) &#123;<br>System.out.println(e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>会被编译器转换为：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy5_1</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Candy5_1</span><span class="hljs-params">()</span> &#123;<br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; ++i) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> array[i];<br>System.out.println(e);<br>&#125;<br>&#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>而集合的循环：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy5_2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">for</span> (Integer i : list) &#123;<br>System.out.println(i);<br>&#125;<br>&#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>实际被编译器转换为对迭代器的调用：</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Candy5_2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Candy5_2</span><span class="hljs-params">()</span> &#123;<br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-type">Iterator</span> <span class="hljs-variable">iter</span> <span class="hljs-operator">=</span> list.iterator();<br><span class="hljs-keyword">while</span>(iter.hasNext()) &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (Integer)iter.next();<br>System.out.println(e);<br>&#125;<br>&#125;<br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="3-类的加载过程"><a href="#3-类的加载过程" class="headerlink" title="3 类的加载过程**"></a>3 类的加载过程**</h2><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191722403.png" alt="image-20220603191722403"></p><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220603191728110.png" alt="image-20220603191728110"></p><h3 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h3><p>指 JVM 读取 Class 文件，并且根据 Class 文件描述创建 java.lang.Class 对象的过程。  </p><p>类的加载过程主要是将类的字节码文件读取到运行时区域的方法区（内部使用C++完成），在堆中创建java.lang.Class 对象， 并封装类在方法区的数据结构的过程  。</p><h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h3><p>主要用于确保 Class 文件符合当前虚拟机的要求， 保障虚拟机自身的安全，只有通过验证的 Class 文件才能被 JVM 加载。  </p><h3 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h3><p><strong>为 static 变量分配空间，设置默认值</strong></p><ul><li>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾</li><li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li><li><strong>如果 static 变量是 final 的基本类型</strong>，以及字符串常量，那么编译阶段值就确定了，<strong>赋值在准备阶</strong><br><strong>段完成</strong></li><li><strong>如果 static 变量是 final 的</strong>，但属于引用类型（new），<strong>那么赋值也会在初始化阶段完成</strong></li></ul><h3 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h3><p>将常量池中的符号引用（仅仅是符号，不知道类、方法或属性到底在哪个位置）解析为直接引用 （能够确切的知道类、方法或者属性在内存中的具体位置了）</p><h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h3><p>主要通过执行类构造器的<client>方法为类进行初始化。 <client>方法是在编译阶段由编译器自动收集类中静态语句块和变量的赋值操作组成的。   </client></client></p><p><strong>发生的时机</strong><br>概括得说，类初始化是【懒惰的】</p><ul><li>main 方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p><strong>不会导致类初始化的情况</strong>  </p><ul><li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li><li>类对象.class 不会触发初始化（在加载阶段已经生成了，）</li><li>创建该类的数组不会触发初始化</li><li>类加载器的 loadClass 方法</li><li>Class.forName 的参数 2 为 false 时</li></ul><h2 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4 类加载器"></a>4 类加载器</h2><p><strong>什么是类加载器？常见的类加载器有哪些？</strong></p><p><strong>类加载器：</strong>通过一个类的全限定性类名（类名全程，带包路径的用点隔开eg：com.zlw.test）获取该类的二进制字节流，叫做类加载器。</p><p><strong>常见的类加载器有四种：</strong></p><table><thead><tr><th>名称</th><th>加载哪的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib （加载java核心类库）–启动类加载器</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext （加载java的扩展库）–扩展类加载</td><td>上级为 Bootstrap，显示为 null</td></tr><tr><td>Application ClassLoader</td><td>classpath（通过java类路径来加载类，一般来说，java应用的类都是用它来加载）–应用程序加载器</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义 （由java语言实现，继承自ClassLoader）</td><td>上级为 Application</td></tr></tbody></table><p><img src="/2022/05/30/JVM%E5%AD%A6%E4%B9%A0/image-20220604100611851.png" alt="image-20220604100611851"></p><h2 id="5-双亲委派模式"><a href="#5-双亲委派模式" class="headerlink" title="5 双亲委派模式"></a>5 双亲委派模式</h2><p><strong>什么是双亲委派模式？</strong></p><p>当一个类加载器收到一个类加载请求时，首先不会尝试自己去加载，而是将这个类委派给上级加载器进行加载，只有上级加载器在自己的搜索范围查找不到该类时，子加载器才会去尝试自己去加载该类。</p><p><strong>好处：</strong></p><p><strong>（1）如果没有双亲委派模式，用户会自己自定义一个java.lang.String，无法保证类的唯一性。</strong></p><p><strong>（2）同时也避免了类的重复加载，因为 JVM中区分不同类，不仅仅是根据类名，相同的 class文件被不同的 ClassLoader加载就是不同的两个类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br><span class="hljs-comment">// 1. 检查该类是否已经加载</span><br>Class&lt;?&gt; c = findLoadedClass(name);<br><span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 2. 有上级的话，委派上级 loadClass</span><br>c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 3. 如果没有上级了（ExtClassLoader），则委派</span><br><span class="hljs-type">BootstrapClassLoader</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> findBootstrapClassOrNull(name);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>&#125; <br><span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-comment">// 4. 每一层找不到，调用 findClass 方法（每个类加载器自己扩展）来加载</span><br>c = findClass(name);<br><span class="hljs-comment">// 5. 记录耗时</span><br>sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);<br>sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>sun.misc.PerfCounter.getFindClasses().increment();<br>&#125;<br>&#125; <br><span class="hljs-keyword">if</span> (resolve) &#123;<br>resolveClass(c);<br>&#125; <br><span class="hljs-keyword">return</span> c;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行流程为：</strong><br>（1）<code>sun.misc.Launcher$AppClassLoader</code> &#x2F;&#x2F;1 处， 开始查看已加载的类，结果没有<br>（2） <code>sun.misc.Launcher$AppClassLoader</code> &#x2F;&#x2F; 2 处，委派上级<code>sun.misc.Launcher$ExtClassLoader.loadClass()</code><br>（3） <code>sun.misc.Launcher$ExtClassLoader</code> &#x2F;&#x2F; 1 处，查看已加载的类，结果没有<br>（4） <code>sun.misc.Launcher$ExtClassLoader</code> &#x2F;&#x2F; 3 处，没有上级了，则委派 <code>BootstrapClassLoader</code>查找<br>（5） <code>BootstrapClassLoader</code> 是在 JAVA_HOME&#x2F;jre&#x2F;lib 下找 H 这个类，显然没有<br>（6）<code>sun.misc.Launcher$ExtClassLoader</code> &#x2F;&#x2F; 4 处，调用自己的 findClass 方法，是在JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 下找 H 这个类，显然没有，回到 <code>sun.misc.Launcher$AppClassLoader</code>的 &#x2F;&#x2F; 2 处<br>（7）继续执行到 <code>sun.misc.Launcher$AppClassLoader</code> &#x2F;&#x2F; 4 处，调用它自己的 findClass 方法，在<br>classpath 下查找，找到了  </p><h2 id="6-自定义加载器"><a href="#6-自定义加载器" class="headerlink" title="6 自定义加载器"></a>6 自定义加载器</h2><h3 id="6-1-为什么要自定义类加载器"><a href="#6-1-为什么要自定义类加载器" class="headerlink" title="6.1 为什么要自定义类加载器"></a>6.1 为什么要自定义类加载器</h3><p>（1）<strong>加密：</strong>Java代码可以轻易的被反编译，如果你需要把自己的代码进行<strong>加密</strong>以<strong>防止反编译</strong>，可以先将编译后的代码用某种加密算法加密，类加密后就不能再用Java的ClassLoader去加载类了，这时就<strong>需要自定义ClassLoader在加载类的时候先解密类，然后再加载。</strong></p><p>（2）<strong>想加载非 classpath 随意路径中的类文件</strong>  </p><p>（3）从非标准的来源加载代码：如果你的字节码是放在数据库、甚至是在云端，就可以自定义类加载器，从指定的来源加载类。</p><p>（4）<strong>以上两种情况在实际中的综合运用：比如你的应用需要通过网络来传输 Java 类的字节码，为了安全性，这些字节码经过了加密处理。这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出在Java虚拟机中运行的类。</strong></p><h3 id="6-2-自定义加载器步骤"><a href="#6-2-自定义加载器步骤" class="headerlink" title="6.2 自定义加载器步骤"></a>6.2 自定义加载器步骤</h3><p>（1）从上面源码看出，调用loadClass时会先根据委派模型在父加载器中加载，如果加载失败，则会调用当前加载器的findClass来完成加载。</p><p>（2）<strong>因此我们自定义的类加载器只需要继承ClassLoader，并覆盖findClass方法</strong>，下面是一个实际例子，在该例中我们用自定义的<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&spm=1001.2101.3001.7020">类加载</a>器去加载我们事先准备好的class文件。</p><p><strong>步骤：</strong></p><ul><li>继承 ClassLoader 父类</li><li>要遵从双亲委派机制，重写 findClass 方法（因为只有重新了findClass方法才会委托上级的加载器优先加载，只有上级没有找到class时，才会在本身的类加载器进行加载）<ul><li>注意不是重写 loadClass 方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 defineClass 方法来加载类</li><li>使用者调用该类加载器的 loadClass 方法</li></ul><p><strong>自定义加载器的代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.example.myclassloader;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//name：类的名称</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> name.replace(<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;\\&quot;</span>);<br>            path = <span class="hljs-string">&quot;D:\\class\\&quot;</span> + path + <span class="hljs-string">&quot;.class&quot;</span>;<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-comment">//根据路径进行拷贝，将拷贝的结果放入到 baos的输出流中</span><br>            Files.copy(Paths.get(path), baos);<br>            <span class="hljs-comment">//得到字节数组</span><br>            <span class="hljs-type">byte</span>[] bytes = baos.toByteArray();<br>            <span class="hljs-comment">//将byte[] -&gt; *.class</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.defineClass(name,bytes,<span class="hljs-number">0</span>,bytes.length);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(<span class="hljs-string">&quot;没找到相应的类文件&quot;</span> + name);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.example.myclassloader;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassLoaderTest</span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//创建类加载器对象</span><br>        <span class="hljs-type">MyClassLoader</span> <span class="hljs-variable">myClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClassLoader</span>();<br>        <span class="hljs-comment">//调用loadClass方法 实现类的加载 class文件名为：G</span><br>        Class&lt;?&gt; g = myClassLoader.loadClass(<span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(g.getClassLoader());<span class="hljs-comment">//cn.example.myclassloader.MyClassLoader@1e965684</span><br>        Class&lt;?&gt; aClass = myClassLoader.loadClass(<span class="hljs-string">&quot;cn.example.cat.G&quot;</span>);<br>        <span class="hljs-comment">//两次加载是一样的，因为第一次加载时，已经放入自定义加载器的缓存中了，下次再执行时，再缓存中已经能找到，就不进行重复的加载了</span><br>        <span class="hljs-comment">//当是两个不同的类加载器，则结果是不一样的。</span><br>        System.out.println(aClass.getClassLoader());<span class="hljs-comment">//cn.example.myclassloader.MyClassLoader@1e965684</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-线程</title>
    <link href="/2022/05/29/Java-%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/05/29/Java-%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><p><strong>1. 什么是进程，什么是线程？</strong><br>答：<br><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong><br>进程是操作系统进行资源分配的最小单位，，包括CPU,内存，磁盘…，<strong>进程是具有独立功能的程序关于某个数据集上的一次运行活动。</strong>分为系统进程和用户进程（用于完成操作系统的各种功能的进程是系统进程，由你启动的进程为用户进程）</p><p><strong>线程是CPU调度的最小单位，必须依赖于进程而存在</strong>，是进程的一个实体，比进程更小，独立运行，不拥有系统资源，可与同与属于一个进程的其他线程共享进程的全部资源。</p><h2 id="两种创建多线程的方式"><a href="#两种创建多线程的方式" class="headerlink" title="两种创建多线程的方式"></a>两种创建多线程的方式</h2><h3 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><blockquote><p>（1）创建一个继承于Thread的子类<br>（2）重写Thread类的<code>run()</code>方法—-》将此线程执行的操作声明在<code>run()</code>方法中<br>（3）创建继承于Thread的子类的对象<br>（4）调用<code>start()</code>方法（该方法作用：①启动当前线程      ②调用当前线程的<code>run()</code>）</p></blockquote><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>创建两个线程分别输出偶数和奇数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>();<br>        <span class="hljs-type">MyThread2</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>();<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方式二：（实现Runnable接口）"><a href="#方式二：（实现Runnable接口）" class="headerlink" title="方式二：（实现Runnable接口）"></a><strong>方式二</strong>：（实现Runnable接口）</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><blockquote><p>（1）创建实现Runnable接口的类<br>（2）实现类去实现Runnable中的抽象方法：<code>run()</code><br>（3）创建实现类的对象<br>（4）将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象<br>（5）通过Thread类的对象调用<code>start()</code></p></blockquote><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>创建三个窗口卖票，总票数为100张，使用实现Runnable接口的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowsThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">my</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(my);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(my);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(my);<br>        t1.setName(<span class="hljs-string">&quot;窗口1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;窗口2&quot;</span>);<br>        t3.setName(<span class="hljs-string">&quot;窗口3&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> <span class="hljs-variable">stick</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span> (stick&gt;<span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;卖票，票号为:&quot;</span>+stick);<br>                stick--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两种方式比较"><a href="#两种方式比较" class="headerlink" title="两种方式比较"></a>两种方式比较</h3><p>开发中，优先选择，实现<code>Runnable</code>接口的方式，</p><p><strong>原因</strong>：（1）实现的方式没有类的单继承的局限性 （2）实现的方式更适合来处理多个线程共享数据的情况</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>上述卖票过程中，<strong>在实现Runnable接口时出现了重复票和错票—》出现了线程安全的问题</strong>。</p><p><strong>问题出现的原因</strong>：当某个线程操作车票时，还没有完成操作，其他线程参与进来也操作车票，导致的不安全。<br><strong>解决问题</strong>：当线程a操作车票时，其他线程不能参与进来，直到a操作完毕后才开始进行下一个线程的操作，<br>在java中，使用同步机制来解决线程安全的问腿。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步监视器)&#123;<br><span class="hljs-comment">//需要被同步的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong> </p><blockquote><p>（1）操作共享数据的代码，就是要同步的代码<br>（2）<strong>共享数据：</strong>多个线程共同操作的变量，比例：车票<br>（3）<code>同步监视器</code>：俗称：锁，任何一个对象都可以充当的锁（<strong>但是多个线程必须共用一把锁</strong>）</p></blockquote><p><strong>继承Runabble接口使用同步代码块的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> <span class="hljs-variable">stick</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(obj) &#123;  <span class="hljs-comment">//一定要三个线程共用一个object对象</span><br>                <span class="hljs-keyword">if</span> (stick &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖票，票号为:&quot;</span> + stick);<br>                    stick--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>继承Thread类使用同步代码块的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread3</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>();<br>        <span class="hljs-type">MyThread3</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>();<br>        <span class="hljs-type">MyThread3</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>();<br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> <span class="hljs-variable">stick</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(MyThread3.class) &#123;  <span class="hljs-comment">//一定要三个线程共用一个object对象</span><br>            <span class="hljs-comment">//其中MyThread3.class表示当前类，不能运用this，因为继承方法中，使用了三个不同的对象</span><br>                <span class="hljs-keyword">if</span> (stick &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;卖票，票号为:&quot;</span> + stick);<br>                    stick--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p><strong>同步方法</strong>：就是在操作操作共享数据的方法上加入<code>synchornized</code>关键字，为同步方法。</p><p><strong>实现runnable的方式中，同步方法的代码为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread4</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread4</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br>        a.start();<br>        b.start();<br>        c.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread4</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            show();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//this</span><br>        <span class="hljs-keyword">if</span> (ticket&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+ticket);<br>            ticket--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>继承自Thread抽象类中使用同步方法的代码块为：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">window5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread6</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread6</span>();<br>        <span class="hljs-type">MyThread6</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread6</span>();<br>        <span class="hljs-type">MyThread6</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread6</span>();<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread6</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span>  <span class="hljs-operator">=</span><span class="hljs-number">100</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            show();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//当前类本身</span><br>        <span class="hljs-keyword">if</span> (ticket&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:&quot;</span>+ticket);<br>            ticket--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关于同步方法的总结</strong></p><blockquote><p>（1）同步方法仍然涉及到同步监视器，只是不需要我们显示的声明。、</p><p>（2）非静态同步方法，同步监视器是：this</p><p>（3）静态同步方法，同步监视器是：当前类本身。</p></blockquote><h3 id="使用锁"><a href="#使用锁" class="headerlink" title="使用锁"></a>使用锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">blank</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">blank</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">blank</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">//这是实现runnable时，这么定义，当利用实现Thread类的方式去创建多线程时，要定义为静态的变量</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;售票&quot;</span> + ticket);<br>                    ticket--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="线程的死锁"><a href="#线程的死锁" class="headerlink" title="线程的死锁"></a>线程的死锁</h5><p><strong>死锁的理解</strong>：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了死锁。</p><p><strong>说明：</strong></p><blockquote><p>（1）出现死锁后，不会出现异常，不会出现提示，只是所有线程都处于阻塞的状态，无法继续。 （2）我们出现同步时，要避免出现死锁。</p></blockquote><p><strong>例题：</strong></p><ul><li>第一个线程执行完s1之后休眠，当时间过了之后要拿到s2的锁，第二个线程执行完s2之后休眠，当时间过了之后要拿到s1的锁</li><li>但是目前s1和s2的锁都在等待，都在等待对方放弃自己需要的同步资源，因此，形成了死锁。</li></ul><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (s1)&#123;<br>                    s1.append(<span class="hljs-string">&quot;a&quot;</span>);<br>                    s2.append(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br>                    <span class="hljs-keyword">synchronized</span> (s2)&#123;<br>                        s1.append(<span class="hljs-string">&quot;b&quot;</span>);<br>                        s2.append(<span class="hljs-number">2</span>);<br><br>                        System.out.println(s1);<br>                        System.out.println(s2);<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;.start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (s2)&#123;<br>                    s1.append(<span class="hljs-string">&quot;c&quot;</span>);<br>                    s2.append(<span class="hljs-number">3</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br>                    <span class="hljs-keyword">synchronized</span> (s1)&#123;<br>                        s1.append(<span class="hljs-string">&quot;d&quot;</span>);<br>                        s2.append(<span class="hljs-number">4</span>);<br>                    &#125;<br>                    System.out.println(s1);<br>                    System.out.println(s2);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>死锁必须具备以下四个条件：</strong></p><ol><li><strong>互斥条件</strong>：该资源任意⼀个时刻只由⼀个线程占⽤。</li><li><strong>请求与保持条件</strong>：⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕<br>后才释放资源。</li><li><strong>循环等待条件</strong>:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。</li></ol><p><strong>如何避免线程死锁?</strong> ：破坏四个条件</p><ol><li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li><li><strong>破坏请求与保持条件</strong> ：⼀次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p>对线程 2 的代码修改成下⾯这样就不会产⽣死锁了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br><span class="hljs-keyword">synchronized</span> (s1) &#123;<br>System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting getresource2&quot;</span>);<br><span class="hljs-keyword">synchronized</span> (s2) &#123;<br>System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;getresource2&quot;</span>);<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br></code></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><strong>饿汉式创建单例模式（本身就是线程安全的，在类加载时才会初始化）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//饿汉式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bank2</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">bank2</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">bank2</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">bank2</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> bank2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>线程安全的懒汉式单例模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">bank1</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">bank1</span><span class="hljs-params">()</span>&#123;&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">bank1</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> bank1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (instance==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (bank1.class)&#123;<br>                <span class="hljs-keyword">if</span> (instance==<span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">bank1</span>();<br>;                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>面试题：synchronized和lock的异同:</strong></p><blockquote><p>（1）相同：二者都可以解决线程安全问题<br>（2）不同：sychronized机制在执行完相应的同步代码以后，自动释放同步监视器<br>lock需要手动启动同步（<code>lock()</code>），同时结束也需要手动实现（<code>unlock()</code>）</p></blockquote><p><strong>使用的优先顺序：</strong></p><blockquote><p>lock—-&gt;同步代码块（已经进入方法体，分配了相应的资源）—-&gt;同步方法（在方法体之外）</p></blockquote><p><strong>利弊：</strong></p><blockquote><p>好处：解决线程安全问题<br>坏处：操作同步代码块时，只能一个线程参与，其他线程等待，相当于一个单线程的过程，效率低</p></blockquote><h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><p>要求线程交替打印100以内的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  * 线程通信的例子  */</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommunicationTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">communicateThread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">communicateThread</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(a);<br>        t1.start();<br>        t2.start();<br><br>    &#125; <br>&#125; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">communicateThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span> (num&lt;=<span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-comment">//唤醒线程</span><br>                notify();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;打印&quot;</span> + num);<br>                num++;<br>                <span class="hljs-comment">//想要线程交替打印</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait,notify,notifyAll"></a>wait,notify,notifyAll</h3><p><strong>涉及到的三个方法：</strong><br>（1）<code>wait()</code>:一旦执行此方法，当前前程进入阻塞状态，并释放同步监视器。<br>（2）<code>notify()</code>:一旦执行此方法，就会唤醒被wait的一个线程，如果有多个线程，唤醒优先级高的。<br>（3）<code>notifyAll()</code>:一旦执行此方法，就会唤醒所有被wait的线程。</p><p><strong>说明：</strong><br>1.<code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>三个方法，必须使用在同步代码快或者同步方法中。<br>2.<code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>三个方法，调用者必须是同步代码块或同步方法中的同步监视器。</p><p><strong>面试题：</strong><br><code>sleep()</code>,<code>wait()</code>两个方法的异同：</p><blockquote><p>1.相同点：一旦执行方法，都可以使得当前线程进入阻塞状态。<br>2.不同点：（1）声明位置不同：Thread类中声明<code>sleep()</code>,Object类中声明<code>wait()</code>。<br>(2)调用的方法不同：<code>sleep()</code>可以在任何需要的场景下调用，而<code>wait()</code>必须在同步代码块或同步方法中调用。<br>(3)关于释放同步监视器，：两个方法都使用在同步代码块或同步方法中，<code>sleep()</code>不会释放锁，<code>wait()</code>会释放锁<br>(4)<code>wait()</code>通常用于线程交互&#x2F;通信，<code>sleep()</code>通常用于暂停执行<br>(5)<code>wait()</code>方法调用后，线程不会自动苏醒，需要别的线程调⽤同⼀个对象上的 <code>notify()</code> 或者 <code>notifyAll()</code> ⽅法。<code> sleep()</code> ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ <code>wait(longtimeout)</code> 超时后线程会⾃动苏醒</p></blockquote><p><strong>练习：</strong> 例题目：生产者和消费者，生产者生产产品给柜员，柜员最多拥有20个产品，如果大于20，则生产者停止生产，消费者消费产品，如果柜员没有产品，则进行等待</p><p><strong>分析：</strong></p><ul><li><p>线程：生产者和消费者 </p></li><li><p>共享数据：柜员或产品 </p></li><li><p>是否有线程安全问题：有</p></li></ul><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductCustomerTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">clerk</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">clerk</span>();<br>        <span class="hljs-type">product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">product</span>(c);<br>        <span class="hljs-type">customer</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">customer</span>(c);<br>        p.setName(<span class="hljs-string">&quot;生产者1&quot;</span>);<br>        c1.setName(<span class="hljs-string">&quot;消费者1&quot;</span>);<br>        p.start();<br>        c1.start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//生产者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">product</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> clerk c;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">product</span><span class="hljs-params">(clerk c)</span>&#123;<br>        <span class="hljs-built_in">this</span>.c = c;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            c.productClert();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//消费者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">customer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> clerk c;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">customer</span><span class="hljs-params">(clerk c)</span>&#123;<br>        <span class="hljs-built_in">this</span>.c = c;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            c.customerClert();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//产品或店员：共享数据</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">clerk</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//生产产品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">productClert</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (num&lt;<span class="hljs-number">20</span>)&#123;<br>            num++;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始生产第&quot;</span>+num+<span class="hljs-string">&quot;个产品&quot;</span>);<br>            notify();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//消费产品</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customerClert</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (num&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始消费第&quot;</span>+num+<span class="hljs-string">&quot;个产品&quot;</span>);<br>            num--;<br>            notify();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JDK5-0新增线程创建方式"><a href="#JDK5-0新增线程创建方式" class="headerlink" title="JDK5.0新增线程创建方式"></a>JDK5.0新增线程创建方式</h1><h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><p><img src="/2022/05/29/Java-%E7%BA%BF%E7%A8%8B/image-20221102100012570.png" alt="image-20221102100012570"></p><blockquote><p>由上面的图片可以看出<code>FutureTask</code>类是实现了<code>Runnable</code>接口的。上面那一种方式正式实现<code>Runnable</code>接口并将<br>对象作为<code>Thread</code>的参数。那么显而易见可以<code>new FutureTask()</code> 作为<code>Thread</code>的参数实现创建线程。<br>不同的是<code>FutureTask</code>类需要一个参数<code>Callable</code>接口类型的对象（这时就只需要创建一个<code>Callable</code>的对象，<br>使用匿名内部类，Lambda表达式，或者创建一个类实现Callable接口 其一就能得到<code>Callable</code>类型的对象）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> a;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask); <span class="hljs-comment">//相当于Thread thread = new Thread(Runnable);</span><br>        thread.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;a=&quot;</span>+a);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadCallable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//3.创建实现Callable接口实现类的对象</span><br>        <span class="hljs-type">NumThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumThread</span>();<br>        <span class="hljs-comment">//4.将此实现Callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask对象</span><br>        <span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(thread);<br>        <span class="hljs-comment">//5.将FutureTask对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start方法。</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask).start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//6.如果要获取返回值时，获取call方法的返回值，否则，返回空，不使用下面代码</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;总和为:&quot;</span>+sum);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//1.创建一个实现Callable接口的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sum;<br>    <span class="hljs-comment">//2.实现call方法，将此线程需要执行的操作声明在call中</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<br>                System.out.println(i);<br>                sum = sum + i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何理解Callable接口的方式创建多线程比实现Runnable接口创建多线程的方式强大"><a href="#如何理解Callable接口的方式创建多线程比实现Runnable接口创建多线程的方式强大" class="headerlink" title="如何理解Callable接口的方式创建多线程比实现Runnable接口创建多线程的方式强大"></a><strong>如何理解Callable接口的方式创建多线程比实现Runnable接口创建多线程的方式强大</strong></h2><blockquote><p> （1）call()可以有返回值<br> （2）call()可以抛出异常，被外面捕获，获取异常信息<br> （3）Callable是支持泛型的</p></blockquote><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//提供指定线程数量的连接池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) executorService;<br>        <span class="hljs-comment">//设置属性</span><br>        <span class="hljs-comment">// 要在ThreadPoolExecutor类中设置，因为ExecutorService是接口，ThreadPoolExecutor是实现类。</span><br><span class="hljs-comment">//        service.setCorePoolSize(15);</span><br>        executorService.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumThread2</span>());<span class="hljs-comment">//适用于实现Runnable</span><br><span class="hljs-comment">//        executorService.submit(Callable callable)//适用于实现Callable</span><br>        executorService.shutdown(); <span class="hljs-comment">//关闭连接池</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用线程池的好处:</strong></p><blockquote><p> (1)提高响应速度(减少创建新线程的时间)<br> (2)降低资源的消耗(重复利用线程池中的线程,不需要每次都创建)<br> (3)便于线程管理:<br>     <code>corePoolSize</code>:核心池的大小<br>     <code>maximumPoolSize</code>:最大线程数<br>     <code>keepAliveTime</code>:线程没有任务时最多保持多长时间会终止</p></blockquote><h2 id="线程池的创建推荐"><a href="#线程池的创建推荐" class="headerlink" title="**线程池的创建推荐"></a>**线程池的创建推荐</h2><p><img src="/2022/05/29/Java-%E7%BA%BF%E7%A8%8B/image-20221102100740950.png" alt="image-20221102100740950"></p><h2 id="ThreadPoolExecutor方式（阿里推荐）"><a href="#ThreadPoolExecutor方式（阿里推荐）" class="headerlink" title="ThreadPoolExecutor方式（阿里推荐）"></a>ThreadPoolExecutor方式（阿里推荐）</h2><p><strong>1，ThreadPoolExecutor的实例化七个参数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.concurrent.ThreadPoolExecutor类的构造器（其一）：<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                         <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params"> <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params"> TimeUnit unit,</span><br><span class="hljs-params"> BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params"> ThreadFactory threadFactory,</span><br><span class="hljs-params">                         RejectedExecutionHandler handler)</span> <br>     &#123;<br><span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>maximumPoolSize &lt; corePoolSize ||<br>keepAliveTime &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br><span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><span class="hljs-built_in">this</span>.acc = System.getSecurityManager() == <span class="hljs-literal">null</span> ?<span class="hljs-literal">null</span> :<br>AccessController.getContext();<br><span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br><span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br><span class="hljs-built_in">this</span>.workQueue = workQueue;<br><span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br><span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br><span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>构造器七个参数：<br>[1] corePoolSize：线程池中的常驻核心线程数</p><p>[2] maximumPoolSize：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1</p><p>[3] keepAliveTime：多余的空闲线程的存活时间。当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime的线程会被销毁，直到剩余线程数量等于 corePoolSize</p><p>[4] unit：keepAliveTime的时间单位</p><p>[5] workQueue：任务队列，被提交但尚未被执行的任务</p><p>[6] threadFactory：表示生成线程池中工作线程的工厂， 用于创建线程，一般默认的即可</p><p>[7] handler：拒绝策略处理器。当任务队列已满，工作线程也达到了maximumPoolSize，新增的工作任务将按照某个既定的拒绝策略被拒绝执行。</p></blockquote><p><strong>2. 其中任务队列的类型(BlockingQueue接口)，有七个实现类，创建线程时根据业务选择</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">1</span>] ArrayBlockingQueue：由数组结构组成的有界阻塞队列。<br>    <br>[<span class="hljs-number">2</span>] LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。<br>    <br>[<span class="hljs-number">3</span>] PriorityBlockingQueue：支持优先级排序的无界阻塞队列。<br>    <br>[<span class="hljs-number">4</span>] DelayQueue：使用优先级队列实现的延迟无界阻塞队列。<br>    <br>[<span class="hljs-number">5</span>] SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。<br>    <br>[<span class="hljs-number">6</span>] LinkedTransferQueue：由链表组成的无界阻塞队列。<br>    <br>[<span class="hljs-number">7</span>] LinkedBlockingDeque：由链表组成的双向阻塞队列。<br></code></pre></td></tr></table></figure><p><strong>3. 拒绝策略处理器，创建线程时根据业务选择</strong></p><pre><code class="hljs">  一般我们创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但这种模式下如果出现任务队列已满且线程池创建的线程数达到你设置的最大线程数时，这时就需要你指定`ThreadPoolExecutor`的`RejectedExecutionHandler`参数即合理的拒绝策略，来处理线程池“超载”的情况。</code></pre><blockquote><p><strong>ThreadPoolExecutor自带的拒绝策略如下：</strong><br>[1] AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</p><p>[2] CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</p><p>[3] DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</p><p>[4] DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</p><p>以上内置的策略均实现了RejectedExecutionHandler接口，也可以自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略。</p></blockquote><p><strong>使用ThreadPoolExecutor方式手写线程池：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span>  <span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maximumPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">keepAliveTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">TimeUnit</span> <span class="hljs-variable">unit</span> <span class="hljs-operator">=</span> TimeUnit.SECONDS;<br>        <span class="hljs-type">BlockingDeque</span> <span class="hljs-variable">workQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> Executors.defaultThreadFactory();<br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">policy</span> <span class="hljs-operator">=</span><br>                <span class="hljs-comment">// 当触发拒绝策略所满足条件时会抛出异常：java.util.concurrent.RejectedExecutionException</span><br>                <span class="hljs-comment">// new ThreadPoolExecutor.AbortPolicy();</span><br><br>                <span class="hljs-comment">// 当触发拒绝策略所满足条件时会将任务转回调用者（main线程）执行</span><br>                <span class="hljs-comment">// new ThreadPoolExecutor.CallerRunsPolicy();</span><br><br>                <span class="hljs-comment">// 当触发拒绝策略所满足条件时会放弃等待时间最长的那个任务</span><br>                <span class="hljs-comment">// new ThreadPoolExecutor.DiscardOldestPolicy();</span><br><br>                <span class="hljs-comment">// 当触发拒绝策略所满足条件时会静默丢弃新的任务</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy();<br>        <span class="hljs-comment">//创建线程池对象</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, policy);<br>        <span class="hljs-comment">//使用自己创建的线程池</span><br>        threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;正在工作&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>submit()和execute方法区别</strong><br>1.submit() 方法可以配合 Future来接收线程执行的返回值，而 execute() 不能接收返回值；<br>2.execute() 方法属于 Executor 接口的方法，而 submit() 方法则是属于 ExecutorService 接口的方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaSE</tag>
      
      <tag>线程</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
