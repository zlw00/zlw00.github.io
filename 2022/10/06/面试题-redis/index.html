

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#447EA5">
  <meta name="author" content="zlw">
  <meta name="keywords" content="">
  
    <meta name="description" content="redis底层数据结构String因为redis是使用C语言开发的，自然没有java的哪些字符串类库，在redis中自定义了一种字符串，叫做SDS（简单动态字符串）（Simple Dynamic String） sds的底层是使用一个结构体实现的： 12345678struct sdshdr &amp;#123;	&#x2F;&#x2F; 记录 buf 数组中已使用字节的数量，它等于 SDS 所保存字符串的长度	int le">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题-redis">
<meta property="og:url" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/index.html">
<meta property="og:site_name" content="zlw">
<meta property="og:description" content="redis底层数据结构String因为redis是使用C语言开发的，自然没有java的哪些字符串类库，在redis中自定义了一种字符串，叫做SDS（简单动态字符串）（Simple Dynamic String） sds的底层是使用一个结构体实现的： 12345678struct sdshdr &amp;#123;	&#x2F;&#x2F; 记录 buf 数组中已使用字节的数量，它等于 SDS 所保存字符串的长度	int le">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323123918257.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323123958954.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323133702901.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323135547951.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323135617155.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323135630954.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1754362-20210516161648249-356996541.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1754362-20210516161655382-2073870704.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1754362-20210516161703961-1686295837.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20220607134236942.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230322124156151.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193316929.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193402245.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193921939.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193957439.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221007091501846.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20190105163846560.jpg">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221028180718550.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221028183529128.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20224285758787.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20224285758788.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20224285758789.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20210421172417360.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/e3d4e1cbd03b5326eb8b3f15a7fc73bc.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/834fcb5588972d9be273189239bf0aba.png">
<meta property="og:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1031302-20201106204833000-564795432.png">
<meta property="article:published_time" content="2022-10-06T04:48:15.000Z">
<meta property="article:modified_time" content="2023-04-14T12:43:01.596Z">
<meta property="article:author" content="zlw">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323123918257.png">
  
  
  
  <title>面试题-redis - zlw</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/diy/shubiao.css">
<link rel="stylesheet" href="/css/mac.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiantiao.js.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css# 鼠标指针.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"8pDDCsRJCVNm1OXHuh0xASVj-gzGzoHsz","app_key":"MnpSoeG5QTTJ4GagUMOq5t7J","server_url":"https://leancloud.cn","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>欢迎来到张露文的Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试题-redis"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-06 12:48" pubdate>
          2022年10月6日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          134 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试题-redis</h1>
            
            <div class="markdown-body">
              
              <h1 id="redis底层数据结构"><a href="#redis底层数据结构" class="headerlink" title="redis底层数据结构"></a>redis底层数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>因为redis是使用C语言开发的，自然没有java的哪些字符串类库，在redis中自定义了一种字符串，叫做<strong>SDS（简单动态字符串）</strong>（Simple Dynamic String）</p>
<p>sds的底层是使用一个结构体实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">struct sdshdr &#123;<br>	<span class="hljs-comment">// 记录 buf 数组中已使用字节的数量，它等于 SDS 所保存字符串的长度</span><br>	<span class="hljs-type">int</span> len;<br>	<span class="hljs-comment">// 记录 buf 数组中未使用字节的数量</span><br>	<span class="hljs-type">int</span> free;<br>	<span class="hljs-comment">// 字节数组，用于保存字符串</span><br>	<span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323123918257.png" srcset="/img/loading.gif" lazyload alt="image-20230323123918257"></p>
<ul>
<li>free 属性的值为0， 表示这个SDS没有分配任何未使用空间</li>
<li>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</li>
<li>buf属性是一个char类型的数组，数组的前五个字节分别保存了’R’、‘e’、‘d’、‘i’、‘s’五个字符，而最后一个字节则保存了空字符’\0’。</li>
</ul>
<blockquote>
<p>SDS 遵循C字符串以空字符串结尾的惯例，保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面，并且为空字符分配额外的 1 字节空间</p>
</blockquote>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323123958954.png" srcset="/img/loading.gif" lazyload alt="image-20230323123958954"></p>
<p>这个SDS和之前展示的SDS一样,都保存了字符串值”Redis”。这个SDS和之前展示的SDS的区别在于，这个SDS为buf数组分配了五字节未使用空间，所以它的free属性的值为5(图中使用五个空格来表示五字节的未使用空间)</p>
<p><strong>SDS与C字符串的区别：</strong></p>
<p>（1）<strong>常数复杂度获取字符串长度</strong>：直接访问len就可以了。</p>
<p>（2）<strong>杜绝缓冲区溢出，</strong>当对SDS进行修改时，会先检查空间是否满足修改所需要的要求，如果不满足，进行空间扩展，再修改。C如果不进行内存重新分配的话就会发生溢出。</p>
<p>（3）<strong>减少内存重新分配次数</strong>：当增加和缩短字符串的时候，C每次都需要一次内存分配，扩展内存空间或者释放内存空间。由于内存分配涉及复杂的算法，需要系统调用，很耗时，而SDS通过空间预分配和惰性空间两种优化策略。</p>
<p><strong>空间预分配：</strong></p>
<ul>
<li><p>对SDS修改之后，SDSlen属性的值小于1MB,  那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。例，SDS 的len将变成13字节，那么程序也会分配13字节的未使用空间，实际长度将变成 <strong>13+13+1&#x3D;27</strong> 字节</p>
</li>
<li><p>对SDS修改之后，SDS 的长度大于等于1MB，那么程序会分配1MB 的未使用空间。如果进行修改之后，SDS的len将变成30MB，SDS的buf数组的实际长度为 <strong>30 MB + 1 MB + 1bytes</strong></p>
</li>
</ul>
<p><strong>惰性空间释放</strong></p>
<p>优化SDS的字符串缩短操作:缩短字符串时，程序并不立即回收缩短多出来的字节，而是使用free属性记录起来，并等待将来使用。</p>
<p>（4）<strong>二进制安全：通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。</strong></p>
<p><strong>举个例子：</strong> 存入 “Redis Cluster” 这种格式就不能用C字符串来保存，因为C字符串所用的函数只会识别出其中的 “Redis” 而忽略之后的 “Cluster”。为了确保 Redis 可以使用不同的场景，SDS 的 API 都是二进制安全的，所有SDS API 都会以处理二进制的方式来处理 SDS 里的数据，数据在被写入时是什么样的，它被读取时就是什么样的。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p><strong>存储在连续内存上的特殊双向链表</strong></p>
<p>其中各部分代表的含义如下：</p>
<ul>
<li>zlbytes：4个字节（32bits），表示ziplist占用的总字节数</li>
<li>zltail：4个字节（32bits），表示ziplist中最后一个节点在ziplist中的偏移字节数</li>
<li>entries：2个字节（16bits），表示ziplist中的元素数</li>
<li>entry：长度不定，表示ziplist中的数据</li>
<li>zlend：1个字节（8bits），表示结束标记，这个值固定为ff（255）</li>
</ul>
<p><strong>特点：</strong></p>
<ol>
<li><p>ziplist 为了节省内存，采用了紧凑的连续存储。所以在修改操作下并不能像一般的链表那么容易，需要从新分配新的内存，然后复制到新的空间。</p>
</li>
<li><p>ziplist类似一个封装的数组，通过zltail可以方便地进行追加和删除尾部数据、使用entries可以方便地计算长度</p>
</li>
<li><p>新增或更新元素可能会出现连锁更新现象。</p>
</li>
<li><p>不能保存过多的元素，否则查询效率就会降低。</p>
<p><strong>通过以上的3、4点就引出了quicklist。</strong></p>
</li>
</ol>
<p><strong>连锁更新现象：</strong></p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323133702901.png" srcset="/img/loading.gif" lazyload alt="image-20230323133702901"></p>
<h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>由于ziplist不能保存过多的元素，否则查询性能大大降低，并且会发生连锁更新的情况。因此提出quicklist。</p>
<p><strong>结合了原先 linkedlist 与 ziplist 各自的优势，本质还是一个链表，只不过链表的每个节点是一个 ziplist。</strong></p>
<p>quicklist 是综合考虑了时间效率与空间效率引入的新型数据结构。<strong>结合了原先 linkedlist 与 ziplist 各自的优势，本质还是一个链表，只不过链表的每个节点是一个 ziplist。</strong></p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323135547951.png" srcset="/img/loading.gif" lazyload alt="image-20230323135547951"></p>
<p>可毕竟还是使用了 ziplist，本质上无法避免连锁更新的问题，于是乎在 5.0 版本设计出另一个内存紧凑型数据结构 listpack，于 7.0 版本替换掉 ziplist。</p>
<h3 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h3><p><strong>listpack 也是一种紧凑型数据结构，用一块连续的内存空间来保存数据，并且使用多种编码方式来表示不同长度的数据来节省内存空间。</strong></p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323135617155.png" srcset="/img/loading.gif" lazyload alt="image-20230323135617155"></p>
<ul>
<li>tot-bytes，也就是 total bytes，占用 4 字节，记录 listpack 占用的总字节数。</li>
<li>num-elements，占用 2 字节，记录 listpack elements 元素个数。</li>
<li>elements，listpack 元素，保存数据的部分。、</li>
<li>listpack-end-byte，结束标志，占用 1 字节，值固定为 255。</li>
</ul>
<p>element <strong>不再像 ziplist 的 entry 保存前一项的长度</strong>。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230323135630954.png" srcset="/img/loading.gif" lazyload alt="image-20230323135630954"></p>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p>
<p>整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存int16_t、int32_t、int64_t的整数值，且保证集合中不出现重复元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">typedef struct intset&#123;<br>    <span class="hljs-comment">//编码方式</span><br>    uint32_t encoding;<br>    <span class="hljs-comment">//集合包含的元素数量</span><br>    uint32_t length;<br>    <span class="hljs-comment">//保存元素的数组</span><br>    int8_t contents[];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="整数集合的升级"><a href="#整数集合的升级" class="headerlink" title="整数集合的升级"></a>整数集合的升级</h4><p>当我们向一个已经存在的整数集合中添加元素时，如果加入的元素的数据类型比contents[]数组元素的数据类型长，则整数集合需要进行升级，举个例子，我要在<strong>上面那个大小5的16位整数集合</strong>中插入一个类型为int32_t的整数65535：</p>
<ol>
<li>升级首先要做的是，根据新元素的长度，扩大空间，目前有5个元素，加入一个后有6个，且int16_t的元素要升级为int32_t类型（需要6 * 32 &#x3D; 192位的空间），因此需要先动态分配内存空间如下：</li>
</ol>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1754362-20210516161648249-356996541.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol>
<li>移动元素的位置，将14632往后移动到新的位置，末尾留下一个位置存放32位的65535</li>
</ol>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1754362-20210516161655382-2073870704.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol>
<li>同理移动233、18、-5、-6370，并最后将末尾的空间中存入65535</li>
</ol>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1754362-20210516161703961-1686295837.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="整数集合不支持降级"><a href="#整数集合不支持降级" class="headerlink" title="整数集合不支持降级"></a>整数集合不支持降级</h4><p>如果因为插入一个32位的整数使得原本16位的contents[]数组转变为32位，后面又删去了这个32位的整数，这个整数集合将不会降级成16位的contents[]数组</p>
<h1 id="redis常用的基本类型"><a href="#redis常用的基本类型" class="headerlink" title="redis常用的基本类型"></a>redis常用的基本类型</h1><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>（1）<code>keys *</code> ：查看当前库中所有的key</p>
<p><a target="_blank" rel="noopener" href="https://zlw00.github.io/2022/06/07/redis/image-20220607134236942.png"><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20220607134236942.png" srcset="/img/loading.gif" lazyload alt="image-20220607134236942"></a></p>
<p>（2）<code>exists key</code> ：判断某个 key 是否存在</p>
<p>（3）<code>type key</code>：查看你的 key 是什么类型</p>
<p>（4）<code>del key</code> ：删除指定的 key 数据 &#x2F; unlink key 根据 value 选择非阻塞删除</p>
<p>（5）<code>expire key 10</code> ：10 秒钟：为给定的 key 设置过期时间</p>
<p>（6）<code>ttl key</code> ：查看还有多少秒过期，-1 表示永不过期，-2 表示已过期</p>
<p>（7）<code>select</code> ：命令切换数据库</p>
<p>（8）<code>dbsize</code> ：查看当前数据库的 key 的数量</p>
<p>（9） <code>flushdb</code> ：清空当前库 &#x2F; <code>flushall</code> ：通杀全部库</p>
<h2 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h2><p>底层数据结构：<strong>动态字符串</strong>，是可以修改的字符串，内部结构上类似于java的ArrayList。</p>
<p><strong>常用命令</strong></p>
<p>（1）<code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对(内容能用字符串表示的)如果设置相同的key，则前面的value被覆盖</p>
<p>（2）<code>get &lt;key&gt;</code>：查询对应键值</p>
<p>（3）<code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 追加到原值的末尾</p>
<p>（4）<code>strlen &lt;key&gt;</code>：获得值的长度</p>
<p>（5）<code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 key 不存在时 设置 key 的值</p>
<p>（6）<code>incr &lt;key&gt;</code> ：将 key 中储存的数字值增 1 （只能对数字操作）</p>
<p>（7）<code>decr &lt;key&gt;</code> ：将 key 中储存的数字值减 1 （只能对数字操作）</p>
<p>（8） <code>incrby / decrby &lt;key&gt;&lt;步长&gt;</code>：将 key 中储存的数字值增减。自定义步长。</p>
<ul>
<li>是原子性的：<strong>所谓原子操作是指不会被线程调度机制打断的操作；</strong></li>
<li>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li>
<li>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li>
<li>Redis 单命令的原子性主要得益于 Redis 的单线程。</li>
</ul>
<p>（9）<code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code>同时设置一个或多个 key-value 对</p>
<p>（10）<code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....</code>同时获取一个或多个 value</p>
<p>（11）<code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt; .....</code> ：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</p>
<p>（12）<code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>： 获得值的范围</p>
<p>（13）<code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code> ：用 覆写所储存的字符串值，从&lt;起始位置&gt;开始(索引从 0 开始)。</p>
<p>（14）<code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒</p>
<p>（15）<code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>当数据量比较少的时候，使用的是ziplist</strong>，因为普通的链表需要的附加指针空间太大，会比较浪费空间。</p>
<p><strong>当数据量比较大的时候，使用的是quickList</strong>（也就是将多个ziplist使用双指针串起来使用），既满足快速插入，又不会出现太大的冗余。</p>
<p><strong>单键多值 按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</strong> <strong>它的底层实际是个双向链表，</strong></p>
<p><strong>常用命令</strong></p>
<p>（1）<code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边&#x2F;右边插入一个或多个值。<br>（2）<code>lpop/rpop &lt;key&gt;</code>从左边&#x2F;右边吐出一个值。值在键在，值光键亡。<br>（3）<code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>从列表右边吐出一个值，插到列表左边。<br>（4）<code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>按照索引下标获得元素(从左到右)<br>（5）<code>lrange mylist 0 -1 0</code> 左边第一个，-1 右边第一个，（0-1 表示获取所有）<br>（6）<code>lindex &lt;key&gt;&lt;index&gt;</code>按照索引下标获得元素(从左到右)<br>（7）<code>llen &lt;key&gt;</code>获得列表长度<br>（8）<code>linsert &lt;key&gt; before &lt;value&gt;&lt;newvalue&gt;</code>在的后面插入插入值<br>（9）<code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>从左边删除 n 个 value(从左到右)<br>（10）<code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>将列表 key 下标为 index 的值替换成 value</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 数据结构是 dict 字典，<strong>字典是用哈希表实现的</strong>。</p>
<p>特殊之处在于 <strong>set 是可以自动排重的</strong></p>
<p><strong>常用命令</strong></p>
<p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....</code>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略<br><code>smembers &lt;key&gt;</code>取出该集合的所有值。<br><code>sismember &lt;key&gt;&lt;value&gt;</code>判断集合是否为含有该值，有 1，没有 0<br><code>scard&lt;key&gt;</code>返回该集合的元素个数。</p>
<p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code> 删除集合中的某个元素。<br><code>spop &lt;key&gt;</code>随机从该集合中吐出一个值。<br><code>srandmember &lt;key&gt;&lt;n&gt;</code>随机从该集合中取出 n 个值。不会从集合中删除 。<br><code>smove &lt;source&gt;&lt;destination&gt;value</code> 把集合中一个值从一个集合移动到另一个集合<br><code>sinter &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的交集元素。<br><code>sunion &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的并集元素。<br><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>返回两个集合的差集元素(key1 中的，不包含 key2 中的)</p>
<h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p><strong>zset 底层使用了两个数据结构</strong><br><strong>（1）hash</strong>，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。<br><strong>（2）跳跃表，</strong>跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20230322124156151.png" srcset="/img/loading.gif" lazyload alt="image-20230322124156151"></p>
<p>Redis 有序集合 zset 与普通集合 set 非常相似，是一个<strong>没有重复元素</strong>的字符串集合。<br>不同之处是有序集合的每个成员都关联了一个<strong>评分（score）</strong>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复了 。</strong></p>
<p><strong>常用命令</strong></p>
<p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code> [WITHSCORES]返回有序集 key 中，下标在之间的元素带 WITHSCORES，可以让分数一起和值返回到结果集。<br><code>zrangebyscore key minmax [withscores] [limit offset count]</code>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。<br><code>zrevrangebyscore key maxmin [withscores] [limit offset count]</code>同上，改为从大到小排列。</p>
<p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code> 为元素的 score 加上增量<br><code>zrem &lt;key&gt;&lt;value&gt;</code>删除该集合下，指定值的元素<br><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>统计该集合，分数区间内的元素个数<br><code>zrank &lt;key&gt;&lt;value&gt;</code>返回该值在集合中的排名，从 0 开始。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash 类型对应的数据结构是两种： <strong>ziplist（压缩列表）， hashtable（哈希表）</strong>。 当field-value 长度较短且个数较少时， 使用 ziplist， 否则使用 hashtable。</p>
<p><strong>常用命令</strong></p>
<p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给集合中的 键赋值<br><code>hget &lt;key1&gt;&lt;field&gt;</code>：从集合取出 value<br><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code> ：批量设置 hash 的值<br><code>hexists&lt;key1&gt;&lt;field&gt;</code>：查看哈希表 key 中， 给定域 field 是否存在。<br><code>hkeys &lt;key&gt;</code>：列出该 hash 集合的所有 field<br><code>hvals &lt;key&gt;：</code>列出该 hash 集合的所有 value<br><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;：</code>为哈希表 key 中的域 field 的值加上增量 1 -1<br><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;：</code>将哈希表 key 中的域 field 的值设置为 value ， 当且仅当域field 不存在</p>
<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34412579/article/details/101731935">https://blog.csdn.net/qq_34412579/article/details/101731935</a></p>
<h2 id="什么是跳表"><a href="#什么是跳表" class="headerlink" title="什么是跳表"></a><strong>什么是跳表</strong></h2><p>​	跳表是可以实现二分查找的有序单链表。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193316929.png" srcset="/img/loading.gif" lazyload alt="image-20221126193316929"></p>
<h2 id="跳表查找的时间复杂度为O-logn"><a href="#跳表查找的时间复杂度为O-logn" class="headerlink" title="跳表查找的时间复杂度为O(logn)"></a><strong>跳表查找的时间复杂度为O(logn)</strong></h2><p>​	时间复杂度 &#x3D; 索引的高度 * 每层索引遍历元素的个数。</p>
<p>​	<strong>先来求跳表的索引高度。</strong>如下图所示，假设每两个结点会抽出一个结点作为上一级索引的结点，原始的链表有n个元素，则一级索引有n&#x2F;2 个元素、二级索引有 n&#x2F;4 个元素、k级索引就有 n&#x2F;2k个元素。最高级索引一般有2个元素，即：最高级索引 h 满足 2 &#x3D; n&#x2F;2^h，即 h &#x3D; log2n - 1，最高级索引 h 为索引层的高度加上原始数据一层，跳表的总高度 h &#x3D; log2n。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193402245.png" srcset="/img/loading.gif" lazyload alt="image-20221126193402245"></p>
<p>​	图中所示，现在到达第 k 级索引，我们发现要查找的元素 x 比 y 大比 z 小，所以，我们需要从 y 处下降到 k-1 级索引继续查找，k-1级索引中比 y 大比 z 小的只有一个 w，所以在 k-1 级索引中，我们遍历的元素最多就是 y、w、z，发现 x 比 w大比 z 小之后，再下降到 k-2 级索引。所以，k-2 级索引最多遍历的元素为 w、u、z。其实每级索引都是类似的道理，每级索引中都是两个结点抽出一个结点作为上一级索引的结点。 现在我们得出结论：当每级索引都是两个结点抽出一个结点作为上一级索引的结点时，每一层最多遍历3个结点。</p>
<p>跳表的索引高度 <code>h = log2n</code>，<strong>且每层索引最多遍历 3 个元素</strong>。所以跳表中查找一个元素的时间复杂度为 <code>O(3*logn)</code>，省略常数即：**O(logn)**。</p>
<h2 id="跳表的空间复杂度O-n"><a href="#跳表的空间复杂度O-n" class="headerlink" title="跳表的空间复杂度O(n)"></a>跳表的空间复杂度<strong>O(n)</strong></h2><p>跳表是典型的”空间换时间“的思想</p>
<p>假如原始链表包含 n 个元素，则一级索引元素个数为 <code>n/2</code>、二级索引元素个数为 <code>n/4</code>、三级索引元素个数为 <code>n/8</code> 以此类推。所以，索引节点的总和是：n<code>/2+n/4+n/8 … 8+4+2 = n-2</code>，**空间复杂度是 O(n)**。</p>
<h2 id="跳表的插入数据"><a href="#跳表的插入数据" class="headerlink" title="跳表的插入数据"></a>跳表的插入数据</h2><p> 通过<code>randomLevel()</code>方法返回当前元素要插入的层级</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193921939.png" srcset="/img/loading.gif" lazyload alt="image-20221126193921939"></p>
<p>整个插入过程的路径与查找元素路径类似， 每层索引中插入元素的时间复杂度 <code>O(1)</code>，所以整个插入的时间复杂度是 **O(logn)**。</p>
<h2 id="跳表的删除数据"><a href="#跳表的删除数据" class="headerlink" title="跳表的删除数据"></a>跳表的删除数据</h2><p>​	跳表删除数据时，要把索引中对应节点也要删掉。如下图所示，如果要删除元素 9，需要把原始链表中的 9 和第一级索引的 9 都删除掉。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221126193957439.png" srcset="/img/loading.gif" lazyload alt="image-20221126193957439"></p>
<p>​	删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素 <code>x</code>，则执行删除操作。跳表中，每一层索引其实都是一个有序的单链表，单链表删除元素的时间复杂度为 <code>O(1)</code>，索引层数为 <code>logn</code> 表示最多需要删除 <code>logn</code> 个元素，所以删除元素的总时间包含 查找元素的时间 加 删除 logn个元素的时间 为 <code>O(logn)+O(logn) = 2 O(logn)</code>，忽略常数部分，**删除元素的时间复杂度为 O(logn)**。</p>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存雪崩是<strong>指当缓存中有大量的key在同一时刻过期，或者Redis直接宕机了</strong>，导致大量的查询请求全部到达数据库，造成数据库查询压力骤增，甚至直接挂掉。</p>
<p><strong>解决</strong>：只需要将每个key的过期时间打散即可，使它们的失效点尽可能均匀分布。</p>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿是<strong>指当缓存中某个热点数据过期了</strong>，在该热点数据重新载入缓存之前，有大量的查询请求穿过缓存，直接查询数据库。<br><strong>解决：</strong>设置key永不过期</p>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>缓存穿透是指<strong>查询一个缓存中和数据库中都不存在的数据</strong>，导致每次查询这条数据都会透过缓存，直接查库，最后返回空。</p>
<p><strong>解决：</strong>布隆过滤器</p>
<h1 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h1><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p><strong>AOF重写的执行流程：</strong></p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221007091501846.png" srcset="/img/loading.gif" lazyload alt="image-20221007091501846"></p>
<ul>
<li>触发重写，执行bgrewriteaof命令</li>
<li>父进程fork子进程进行重写，fork子进程的同时，父进程阻塞，fork完毕父进程继续接受指令。</li>
<li>子进程在创建新的aof的同时，子进程根据内存快照，按照命令合并规则写入到新的AOF文件。父进程继续接受指令， 存储到<code>aof_buf</code>和<code>aof_rewirte_buf</code>缓存中，所以父进程继续往旧的aof文件中备份，同时也要往新的aof文件中备份。</li>
<li>新的aof备份完成</li>
<li>父进程备份新的文件创建完成</li>
<li>将<code>aof_rewrite_buf</code>缓存中的备份到新的aof文件中</li>
<li>新的文件替换旧的aof文件。</li>
</ul>
<h1 id="说一下redis和Memcached的区别和共同点"><a href="#说一下redis和Memcached的区别和共同点" class="headerlink" title="说一下redis和Memcached的区别和共同点"></a>说一下redis和Memcached的区别和共同点</h1><p><strong>共同点：</strong></p>
<ul>
<li>都基于内存数据库，一般都用来当作缓存使用</li>
<li>都有过期策略</li>
<li>两者的性能都非常高</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>redis支持更丰富的数据类型，（list，set，zset，hash）</li>
<li>redis支持持久化操作</li>
<li>redis有灾难恢复机制，因为有持久化功能</li>
<li>redis在服务器内存使用完之后，将不用的数据放到磁盘上，而Memcached在服务器中内存使用后，直接报异常</li>
<li>memcached是多线程，非阻塞IO复用模型，redis是单线程，多路IO复用模型</li>
<li>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>Redis：数据量较小的高性能操作和运算上。</li>
<li>memcache：用于在动态系统中减少数据库负载，提升性能; 做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用 sharding）。</li>
<li>MongoDB: 主要解决海量数据的访问效率问题。</li>
</ul>
<h1 id="redis如何使用事务"><a href="#redis如何使用事务" class="headerlink" title="redis如何使用事务"></a>redis如何使用事务</h1><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/multi"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<code>exec</code> 命令后，再执行所有的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br>&gt; GET PROJECT<br>QUEUED<br>&gt; EXEC<br>1) OK<br>2) <span class="hljs-string">&quot;JavaGuide&quot;</span><br></code></pre></td></tr></table></figure>

<p><code>DISCARD：</code>取消一个事务，它会清空事务队列中保存的所有命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br>&gt; GET PROJECT<br>QUEUED<br>&gt; DISCARD<br>OK<br></code></pre></td></tr></table></figure>

<p>你可以通过[<code>WATCH</code>命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端&#x2F;Session</strong> 修改的话，整个事务都不会被执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 客户端 1</span><br>&gt; SET PROJECT <span class="hljs-string">&quot;RustGuide&quot;</span><br>OK<br>&gt; WATCH PROJECT<br>OK<br>&gt; MULTI<br>OK<br>&gt; SET PROJECT <span class="hljs-string">&quot;JavaGuide&quot;</span><br>QUEUED<br><br><span class="hljs-comment"># 客户端 2</span><br><span class="hljs-comment"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span><br>&gt; SET PROJECT <span class="hljs-string">&quot;GoGuide&quot;</span><br><br><span class="hljs-comment"># 客户端 1</span><br><span class="hljs-comment"># 修改失败，因为 PROJECT 的值被客户端2修改了</span><br>&gt; EXEC<br>(nil)<br>&gt; GET PROJECT<br><span class="hljs-string">&quot;GoGuide&quot;</span><br></code></pre></td></tr></table></figure>

<h1 id="redis不支持原子性"><a href="#redis不支持原子性" class="headerlink" title="redis不支持原子性"></a>redis不支持原子性</h1><p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<h1 id="Redis单线程为什么这么快？"><a href="#Redis单线程为什么这么快？" class="headerlink" title="Redis单线程为什么这么快？"></a>Redis单线程为什么这么快？</h1><p>1.redis是基于内存的，内存的读写速度非常快；</p>
<p>2.redis是单线程的，省去了很多上下文切换线程的时间；</p>
<p>3.采用IO多路复用机制</p>
<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/10225159.html#autoid-h2-5-0-0">https://www.cnblogs.com/crazymakercircle/p/10225159.html#autoid-h2-5-0-0</a></p>
<p><strong>IO多路复用的基本原理就是，单个线程不断的轮询select&#x2F;epoll系统调用所负责的成百上千的scoket连接，当某个或者某些连接有数据到达的时候，就返回这些可读写的连接，因此好处就是通过一次select&#x2F;epoll的系统调用，就可以读写一个甚至成百上千的连接。</strong></p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20190105163846560.jpg" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p><strong>发起一个多路复用IO的的read读操作系统调用，流程是这个样子：</strong></p>
<p>（1）不断的进行select&#x2F;epoll系统调度，查询可以读的连接，只要有连接数据到达，就返回该连接（当用户线程调用select时，整个线程被block）</p>
<p>（2）建立连接后，发起read系统调用，将内核缓冲区的数据复制到用户缓冲区，然后返回结果。</p>
<p>（3）用户线程读取了数据。接触block。</p>
<p>IO多路复用，用到两个系统调用，一个是select&#x2F;epoll调用，另一个是IO读取调用。</p>
<p><strong>优点：</strong>使用select&#x2F;epoll就可以同属处理成千上万的连接，与一条线程维护一条连接相比，系统不必创建线程，不必维护线程，减少了系统的开销。</p>
<p><strong>缺点：</strong>读写过程是阻塞的。</p>
<h1 id="redis中基本数据类型的zset底层是什么"><a href="#redis中基本数据类型的zset底层是什么" class="headerlink" title="redis中基本数据类型的zset底层是什么"></a>redis中基本数据类型的zset底层是什么</h1><p>（1）hash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</p>
<p>（2）跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221028180718550.png" srcset="/img/loading.gif" lazyload alt="image-20221028180718550"></p>
<h1 id="redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程"><a href="#redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程" class="headerlink" title="redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程"></a>redis是多线程还是单线程，什么时候引入的多线程，为什么之前使用单线程</h1><p><strong>单线程，可以设置为多线程，。</strong></p>
<p><strong>在redis6.0之后引入的多线程，。</strong></p>
<p><strong>为什么之前不使用多线程？</strong></p>
<p>（1）单线程编程容易并且更容易维护；</p>
<p>（2）多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</p>
<p><strong>如果需要开启多线程，则需要修改redis的配置文件：</strong></p>
<p><code>io-threads-do-reads yes</code></p>
<p><strong>redis的文件处理器通过IO多路复用来监听大量的客户端连接。</strong></p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/image-20221028183529128.png" srcset="/img/loading.gif" lazyload alt="image-20221028183529128"></p>
<h1 id="为什么redis6-0之后使用多线程"><a href="#为什么redis6-0之后使用多线程" class="headerlink" title="为什么redis6.0之后使用多线程"></a>为什么redis6.0之后使用多线程</h1><p>因为对redis有更高的要求。</p>
<p>redis对于小数据包来说，对于80%的公司已经足够使用了。</p>
<p>但随着越来越复杂的业务场景，有些公司达到上亿的交易量，因此需要更大的查询效率。</p>
<p>为了提升查询效率，很多公司的做法是部署Redis集群，尽可能的提升redis机器数，但这种做法的资源消耗是巨大的。</p>
<p>经过分析限制redis的性能主要瓶颈出现在网络IO处理上，虽然采用了IO多路复用技术，但在处理网络请求时，调用select的过程时阻塞的，也就是这个过程会阻塞线程，如果并发量很高，就会成为瓶颈。</p>
<p><strong>如果能采用多线程，使得网路处理的请求并发进行，就可以大大提升性能。还可以充分利用CPU的多核优势</strong></p>
<p><strong>因此采用多个IO线程处理网络的请求，网络的请求和解析由其他线程完成，主线程进行内存的读写。</strong></p>
<p><strong>注意：只是网络的请求使用多IO线程，对于读写命令，redis仍然采用单线程来处理</strong></p>
<h1 id="redis怎么更新缓存"><a href="#redis怎么更新缓存" class="headerlink" title="redis怎么更新缓存"></a>redis怎么更新缓存</h1><p><strong>为什么要更新缓存？</strong></p>
<blockquote>
<p> 使用缓存后，数据要同时保存到数据库和缓存中，如果数据库中的数据发生变化，而缓存中的数据没有改变，会导致数据不一致的问题，因此要更新缓存。</p>
</blockquote>
<p><strong>常见的更新缓存的策略：</strong></p>
<p><strong>（1）内存淘汰：</strong></p>
<p>redis自带内存淘汰机制，当内存不足时自动淘汰部分数据。</p>
<p>redis提供了6种淘汰策略：</p>
<ul>
<li><strong>volatile-lru（least recently used）</strong>：从已经设置时间的数据集种挑选最近最少使用的数据进行淘汰。</li>
<li><strong>volatile-ttl：</strong>从已设置过期时间的数据集，中挑选将要过期的数据淘汰</li>
<li><strong>allkeys-lru：</strong>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key</li>
<li><strong>allkeys-random：</strong>从数据集中任意选择数据淘汰</li>
</ul>
<p>4.0版本后增加了以下两种：</p>
<ul>
<li><strong>volatile-lfu：</strong>从已设置过期时间的数据集，中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）：</strong>当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<p><strong>（2）超时剔除</strong></p>
<p>手动给缓存的数据添加ttl，到期后自动删除。</p>
<p><strong>（3）主动更新</strong></p>
<p>编写业务逻辑，更新数据库数据后同步更新缓存</p>
<p><strong>三种实现方法：</strong></p>
<ul>
<li>由缓存的调用者，在更新数据库时同时更新缓存</li>
<li>将缓存与数据库整合为一个服务，由服务来维护一致性，调用者无需关心缓存一致性。</li>
<li>crud在缓存中进行，由其他线程异步的将缓存数据持久化到数据库，</li>
</ul>
<p><strong>这三种方法最好的就是：第一个（由缓存的调用者，在更新数据库时同时更新缓存）</strong></p>
<p><strong>总结以上缓存更新策略的最佳方案方法：</strong></p>
<p>（1）低一致性需求：使用redis自带的内存淘汰机制（就是数据不会长久发生变化的情况下，例如：查询店铺类型缓存）</p>
<p>（2）高一致性需求：主动更新，并以超时剔除作为兜底方案（查询店铺详情）</p>
<ul>
<li><p>读操作：</p>
<ul>
<li>缓存命中则直接返回</li>
<li>缓存未命中，则查询数据库，并写入缓存，设定超时时间</li>
</ul>
</li>
<li><p>写操作：</p>
<ul>
<li>先写数据库，然后再删除缓存</li>
<li>确保数据库与缓存操作的原子性</li>
</ul>
</li>
</ul>
<h1 id="redis单线程模型"><a href="#redis单线程模型" class="headerlink" title="redis单线程模型"></a>redis单线程模型</h1><h1 id="redis的过期策略"><a href="#redis的过期策略" class="headerlink" title="redis的过期策略"></a>redis的过期策略</h1><p><strong>redis 过期策略是：定期删除+惰性删除。</strong></p>
<p>所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p>
<p>假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 redis 是每隔 100ms 随机抽取一些key 来检查和删除的。</p>
<p>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p>
<p>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p>
<p>答案是：走内存淘汰机制。</p>
<h1 id="如何保证缓存与数据库的双写一致性？"><a href="#如何保证缓存与数据库的双写一致性？" class="headerlink" title="如何保证缓存与数据库的双写一致性？"></a>如何保证缓存与数据库的双写一致性？</h1><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。- 更新的时候，先更新数据库，然后再删除缓存。</p>
<p><strong>为什么是删除缓存，而不是更新缓存？</strong></p>
<p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存</p>
<p><strong>明确了是删除缓存后，目前存在两种选择:</strong></p>
<ul>
<li>先更新数据库，再删除缓存</li>
<li>先删除缓存，再更新数据库</li>
</ul>
<p><strong>（1）先更新数据库，再删除缓存</strong></p>
<p><strong>问题：</strong>更新数据库成功，线程出现问题，缓存删除失败，缓存中的是旧数据，数据不一致，有两种解决方式；<strong>失败重试</strong>和<strong>异步更新</strong></p>
<p><strong>失败重试：</strong>把删除的key放入到消息队中，从消息队列中进行删除，（有个缺点，首先会对业务代码造成入侵，其次引入了消息队列，增加了系统的不确定性。）</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20224285758787.png" srcset="/img/loading.gif" lazyload alt="MySQL和Redis的数据一致性问题_一致性问题_04"></p>
<p><strong>异步更新：</strong>因为更新数据库时会往 <code>binlog </code>中写入日志，所以我们可以启动一个监听 binlog变化的服务（比如使用阿里的 canal开源组件），然后在客户端完成删除 key 的操作。如果删除失败的话，再发送到消息队列。</p>
<p><strong>（2）先删除缓存，再更新数据库</strong></p>
<p><strong>问题：</strong>如果先删除Redis缓存数据，然而还没有来得及写入MySQL，另一个线程就来读取。这个时候发现缓存为空，则去Mysql数据库中读取旧数据写入缓存，此时缓存中为脏数据。出现了数据不一致的问题。可以采用<strong>延时双删</strong>的策略解决。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20224285758788.png" srcset="/img/loading.gif" lazyload alt="MySQL和Redis的数据一致性问题_缓存_05"> </p>
<p><strong>延时双删</strong>：就是更新数据库之后，再删除一次缓存。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20224285758789.png" srcset="/img/loading.gif" lazyload alt="MySQL和Redis的数据一致性问题_缓存_06"></p>
<h1 id="redis-的并发竞争问题是什么？如何解决这个问题？了解redis-事务的-CAS-方案吗？"><a href="#redis-的并发竞争问题是什么？如何解决这个问题？了解redis-事务的-CAS-方案吗？" class="headerlink" title="redis 的并发竞争问题是什么？如何解决这个问题？了解redis 事务的 CAS 方案吗？"></a>redis 的并发竞争问题是什么？如何解决这个问题？了解redis 事务的 CAS 方案吗？</h1><h2 id="乐观锁介绍："><a href="#乐观锁介绍：" class="headerlink" title="乐观锁介绍："></a>乐观锁介绍：</h2><p>watch指令在redis事物中提供了CAS的行为。为了检测被watch的keys在是否有多个clients同时改变引起冲突，这些keys将会被监控。如果至少有一个被监控的key在执行exec命令前被修改，整个事物将会回滚，不执行任何动作，从而保证原子性操作，并且执行exec会得到null的回复。</p>
<h2 id="乐观锁工作机制："><a href="#乐观锁工作机制：" class="headerlink" title="乐观锁工作机制："></a>乐观锁工作机制：</h2><p>watch 命令会监视给定的每一个key，当exec时如果监视的任一个key自从调用watch后发生过变化，则整个事务会回滚，不执行任何动作。注意watch的key是对整个连接有效的，事务也一样。如果连接断开，监视和事务都会被自动清除。当然exec，discard，unwatch命令，及客户端连接关闭都会清除连接中的所有监视。还有，如果watch一个不稳定(有生命周期)的key并且此key自然过期，exec仍然会执行事务队列的指令。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/20210421172417360.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h2 id="redis的Watch机制是什么？"><a href="#redis的Watch机制是什么？" class="headerlink" title="redis的Watch机制是什么？"></a>redis的Watch机制是什么？</h2><blockquote>
<p>Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。注意使用multi 开始事务，exec 提交事务。</p>
</blockquote>
<h1 id="缓存雪崩-1"><a href="#缓存雪崩-1" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p><strong>缓存雪崩是指缓存同一时间大面积的失效（由于对缓存数据设置了相同的过期时间），所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</strong>（多个key）</p>
<p>解决方案：</p>
<ol>
<li><p><strong>构建多级缓存架构：</strong>nginx缓存+redis缓存+其他缓存（ehcache等）</p>
</li>
<li><p><strong>使用锁或队列：</strong>使用锁或在队列的方式来保证不会有大量的线程对数据库进行读写，从而避免失效时大量的并发请求到底层存储系统上，不适用高并发情况</p>
</li>
<li><p><strong>将缓存失效时间分散开：</strong>设置缓存过期时间时加上一个随机值，避免缓存在同一时间过期</p>
</li>
<li><p><strong>限流</strong></p>
</li>
</ol>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/e3d4e1cbd03b5326eb8b3f15a7fc73bc.png" srcset="/img/loading.gif" lazyload alt="redis-caching-avalanche-solution"></p>
<p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空值</p>
<p><strong>好处：</strong></p>
<ul>
<li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li>
<li>只要数据库不死，就是说，对用户来说，2&#x2F;5 的请求都是可以被处理的。</li>
<li>只要有 2&#x2F;5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来了。</li>
</ul>
<h1 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p><strong>缓存穿透是指查询一个根本不存在的数据，缓存层和持久层都不会命中，请求都会压到数据库，从而压垮数据库。</strong></p>
<p>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“<strong>绕过缓存</strong>”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/834fcb5588972d9be273189239bf0aba.png" srcset="/img/loading.gif" lazyload alt="redis-caching-penetration"></p>
<p>解决方式很简单：</p>
<p><strong>每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去</strong>，比如 <code>set -999 UNKNOWN</code> 。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p>
<p>这种方式虽然是简单，在某些场景（如数据量大的博客）下不优雅，还可能会缓存过多的空值，更加优雅的方式就是：<strong>使用 bitmap 布隆过滤（将数据库中所有的查询条件，放入布隆过滤器中，当一个查询请求过来时，先经过布隆过滤器进行查，如果判断请求查询值存在，则继续查；如果判断请求查询不存在，直接丢弃。）</strong></p>
<h1 id="缓存击穿-1"><a href="#缓存击穿-1" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p><strong>缓存击穿是指缓存中没有但数据库中有的某一个数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力（有点像一把尖刀瞬间击穿到数据库）</strong></p>
<p><strong>某一个数key失效，但同时有许多用户并发的访问数据库，导致数据库压力过大</strong></p>
<p><strong>不同场景下的解决方式可如下：</strong></p>
<ul>
<li>若缓存的数据是基本不会发生更新的，<strong>则可尝试将该热点数据设置为永不过期</strong>。</li>
<li>若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。</li>
<li><strong>预先设置热门数据</strong>：在redis高峰访问前，把一些热门数据提前存入redis中，加大这些热门数据key的时长实时调整 现场监控哪些数据是热门数据，实时调整key的过期时长</li>
</ul>
<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>是由一个很长的二进制(0或1)向量和一系列随机映射函数组成。</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它可以告诉你某种东西<strong>一定不存在</strong>或者<strong>可能存在</strong>。当布隆过滤器说，某种东西存在时，这种东西可能不存在；当布隆过滤器说，某种东西不存在时，那么这种东西一定不存在。</p>
<p>布隆过滤器 优点：A. 空间效率高，占用空间少 B. 查询时间短</p>
<p>　　　　　　　 缺点：A. 有一定的误判率 B. 元素不能删除</p>
<p><strong>原理</strong> </p>
<p>　当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点（使用多个哈希函数对<strong>元素key (bloom中不存value)</strong> 进行哈希，算出一个整数索引值，然后对位数组长度进行取模运算得到一个位置，每个无偏哈希函数都会得到一个不同的位置），把它们置为1。</p>
<p>　检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：① 如果这些点有任何一个为0（如下图的e），则被检元素一定不在；如果都是1（如下图的d），并不能完全说明这个元素就一定存在其中，有可能这些位置为1是因为其他元素的存在，这就是布隆过滤器会出现误判的原因。</p>
<p><img src="/2022/10/06/%E9%9D%A2%E8%AF%95%E9%A2%98-redis/1031302-20201106204833000-564795432.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>使用布隆过滤器的场景：</strong></p>
<p><strong>黑名单校验</strong></p>
<p>　识别垃圾邮件，只要发送者在黑名单中的，就识别为垃圾邮件。假设黑名单的数量是数以亿计的，存放起来就是非常耗费存储空间的，布隆过滤器则是一个较好的解决方案。把所有黑名单都放在布隆过滤器中，再收到邮件时，判断邮件地址是否在布隆过滤器中即可。</p>
<p><strong>原本有10亿个号码，现在又来了10万个号码，要快速准确判断这10万个号码是否在10亿个号码库中？</strong></p>
<p>解决办法一：将10亿个号码存入数据库中，进行数据库查询，准确性有了，但是速度会比较慢。</p>
<p>解决办法二：将10亿号码放入内存中，比如Redis缓存中，这里我们算一下占用内存大小：10亿*8字节&#x3D;8GB，通过内存查询，准确性和速度都有了，但是大约8gb的内存空间，挺浪费内存空间的。</p>
<p>那么对于类似这种，大数据量集合，如何准确快速的判断某个数据是否在大数据量集合中，并且不占用内存，<strong>布隆过滤器</strong>应运而生了。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%A0%A1%E6%8B%9B/" class="category-chain-item">校招</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%A0%A1%E6%8B%9B/%E5%BC%80%E5%8F%91/" class="category-chain-item">开发</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试题-redis</div>
      <div>http://example.com/2022/10/06/面试题-redis/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>zlw</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月6日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/10/PathVariable%E5%92%8CRequestParam%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB/" title="PathVariable和RequestParam注解的区别">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">PathVariable和RequestParam注解的区别</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/04/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%9B%86%E5%90%88/" title="面试题-集合">
                        <span class="hidden-mobile">面试题-集合</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"enable":true,"appId":"8pDDCsRJCVNm1OXHuh0xASVj-gzGzoHsz","appKey":"MnpSoeG5QTTJ4GagUMOq5t7J","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://8pddcsrj.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       #<a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> #<i class="iconfont icon-love"></i> #<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> #<a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> #<i class="iconfont icon-love"></i> #<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div>张露文的博客 | 记录成长过程</div> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>




  
<script src="/js/diy/timeDate.js"></script>
<script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/metowolf/Metingjs@1.2/dist/Meting.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/qipao.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/dianjichuzi.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
