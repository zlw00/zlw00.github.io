

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#447EA5">
  <meta name="author" content="zlw">
  <meta name="keywords" content="">
  
    <meta name="description" content="MySQL 存储引擎架构了解吗？MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。  所以我们用SQL语句对数据进行操作，好像是我们的SQL语句对数据进行了直接操作，但是呢，本质上是通过存储引擎">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql高级">
<meta property="og:url" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/index.html">
<meta property="og:site_name" content="zlw">
<meta property="og:description" content="MySQL 存储引擎架构了解吗？MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。  所以我们用SQL语句对数据进行操作，好像是我们的SQL语句对数据进行了直接操作，但是呢，本质上是通过存储引擎">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/13526879-3037b144ed09eb88.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908124314451.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210220122011873.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210220122426319.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2021022012244740.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210220122538388.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908124511218.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908124619358.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230416182424886.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221005221522286.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309560640.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221006121109983.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221006121114693.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908115444190.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908120042584.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309560646.jpg">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309560647.jpg">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908120558009.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908120605893.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908121149094.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908123400865.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140105574.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140422974.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140549906.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140922771.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126141104785.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309561197.jpg">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309561198.jpg">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309561199.jpg">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126145423129.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20220803095611101.jpg">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20220803095612105.jpg">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908130942497.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908131726920.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908132425625.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/03.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620160153106.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620161433980.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620172422570.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620172534743.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620172630964.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620173251235.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2f768fa6e05f4d89ab95c3b27a2886d5.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20224285758787.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20224285758788.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20224285758789.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230412190611640.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230412190743985.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230412190723458.png">
<meta property="og:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230412190747912.png">
<meta property="article:published_time" content="2022-09-05T14:17:24.000Z">
<meta property="article:modified_time" content="2023-04-18T04:22:46.790Z">
<meta property="article:author" content="zlw">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/13526879-3037b144ed09eb88.png">
  
  
  
  <title>Mysql高级 - zlw</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/diy/shubiao.css">
<link rel="stylesheet" href="/css/mac.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"8pDDCsRJCVNm1OXHuh0xASVj-gzGzoHsz","app_key":"MnpSoeG5QTTJ4GagUMOq5t7J","server_url":"https://leancloud.cn","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>欢迎来到zlw的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/8.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Mysql高级"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-05 22:17" pubdate>
          2022年9月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          173 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Mysql高级</h1>
            
            <div class="markdown-body">
              
              <h1 id="MySQL-存储引擎架构了解吗？"><a href="#MySQL-存储引擎架构了解吗？" class="headerlink" title="MySQL 存储引擎架构了解吗？"></a>MySQL 存储引擎架构了解吗？</h1><p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p>
<p><strong>存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法</strong>。</p>
<ol>
<li>所以我们用SQL语句对数据进行操作，好像是我们的SQL语句对数据进行了直接操作，但是呢，本质上是通过存储引擎来真正对数据进行操作。</li>
<li>存储引擎把怎么对数据操作什么的都封装好了，SQL语句更像是一个接口！你不用管存储引擎内部到底是怎样实现的，你只要会用SQL语句就好了！</li>
</ol>
<h1 id="Mysql的执行流程"><a href="#Mysql的执行流程" class="headerlink" title="Mysql的执行流程"></a>Mysql的执行流程</h1><h2 id="Mysql基础架构分析"><a href="#Mysql基础架构分析" class="headerlink" title="Mysql基础架构分析"></a>Mysql基础架构分析</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/13526879-3037b144ed09eb88.png" alt="img"></p>
<p><strong>Server层：</strong>所有跨存储引擎的功能都在这层实现，比如存储过程，触发器，函数等，还有一个通用的binlog模块。</p>
<p><strong>存储引擎：</strong>支持多个引擎（InnoDB、MyISAM、Memory）。其中InnoDB引擎有自由的redolog模块。</p>
<p><strong>下面解释Server层里面的组件：</strong></p>
<ul>
<li><p><strong>连接器：</strong>主要和身份认证和权限相关，主要负责登录数据库，用户身份验证，权限等操作。如果用户名和密码通过，连接器会到权限表中查询该用户的权限（一直到断开，权限都是相同的）。</p>
</li>
<li><p><strong>查询缓存：</strong>在Mysql8.0之后就取消了这个组件，因为很少去用，它主要就是查询数据的时候，以 Key-Value 的形式缓存在内存中，会先在查询缓存中查询，如果查到则直接返回，否则执行后序的操作，并且也会存储到查询缓存中。</p>
<ul>
<li><strong>MySQL 查询不建议使用缓存，</strong>因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</li>
</ul>
</li>
<li><p><strong>分析器：</strong>分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<ul>
<li>词法分析：提取关键字，提出查询的表，提出字段名，提出查询条件等。</li>
<li>语法分析：主要是判断输入的SQL是否正确</li>
</ul>
</li>
<li><p><strong>优化器：</strong>选择最优的执行方案去执行（比如有多个条件的时候，先执行哪个条件）</p>
</li>
<li><p><strong>执行器：</strong>选择执行方案后，开始执行，校验用户有没有权限，如果没有则返回错误，如果有则调用引擎接口，返回执行结果。</p>
</li>
</ul>
<h2 id="查询语句分析"><a href="#查询语句分析" class="headerlink" title="查询语句分析"></a>查询语句分析</h2><p><strong>分析下面这条查询语句：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from tb_student  A where A.age=&#x27;18&#x27; and A.name=&#x27; 张三 &#x27;;<br></code></pre></td></tr></table></figure>

<p><strong>权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</strong></p>
<p>（1）先检查语句是否有权限，Mysql8.0之前先查询缓存，有直接返回，没有接着执行。</p>
<p>（2）通过分析器进行语法分析，提取上面的select，查询表名为tb_student，需要查询所有的列，查询条件是什么，然后判断是否有语法错误，如果没有则下一步</p>
<p>（3）接下来就是优化器，可能有以下两种方案，优化器选择一个效率最高的方案进行执行，</p>
<blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。<br>b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。<br></code></pre></td></tr></table></figure>
</blockquote>
<p>（4）权限校验，如果没有权限则返回错误，如果有权限，则调用引擎接口，返回引擎结果。</p>
<h2 id="更新语句分析"><a href="#更新语句分析" class="headerlink" title="更新语句分析"></a>更新语句分析</h2><p><strong>分析下面这条更新语句：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update tb_student A set A.age=&#x27;19&#x27; where A.name=&#x27; 张三 &#x27;;<br></code></pre></td></tr></table></figure>

<p>在更新的时候要引入日志模块，Mysql自带的日志模块是bin log（归档日志），InnoDB引擎还引入了一个自带的日志模块 redo log（重做日志）</p>
<p><strong>分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</strong></p>
<p>（1）通过分析器进行语法分析，更新操作，操作哪张表，条件是什么，检查有没有语法错误。</p>
<p>（2）权限校验，如果没有权限则返回错误信息，如果有权限则调用引擎接口执行。</p>
<p>（3）调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</p>
<p>（4）执行器收到通过后记录bin log，然后调用引擎接口，提交redo log为提交状态。</p>
<p>（5）更新完成</p>
<h2 id="为什么同时用redo-log和bin-log"><a href="#为什么同时用redo-log和bin-log" class="headerlink" title="为什么同时用redo log和bin log"></a>为什么同时用redo log和bin log</h2><p><strong>redo log</strong>是InnoDB特有的，它有一个特殊的功能：<strong>如果数据库发生异常重启，之前提交的记录都不会丢失。</strong></p>
<p>并不是说只用一个<code>bin log</code>日志不行，而是<strong>使用<code>redo log</code>来支持事务。</strong></p>
<p><strong>那如果说用两个日志，但不用这么复杂可不可以，没有<code>prepare</code>状态和提交状态？</strong></p>
<ul>
<li>**先写 <code>redo log</code> 直接提交，然后写 <code>binlog</code>**，假设写完 <code>redo log</code> 后，机器挂了，<code>binlog</code> 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li>**先写 <code>binlog</code>，然后写 <code>redo log</code>**，假设写完了 <code>binlog</code>，机器异常重启了，由于没有 <code>redo log</code>，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<blockquote>
<p> <strong>如果采用 <code>redo log</code> 两阶段提交的方式就不一样了，写完 <code>binlog</code> 后，然后再提交 <code>redo log</code> 就会防止出现上述的问题，从而保证了数据的一致性。</strong></p>
</blockquote>
<p><strong>假设 <code>redo log</code> 处于预提交状态，<code>binlog</code> 也已经写完了，这个时候发生了异常重启会怎么样呢？</strong>下面为Mysql的处理机制：</p>
<ul>
<li>判断 <code>redo log</code> 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 <code>redo log</code> 只是预提交但不是 <code>commit</code> 状态，这个时候就会去判断 <code>binlog</code> 是否完整，如果完整就提交 <code>redo log</code>, 不完整就回滚事务。</li>
</ul>
<p>这样就保证了数据的一致性。</p>
<h1 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h1><p><strong>1.是否支持行级锁</strong>：InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</p>
<p><strong>2.是否支持事务</strong>：MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</p>
<p><strong>3.是否支持外键</strong>：MyISAM 不支持外键，而 InnoDB 支持</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong>：MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持</p>
<p><strong>5.是否支持 MVCC</strong>：MyISAM 不支持 MVCC，而 InnoDB 支持</p>
<p><strong>6.索引实现不一样。</strong></p>
<h1 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h1><ul>
<li><p><strong>第一范式</strong></p>
<p>第一范式的目标是确保每列的原子性:<strong>如果每列都是不可再分的最小数据单元</strong>（也称为最小的原子单元），则满足第一范式（1NF）  </p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908124314451.png" alt="image-20220908124314451"></p>
</li>
<li><p><strong>第二范式</strong></p>
<p>满足第一范式，表中非主键列不存在对主键的部分依赖  （<strong>也就是第二范式要求每个表只描述一件事情</strong>  ）</p>
<p><strong>什么叫“部分依赖”：</strong></p>
<p>如果确定一个表中的某个数据组合（A，B），则就可以确定该表中的其他另一个数据（C），则我们说：C依赖于（A，B）（此时A，B通常就是做出主键）。</p>
<p>但：如果某个数据D，它只依赖于数据A，或者说，A一确定，则D也可以确定，此时我们就称为“数据D部分依赖于数据A——可见部分依赖是指某个非主键字段，依赖于联合主键字段的其中部分字段。</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210220122011873.png" alt="img"></p>
<p>学生和课程作为联合主键，第二范式的要求非主键字段必须完全依赖主键，所以上表中，学分是依赖课程的，成绩和依赖学生的。要进行修改：</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210220122426319.png" alt="img"></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2021022012244740.png" alt="img"></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210220122538388.png" alt="img"></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908124511218.png" alt="image-20220908124511218"></p>
</li>
<li><p><strong>第三范式</strong></p>
<p>满足第一和第二范式，<strong>不存在对非主键列的传递依赖</strong>  ，非主键的属性对主键都是直接依赖，而不是间接依赖</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908124619358.png" alt="image-20220908124619358"></p>
</li>
</ul>
<h1 id="什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h1><p><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</p>
<p><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</p>
<p><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</p>
<p><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</p>
<p><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</p>
<p><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</p>
<p><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</p>
<h1 id="什么是-ER-图？"><a href="#什么是-ER-图？" class="headerlink" title="什么是 ER 图？"></a>什么是 ER 图？</h1><p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。</p>
<p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。</p>
<p>ER 图由下面 3 个要素组成：</p>
<ul>
<li><strong>实体</strong> ：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>
<li><strong>属性</strong> ：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。</li>
<li><strong>联系</strong> ：即实体与实体之间的关系，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>
</ul>
<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230416182424886.png" alt="image-20230416182424886"></p>
<h1 id="drop、delete-与-truncate-区别"><a href="#drop、delete-与-truncate-区别" class="headerlink" title="drop、delete 与 truncate 区别"></a>drop、delete 与 truncate 区别</h1><ul>
<li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。-DDL</li>
<li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。-DDL</li>
<li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。-DML</li>
</ul>
<p><code>truncate</code> 和不带 where&#96;&#96;子句的 <code>delete</code>、以及 <code>drop</code> 都会删除表内的数据，但是 **<code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构(定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行 <code>drop</code> 之后对应的表不复存在。</p>
<h1 id="DML-语句和-DDL-语句区别："><a href="#DML-语句和-DDL-语句区别：" class="headerlink" title="DML 语句和 DDL 语句区别："></a><strong>DML 语句和 DDL 语句区别：</strong></h1><ul>
<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li>
<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>
</ul>
<h1 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步?"></a>数据库设计通常分为哪几步?</h1><p><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</p>
<p><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</p>
<p><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</p>
<p><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</p>
<p><strong>数据库实施</strong> : 包括编程、测试和试运行</p>
<p><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/257835.htm">https://www.jb51.net/article/257835.htm</a></p>
<h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是对数据库表中的一列或多列的值进行排序的一种数据结构，使用索引可以快速访问数据表中的特定信息。</p>
<p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p>
<p><strong>优点</strong> ：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221005221522286.png" alt="image-20221005221522286"></p>
<p>但是hash算法存在hash冲突问题,也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。</p>
<p><strong>为什么MySQL 没有使用hash表这个数据结构呢？</strong></p>
<p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>
<h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a><strong>B+树索引</strong></h3><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309560640.png" alt="img"></p>
<ul>
<li>所有的数据都会出现在叶子节点。</li>
<li>叶子节点形成一个单向链表。</li>
<li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li>
</ul>
<h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>哈希索引一般用于精确等值查询但不支持排序，B+树用于精确等值查询之外的查询（范围查询and模糊查询等）。</p>
<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><p><strong>区别：</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p><strong>B树索引</strong></p>
<ul>
<li>B树中的内部节点和叶子节点均存放键和值，而B+树的内部节点只有键没有值，叶子节点存放所有的键和值。</li>
<li>B+树的叶子节点相连，方便顺序检索</li>
</ul>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221006121109983.png" alt="image-20221006121109983"></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221006121114693.png" alt="image-20221006121114693"></p>
<h2 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908115444190.png" alt="image-20220908115444190"></p>
<h2 id="数据库为什么使用B-树而不是B树"><a href="#数据库为什么使用B-树而不是B树" class="headerlink" title="数据库为什么使用B+树而不是B树"></a>数据库为什么使用B+树而不是B树</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908120042584.png" alt="image-20220908120042584"></p>
<h2 id="什么是聚簇索引，什么是非聚簇索引"><a href="#什么是聚簇索引，什么是非聚簇索引" class="headerlink" title="什么是聚簇索引，什么是非聚簇索引"></a>什么是聚簇索引，什么是非聚簇索引</h2><p><strong>聚簇索引：</strong>将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。</p>
<p><strong>非聚簇索引</strong>：将数据和索引分开存储，索引叶子节点存储的是指向数据行的地址。（叶子节点存储的是主键）</p>
<p><strong>（1）聚簇索引的优缺点</strong></p>
<p><strong>优点</strong> ：</p>
<ul>
<li><strong>查询速度非常快</strong> ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li>
<li><strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<p><strong>（2）非聚簇索引的优缺点</strong></p>
<p><strong>优点</strong> ：</p>
<p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p>
<p><strong>缺点</strong> ：</p>
<ul>
<li><strong>依赖于有序的数据</strong> ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> ：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309560646.jpg" alt="img"></p>
<p><strong>也就是说通过非聚簇索引找到主键，再通过聚簇索引找到主键对应的数据。</strong></p>
<p><strong>当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</strong></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309560647.jpg" alt="img"></p>
<ul>
<li>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li>
<li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</li>
<li>最终拿到这一行的数据，直接返回即可。</li>
</ul>
<blockquote>
<p> 回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p>
</blockquote>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908120558009.png" alt="image-20220908120558009"></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908120605893.png" alt="image-20220908120605893"></p>
<h2 id="索引的使用场景"><a href="#索引的使用场景" class="headerlink" title="索引的使用场景"></a>索引的使用场景</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908121149094.png" alt="image-20220908121149094"></p>
<h2 id="索引在什么情况下会失效"><a href="#索引在什么情况下会失效" class="headerlink" title="索引在什么情况下会失效"></a>索引在什么情况下会失效</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908123400865.png" alt="image-20220908123400865"></p>
<h2 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h2><ul>
<li>选择唯一性索引： 唯一性索引一般基于 Hash 算法实现， 可以快速、唯一地定位某条数据。</li>
<li>为经常需要排序、分组和联合操作的字段建立索引。</li>
<li>为常作为查询条件的字段建立索引。</li>
<li>限制索引的数量：索引越多，数据更新表越慢，因为在数据更新时会不断计算和添加索引。</li>
<li>尽量使用数据量少的索引：如果索引的值很长，则占用的磁盘变大，查询速度会受到影响。</li>
<li>尽量使用前缀来索引：如果索引字段的值过长， 则不但影响索引的大小，而且会降低索引的执行效率， 这时需要使用字段的部分前缀来作为索引。</li>
<li>删除不再使用或者很少使用的索引。</li>
<li>尽量选择区分度高的列作为索引：区分度表示字段值不重复的比例。</li>
<li>索引列不能参与计算：带函数的查询不建议参与索引。</li>
<li>尽量扩展现有索引： 联合索引的查询效率比多个独立索引高。</li>
</ul>
<h2 id="索引举例"><a href="#索引举例" class="headerlink" title="索引举例"></a>索引举例</h2><ul>
<li>创建表<code>test_table1</code>,并分别是在<code>id</code>字段上名称为<code>uniqidx</code>的唯一索引；在<code>name</code>和<code>address</code>字段上的组合索引；在<code>description</code>字段上长度为30的普通索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table test_table1    -&gt; (<br><br>    -&gt; id int not null primary key auto_increment,<br><br>    -&gt; name char(100) not null,<br><br>    -&gt; address char(100) not null,<br><br>    -&gt; description char(100) not null,<br><br>    -&gt; unique index uniqidx(id),<br><br>    -&gt; index MultiColidx(name(20),address(30) ),<br><br>    -&gt; index Comidx(description(30));<br></code></pre></td></tr></table></figure>

<ul>
<li>创建表test_table2，存储引擎为MyISAM</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table test_table2    -&gt; (<br><br>    -&gt; id int not null primary key auto_increment,<br><br>    -&gt; firstname char(100) not null,<br><br>    -&gt; middlename char(100) not null,<br><br>    -&gt; lastname char(100) not null,<br><br>    -&gt; birth date not null,<br><br>    -&gt; title char(100) null<br><br>    -&gt; )ENGINE=MyISAM;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用alter table 语句在表test_table2的birth字段上建立名称为ComDateIdx的普通索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table test_table2 add index ComDateidx(birth);<br></code></pre></td></tr></table></figure>

<ul>
<li>使用alter table语句在表test_table2的id字段上添加名称为Uniqidx2的唯一索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table test_table2 add unique index Uniqidx(id);<br></code></pre></td></tr></table></figure>

<ul>
<li>使用create index 在firstname和middlename两个字段上建立名称为 MultiColidx2的组合索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create index MultiColidx2 on test_table2(firstname,middlename);<br></code></pre></td></tr></table></figure>

<ul>
<li>使用create index在title字段上建立名称为FTidx的全文索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create fulltext index ftidx on test_table2(title);<br></code></pre></td></tr></table></figure>

<ul>
<li>使用alter table语句删除表test_table1中名称为Uniqidx的唯一索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table test_table1 drop index uniqidx;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用drop index语句删除表test_table2中名称为MultiColidx2的组合索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop index MultiColidx2 on test_table2;<br></code></pre></td></tr></table></figure>

<h2 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h2><p><strong>对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。</strong></p>
<p><strong>注意： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</strong></p>
<p>下面以一个表的例子进行展示，查询表中的索引，看是否有联合索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show index from tb_user<br></code></pre></td></tr></table></figure>

<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140105574.png" alt="image-20221126140105574"></p>
<p><strong>（1）符合最左原则，成功！红框中的是联合索引，最左边的列是profession，因此下面的查询都是有效的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27;;<br>explain select * from tb_user where profession = &#x27;软件工程&#x27; and age = 31;<br>explain select * from tb_user where profession = &#x27;软件工程&#x27;;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140422974.png" alt="image-20221126140422974"></p>
<p><strong>（2）不符合最左原则，失败！如果profession列没有用到的时候，则索引失效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_user where age = 31 and status = &#x27;0&#x27;;<br>explain select * from tb_user where status = &#x27;0&#x27;;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140549906.png" alt="image-20221126140549906"></p>
<p><strong>（3）跨列查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_user where profession = &#x27;软件工程&#x27; and status = &#x27;0&#x27;;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126140922771.png" alt="image-20221126140922771"></p>
<p><strong>根据索引使用的长度，索引的部分生效，只用到了profession列的部分</strong></p>
<p><strong>思考：如果顺序不同的话是否可以执行索引，答案是：可以！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">explain select * from tb_user <span class="hljs-type">where</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-type">and</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-type">and</span> <span class="hljs-variable">profession</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;软件工程&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126141104785.png" alt="image-20221126141104785"></p>
<p><strong>出现 &gt; 或 &lt; 时，&gt;或&lt;的列失效，其他的不是失效</strong></p>
<p><strong>mysql8的时候，如果条件语句中有or，并且两边都有索引，则走索引，否则失效。而mysql5无论两边是否有索引，出现or就会失效</strong></p>
<p><strong>对于is null 和 is not null，按照情况说是否走索引，会判断走索引块还是查询表块</strong></p>
<h2 id="Using-where-和-Using-index"><a href="#Using-where-和-Using-index" class="headerlink" title="Using where 和 Using index"></a>Using where 和 Using index</h2><p><strong>Using where和USing index：</strong>查找使用到了索引，需要的数据都能在索引列中找到，不需要回表查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id, profession from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27; ;<br></code></pre></td></tr></table></figure>

<p><strong>Using index</strong>：使用覆盖索引的时候就会生效。</p>
<p><strong>using index condition：</strong>查找使用了索引，不需要回表查询，因为要过滤的字段在索引中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select id,profession,age, status, name from tb_user where profession = &#x27;软件工程&#x27; and age = 31 and status = &#x27;0&#x27; ;<br></code></pre></td></tr></table></figure>

<p><strong>Using Where</strong>：在查找使用索引的情况下，需要回表去查询所需的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">explain select * from tb_user where age = 31 and name=&#x27;zw&#x27;; #删除了name的索引<br></code></pre></td></tr></table></figure>

<p>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p>
<p>执行SQL : <code>select * from tb_user where id = 2;</code></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309561197.jpg" alt="img"></p>
<p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p>
<p>执行SQL：<code>selet id,name from tb_user where name = &#39;Arm&#39;;</code></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309561198.jpg" alt="img"></p>
<p>执行SQL：<code>selet id,name,gender from tb_user where name = &#39;Arm&#39;;</code></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2022080309561199.jpg" alt="img"></p>
<p><strong>思考题：</strong> 一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对以下SQL语句进行优化, 该如何进行才是最优方案:</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span><span class="hljs-symbol">` `</span>id,username,<span class="hljs-symbol">``</span><span class="hljs-keyword">password</span><span class="hljs-symbol">` `</span><span class="hljs-keyword">from</span><span class="hljs-symbol">` `</span>tb_user <span class="hljs-symbol">``</span><span class="hljs-keyword">where</span><span class="hljs-symbol">` `</span>username =<span class="hljs-symbol">``</span><span class="hljs-string">&#x27;zhangsan&#x27;</span><span class="hljs-symbol">``</span>;<br></code></pre></td></tr></table></figure>

<p>答案: 针对于 username, password建立联合索引, sql为:<br><code>create index idx_user_name_pass on tb_user(username,password);</code><br>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。</p>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>当字段类型为字符串（varchar，text，longtext等）时，<strong>有时候需要索引很长的字符串，这会让索引变得很大</strong>，查询时，浪费大量的磁盘IO， 影响查询效率。<strong>此时可以只将字符串的一部分前缀，建立索引</strong>，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>语法：<code>create index idx_xxxx on table_name(column(n)) ;</code></p>
<p>实例：</p>
<p><code>create index idx_email_5 on tb_user(email(5));</code></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20221126145423129.png" alt="image-20221126145423129"></p>
<p><strong>查询流程：</strong></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20220803095611101.jpg" alt="img"></p>
<h2 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h2><ul>
<li><p>单列索引：即一个索引只包含单个列。</p>
</li>
<li><p>联合索引：即一个索引包含了多个列。</p>
<p><strong>如果查询条件存在两个单列索引的话，只能用到一个索引并进行回表查询，</strong></p>
<p><strong>但创建联合索引后，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。</strong></p>
</li>
</ul>
<p><strong>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</strong></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20220803095612105.jpg" alt="img"></p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p> 覆盖索引是指 查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。说白了就是避免回表查询</p>
<h1 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a>事务篇</h1><h2 id="什么是数据库事务"><a href="#什么是数据库事务" class="headerlink" title="什么是数据库事务"></a>什么是数据库事务</h2><p>数据库事务执行一系列基本操作，这些基本操作组成一个逻辑工作单元一起向数据库提交，要么都执行，要么都不执行。事务是一个不可分割的工作逻辑单元。  </p>
<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><ul>
<li><strong>原子性</strong>：包含事务的操作要么全部执行成功，要么全部失败执行回滚</li>
<li><strong>一致性</strong>：事务在执行前后状态是一致的</li>
<li><strong>隔离性</strong>：并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；  </li>
<li><strong>持久性</strong>：⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</li>
</ul>
<h2 id="数据库并发一致性问题"><a href="#数据库并发一致性问题" class="headerlink" title="数据库并发一致性问题"></a>数据库并发一致性问题</h2><p>当多个事务并发执行时，会出现以下问题：</p>
<ul>
<li><strong>脏读</strong>：事务A更新了数据，但没有提交，事务B读取了事务A更新的数据，然后事务A进行回滚，则数据B读到的数据为脏读数据。</li>
<li><strong>不可重复读取</strong>：事务A对数据进行多次读取，事务B在事务A的多次读取中，更新了数据并提交，导致事务A多次读取到数据的数据不一致。</li>
<li><strong>幻读</strong>：事务A读取了数据库中的数据后，事务B向事务A中插入了几行数据，事务A再次读取数据时发现多了几条数据，和之间读取的数据不一致。</li>
<li><strong>丢失修改</strong>：事务A和事务B对同一个数据进行修改，事务A 先修改随后事务B再修改覆盖了事务A的修改。</li>
</ul>
<h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><p><strong>数据库的隔离级别可以解决数据库的脏读、幻读、不可重复读的问题</strong></p>
<ul>
<li><strong>未提交读</strong>：一个事务在提交之前，它的修改对其他事务也是可见的。  </li>
<li><strong>提交读</strong>：一个事务提交之后，才可能被其他事务看到。</li>
<li><strong>可重复读</strong>：同一事务中多次读取到的数据是一致的</li>
<li><strong>串行化</strong>：加锁实现，事务串行执行</li>
</ul>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908130942497.png" alt="image-20220908130942497"></p>
<h2 id="Mysql的默认隔离级别：可重复读是怎么实现的"><a href="#Mysql的默认隔离级别：可重复读是怎么实现的" class="headerlink" title="Mysql的默认隔离级别：可重复读是怎么实现的"></a>Mysql的默认隔离级别：可重复读是怎么实现的</h2><p>InnoDB是通过维护两个隐藏列来实现mvcc，隐藏列记录了数据行<strong>创建版本号</strong>和<strong>删除版本号</strong></p>
<p><strong>mvcc在可重复读级别下的具体实现：</strong></p>
<ul>
<li><p>查询：需要满足两个条件，</p>
<ul>
<li>创建版本号小于等于当前事务的版本号，这样可以保证查询到的数据是事务开始之前就已经存在的，或者由该事务创建和修改的。</li>
<li>删除版本号要大于等于当前事务的版本号，可以保证在该事务之前是存在的。</li>
</ul>
</li>
<li><p>插入：插入的每条数据将创建版本号与该事务的版本号一致。</p>
</li>
<li><p>删除：删除每条数据，要将删除版本号与该事务版本号一致。</p>
</li>
<li><p>修改：将创建版本号修改为事务版本号，将删除版本号修改为事务版本号。</p>
</li>
</ul>
<h1 id="数据的锁"><a href="#数据的锁" class="headerlink" title="数据的锁"></a>数据的锁</h1><h2 id="什么是数据库的锁"><a href="#什么是数据库的锁" class="headerlink" title="什么是数据库的锁"></a>什么是数据库的锁</h2><p>有并发事务时，保证事务的访问顺序机制是锁机制</p>
<h2 id="数据库锁的类型"><a href="#数据库锁的类型" class="headerlink" title="数据库锁的类型"></a>数据库锁的类型</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908131726920.png" alt="image-20220908131726920"></p>
<h2 id="数据库的乐观锁和悲观锁"><a href="#数据库的乐观锁和悲观锁" class="headerlink" title="数据库的乐观锁和悲观锁"></a>数据库的乐观锁和悲观锁</h2><p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20220908132425625.png" alt="image-20220908132425625"></p>
<h2 id="MySql锁"><a href="#MySql锁" class="headerlink" title="MySql锁"></a>MySql锁</h2><h3 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h3><p><strong>MyISAM 仅仅支持表级锁</strong>(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。</p>
<p><strong>InnoDB 不光支持表级锁</strong>(table-level locking)，<strong>还支持行级锁(row-level locking)，默认为行级锁。</strong>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高.</p>
<p><strong>表级锁和行级锁对比</strong> ：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，<strong>是针对非索引字段加的锁，对当前操作的整张表加锁,其锁定粒度最大</strong>，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，<strong>是针对索引字段加的锁，只针对当前操作的行记录进行加锁</strong>。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h3 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h3><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p>
<ul>
<li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong> ：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li>
</ul>
<p><strong>手动加锁:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 共享锁<br>SELECT ... LOCK IN SHARE MODE;<br># 排他锁<br>SELECT ... FOR UPDATE;<br></code></pre></td></tr></table></figure>

<h3 id="意向共享锁和意向排他锁"><a href="#意向共享锁和意向排他锁" class="headerlink" title="意向共享锁和意向排他锁"></a>意向共享锁和意向排他锁</h3><ul>
<li><strong>意向共享锁（IS）：</strong>当需要对数据加行级读锁时，会像整个表加意向读锁。	</li>
<li><strong>意向排他锁（IX）：</strong>当需要对数据加行级写锁时，会像整个表加意向写锁。</li>
</ul>
<p><strong>为什么要加入意向锁：</strong>为了告诉你当前表中已经有了共享锁&#x2F;排他锁，就没有必要加表锁了，起到一个标识的作用，提高表锁的效率。</p>
<p>如果需要对表加锁的时候，可以快速遍历表是否有行锁，避免用遍历的方式检查是否上行锁。</p>
<ul>
<li>如果意向锁是行锁，则需要遍历每一行数据去确认；</li>
<li>如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。</li>
</ul>
<h1 id="MySQL的三大日志"><a href="#MySQL的三大日志" class="headerlink" title="MySQL的三大日志"></a>MySQL的三大日志</h1><p>mysql比较重要的三大日志为:<strong>二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</strong></p>
<h2 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a><code>redo log</code>（重做日志）</h2><p>是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>
<p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>
<p>记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>
<h2 id="bin-log-归档日志"><a href="#bin-log-归档日志" class="headerlink" title="bin log(归档日志)"></a><code>bin log</code>(归档日志)</h2><p> <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p>
<h1 id="数据库执行过慢怎么办"><a href="#数据库执行过慢怎么办" class="headerlink" title="数据库执行过慢怎么办"></a>数据库执行过慢怎么办</h1><ul>
<li><p>SQL及<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96&spm=1001.2101.3001.7020">索引优化</a></p>
<p><strong>（1）开启慢查询，查找哪条执行语句过慢。</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">log-slow-queries</span>=/data/mysqldata/slow-query.log<br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<ul>
<li>log-slow-queries参数为慢查询日志存放的位置，一般这个目录要有mysql的运行账号的可写权限，一般都将这个目录设置为mysql的数据存放目录。</li>
<li>long_query_time&#x3D;5中的5表示查询超过五秒才记录。</li>
</ul>
<p><strong>（2）通过Explain分析，优化语句。</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020">数据库表结构</a>优化</p>
<ul>
<li><p>尽量将表字段定义为NOT NULL约束，这时由于在MySQL中含有空值的列很难进行查询优化，NULL值会使索引以及索引的统计信息变得很复杂。</p>
</li>
<li><p>对于只包含特定类型的字段，可以使用enum、set 等数据类型。</p>
</li>
<li><p>数值型字段的比较比字符串的比较效率高得多，字段类型尽量使用最小、最简单的数据类型。例如IP地址可以使用int类型。</p>
</li>
<li><p>尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED。但对整数类型指定宽度，比如INT(11)，没有任何用，因为指定的类型标识范围已经确定。</p>
</li>
<li><p>VARCHAR的长度只分配真正需要的空间。</p>
</li>
<li><p>尽量使用TIMESTAMP而非DATETIME，但TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。</p>
</li>
<li><p>单表不要有太多字段，建议在20以内。</p>
</li>
<li><p>合理的加入冗余字段可以提高查询速度。</p>
</li>
</ul>
</li>
<li><p>硬件优化</p>
</li>
</ul>
<p><strong>四. 总结</strong></p>
<p>（1）首先数据库优化的主要思路，是先找到当前数据库的瓶颈所在，然后再针对具体问题具体优化；</p>
<p>（2）由于优化成本限制，所以要考虑SQL语句及索引优化，通过<strong>慢查询日志发现项目中是哪条SQL语句导致了查询变慢</strong>；</p>
<p>（3）然后<strong>通过Explain执行计划分析这条要优化的SQL语句到底是哪里有问题</strong>，再进行优化；</p>
<p>（4）对于<strong>有索引的字段</strong>，要在查询条件中遵循最左匹配原则，<strong>确保能够命中索引</strong>；</p>
<p>（5）然后<strong>再考虑优化表结构</strong>，对于单表500万条以上数据的大表，可以进行水平分表，比如使用数据库中间件Mycat进行分表；</p>
<p>（6）最后<strong>再考虑是否是服务器硬件导致的瓶颈</strong>，可以通过Zabbix监控软件进行分析，优化服务器硬件配置。</p>
<h1 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/orecle_littleboy/article/details/88534160">https://blog.csdn.net/orecle_littleboy/article/details/88534160</a></p>
<p>Sql中in包含的值不应该过多</p>
<p>SELECT语句务必指明字段名称</p>
<p>当只需要一条数据的时候，使用limit 1</p>
<p>如果限制条件中其他字段没有索引，尽量少用or</p>
<p>尽量用union all代替union</p>
<p>避免在where子句中对字段进行null值判断</p>
<p>不建议使用%前缀模糊查询</p>
<p>避免在where子句中对字段进行表达式操作</p>
<p>禁止使用 order by rand() 进行随机排序</p>
<p>对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<h1 id="Mysql怎么保证事务的持久性"><a href="#Mysql怎么保证事务的持久性" class="headerlink" title="Mysql怎么保证事务的持久性"></a>Mysql怎么保证事务的持久性</h1><p>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。</p>
<p>为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，<strong>Buffer Pool中修改的数据会定期刷新到磁盘中</strong>（这一过程称为刷脏）。</p>
<p>Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：<strong>如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</strong></p>
<p>于是，<strong>redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</strong></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/03.png" alt="img"></p>
<h1 id="Mysql怎么保证事务的原子性"><a href="#Mysql怎么保证事务的原子性" class="headerlink" title="Mysql怎么保证事务的原子性"></a>Mysql怎么保证事务的原子性</h1><p><strong>是利用<code>Innodb</code>的<code>undo log</code>。</strong><br><code>undo log</code>名为回滚日志，是实现原子性的关键，<strong>当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。</strong></p>
<p><strong>是当事务回滚时能够撤销所有已经成功执行的sql语句</strong></p>
<p>InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
<p>例如:<br>(1)当你<code>delete</code>一条数据的时候，就需要记录这条数据的信息，回滚的时候，<code>insert</code>这条旧数据<br>(2)当你<code>update</code>一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行<code>update</code>操作<br>(3)当年<code>insert</code>一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行<code>delete</code>操<br><strong><code>undo log</code>记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</strong></p>
<h1 id="Mysql怎么保证事务的隔离性"><a href="#Mysql怎么保证事务的隔离性" class="headerlink" title="Mysql怎么保证事务的隔离性"></a>Mysql怎么保证事务的隔离性</h1><p><strong>有两种方法MVCC和LBCC保证事务的隔离性，至于到底使用的哪种，就看程序员的sql语句是怎样写的。</strong></p>
<h2 id="MVCC-Multi-Version-Concurrency-Control-多版本并发控制"><a href="#MVCC-Multi-Version-Concurrency-Control-多版本并发控制" class="headerlink" title="MVCC (Multi-Version Concurrency Control) 多版本并发控制."></a>MVCC (Multi-Version Concurrency Control) 多版本并发控制.</h2><blockquote>
<p> 建立一个快照，同一个事务无论查多少次都是一个结果。某一个事务第一次查询确认了快照之后，无论后面的事务插入数据，删除数据还是更新数据，都不会影响该事务的查询结果，只能看到最初建立快照时饿情况。</p>
</blockquote>
<p><strong>(1)MVCC的底层支持，InnoDB为每个表提供了三个隐藏的字段以及事务id和删除版本号的使用</strong></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620160153106.png" alt="在这里插入图片描述"></p>
<p><strong>(2)MVCC的底层是read view（一致性视图）。</strong></p>
<p>不同的表类型生成的时机不同：</p>
<ul>
<li><p><strong>RR repeat read 可重复读:</strong> <code>read view</code> 是在事务第一次查询的时候建立（之后 <code>read view</code> 就不会变了）；</p>
</li>
<li><p><strong>RC read commit 已提交读:</strong> <code>read view</code> 是在事务每次查询的时候建立（每次查询都重新生成一个 <code>read view</code> ）；</p>
</li>
</ul>
<p><strong>(3)readview一致性视图的结构</strong></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620161433980.png" alt="在这里插入图片描述"></p>
<p><strong>readview一致性视图的应用</strong></p>
<ul>
<li><p>对于某个事务<code>trx_id</code>，如果这个<code>trx_id=creator_trx_id</code>，表示这个<code>readview</code>就是这个<code>trx_id</code>创建的，自然可以访问这个<code>trx_id</code></p>
</li>
<li><p>对于某个事务<code>trx_id</code>，如果这个<code>trx_id&lt;min_trx_id</code>，表示这个<code>trx_id</code> 比最小的未提交的事务id还小，表示这个事务<code>id</code>是已提交的，自然可以访问这个<code>trx_id</code></p>
</li>
<li><p>对于某个事务<code>trx_id</code>，如果这个<code>trx_id&gt;max_trx_id</code>，表示这个<code>trx_id</code> 比最大的未提交的事务<code>id</code>还大，表示这个事务<code>id</code>是未提交的，自然不可以访问这个<code>trx_id</code></p>
</li>
<li><p>对于某个事务<code>trx_id</code>，如果这个<code>max_trx_id &gt; trx_id&gt;min_trx_id</code>，表示这个 <code>trx_id</code> 比在这个范围内，如果在 <code>m_ids</code> ,表示未提交，不可访问，如果不在 <code>m_ids</code> ，表示已提交，可以访问</p>
</li>
</ul>
<p><strong>（4）MVCC的局限</strong></p>
<p>只作用于RC和RR隔离级别。</p>
<p><strong>repeat read特点：</strong>只保存第一次查询的视图；<br><strong>repeat read优点：</strong>解决了幻读问题（第一次生成视图之后，不受 update&#x2F;insert&#x2F;delete 影响）；<br><strong>repeat read缺点：</strong>不能查询到最新的实时数据。</p>
<p><strong>MVCC的局限：</strong>对于RR repeat read 可重复读，只能保存第一次查询的视图，不能查询到最新的实时数据，要想实时查询到最新的实时数据，只能 LBCC ，就是加锁。</p>
<h2 id="LBCC-Lock-Base-Concurrency-Control-基于锁的并发控制"><a href="#LBCC-Lock-Base-Concurrency-Control-基于锁的并发控制" class="headerlink" title="LBCC(Lock-Base Concurrency Control)基于锁的并发控制."></a>LBCC(Lock-Base Concurrency Control)基于锁的并发控制.</h2><blockquote>
<p>使用加锁的方式来保证并发下数据的一致性，实现了事务隔离</p>
</blockquote>
<p><strong>（1）表锁到行锁</strong></p>
<p>表锁和行锁的区别：表锁粒度大，行锁效率高，行锁冲突概率小，行锁并发性能强，所以行锁优于表锁。</p>
<p><strong>（2）四种基本锁</strong></p>
<p>共享锁，独占锁，意向共享锁，意向独占锁。</p>
<blockquote>
<p>对于程序员给表加上行锁（读共享锁 写独占锁），<br>如果存在索引，锁住的索引，如果where条件中有索引列，仅锁住where条件命中的这一行或多行数据；如果where条件中没有索引列 或者 没有根本就没有where子句，会锁住整个表（连插入都插入不进去了 解决幻读问题）。<br>如果不存在索引，锁住的隐藏的rowid，此时会锁住整个表（连插入都插入不进去了 解决幻读问题）。</p>
</blockquote>
<p><strong>（3）三种高级锁</strong></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620172422570.png" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>record记录锁</strong></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620172534743.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>间隙锁</strong></p>
<p>那么幻读能仅通过行锁解决么？答案是否定的，如上面示例，首先说明一下，select xx for update（当前读）是将所有条件涉及到的（符合where条件）行加上行锁。但是，就算我在select xx for update 事务开启时将所有的行都加上行锁。那么也锁不住Session C新增的行，<strong>因为在我给数据加锁的时刻，压根就还没有新增的那行，自然也不会给新增行加上锁。</strong></p>
<p><strong>所以要解决幻读，就必须得解决新增行的问题。</strong></p>
<p><strong>现在你应该明白了，产生幻读的原因是：行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</strong>顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 LOL，初始化插入了 7 个记录，这就产生了 8 个间隙。</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620172630964.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>临键锁</strong></p>
<p>在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。<strong>MySQL将行锁 + 间隙锁组合统称为 next-key lock</strong>，通过 next-key lock 解决了幻读问题。</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20210620173251235.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><strong>（4）四种隔离级别的锁，哪种mvcc,哪种加锁</strong></p>
<blockquote>
<p>mvcc只有在RC RR中有，</p>
</blockquote>
<ul>
<li>在read uncommited(读未提交)啥都没有，没有锁，没有mvcc，</li>
<li>在rc（读已提交）里面，有mvcc，有锁，只有记录锁，没有间隙锁，所以无法解决幻读问题</li>
<li>在rr（可重复读）里面，有mvcc，有锁，有记录锁，有间隙锁，可以解决幻读问题</li>
<li>在serializable（串行化），只有锁，没有mvcc</li>
</ul>
<h1 id="Mysql中explain"><a href="#Mysql中explain" class="headerlink" title="Mysql中explain"></a>Mysql中explain</h1><p><strong>返回执行计划的信息</strong></p>
<blockquote>
<p>select语句前面加explain关键字，执行mysql就会返回执行计划的信息，而不是执行mysql。</p>
</blockquote>
<p><strong>exception中的列：</strong></p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/2f768fa6e05f4d89ab95c3b27a2886d5.png" alt="img"></p>
<p><strong>（1）id：</strong>id列的编号是select的序列号，有几个select就有几个id</p>
<p><strong>（2）select_type：</strong>对应行的查询是简单查询还是复杂查询。</p>
<blockquote>
<p> simple：不包含子查询和union的简单查询</p>
</blockquote>
<blockquote>
<p>primary：复杂查询中的最外层的查询</p>
<p>subquery：包含在select中的子查询（不在from中的子句中，可以是where后的子查询）</p>
<p>derived：包含在from中的子查询</p>
</blockquote>
<p><strong>（3）table：</strong>表示当前行访问的是哪张表，</p>
<p><strong>（4）partitions：</strong>查询将匹配记录的分区，如果是非分区表，则为null。</p>
<p><strong>（5）type：</strong>表示访问类型，就是mysql如何查找表中的行，最优到最差：<code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。</code></p>
<blockquote>
<p>system：主键索引或者唯一索引，表中只有一条元组匹配时。</p>
<p>const：主键索引或者唯一索引上的等值查询。</p>
<p>eq_ref：命中主键索引或唯一索引join查询，等值连接，前表的每一行，后表只有一行命中。</p>
<p>ref：使用了普通索引，没有使用主键索引和唯一索引，可能有多行命中。</p>
<p>range：索引上的范围扫描，相比index的全文索引扫描有范围限制，因此要优于index。</p>
<p>index：扫描全部索引</p>
<p>all：全表扫描</p>
</blockquote>
<p><strong>（6）possible_keys：</strong>显示查询中可能用到的索引，如果为null，表示没有用到相关索引。</p>
<p><strong>（7）key：</strong>实际查询用到的索引，。</p>
<p><strong>（8）key_len：</strong>具体使用了索引的哪些列，索引中使用的字节数</p>
<p><strong>（9）ref：</strong>索引中使用到的列或者常量</p>
<p><strong>（10）row：</strong>mysql查询中估计要读取的行数</p>
<p><strong>（11）extra：</strong>额外的信息</p>
<h1 id="如何保证缓存与数据库的双写一致性？"><a href="#如何保证缓存与数据库的双写一致性？" class="headerlink" title="如何保证缓存与数据库的双写一致性？"></a>如何保证缓存与数据库的双写一致性？</h1><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。- 更新的时候，先更新数据库，然后再删除缓存。</p>
<p><strong>为什么是删除缓存，而不是更新缓存？</strong></p>
<p>举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存</p>
<p><strong>明确了是删除缓存后，目前存在两种选择:</strong></p>
<ul>
<li>先更新数据库，再删除缓存</li>
<li>先删除缓存，再更新数据库</li>
</ul>
<p><strong>（1）先更新数据库，再删除缓存</strong></p>
<p><strong>问题：</strong>更新数据库成功，线程出现问题，缓存删除失败，缓存中的是旧数据，数据不一致，有两种解决方式；<strong>失败重试</strong>和<strong>异步更新</strong></p>
<p><strong>失败重试：</strong>把删除的key放入到消息队中，从消息队列中进行删除，（有个缺点，首先会对业务代码造成入侵，其次引入了消息队列，增加了系统的不确定性。）</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20224285758787.png" alt="MySQL和Redis的数据一致性问题_一致性问题_04"></p>
<p><strong>异步更新：</strong>因为更新数据库时会往 <code>binlog </code>中写入日志，所以我们可以启动一个监听 binlog变化的服务（比如使用阿里的 canal开源组件），然后在客户端完成删除 key 的操作。如果删除失败的话，再发送到消息队列。</p>
<p><strong>（2）先删除缓存，再更新数据库</strong></p>
<p><strong>问题：</strong>如果先删除Redis缓存数据，然而还没有来得及写入MySQL，另一个线程就来读取。这个时候发现缓存为空，则去Mysql数据库中读取旧数据写入缓存，此时缓存中为脏数据。出现了数据不一致的问题。可以采用<strong>延时双删</strong>的策略解决。</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20224285758788.png" alt="MySQL和Redis的数据一致性问题_缓存_05"></p>
<p><strong>延时双删</strong>：就是更新数据库之后，再删除一次缓存。</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/20224285758789.png" alt="MySQL和Redis的数据一致性问题_缓存_06"></p>
<h1 id="数据库的连接"><a href="#数据库的连接" class="headerlink" title="数据库的连接"></a>数据库的连接</h1><p>又称多表查询，当查询的字段分别来自于不同表时，就会用到连接查询。</p>
<h2 id="连接的分类"><a href="#连接的分类" class="headerlink" title="连接的分类"></a><strong>连接的分类</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">内连接：inner<br>外连接：<br>	左外：left outer<br>	右外：right outer<br>	全外（用的较少）<br>交叉连接：cross（用的较少）相当于做了一个笛卡尔乘积<br></code></pre></td></tr></table></figure>

<p>内连接：</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230412190611640.png" alt="image-20230412190611640"></p>
<p>右外连接：</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230412190743985.png" alt="image-20230412190743985"></p>
<p>左外连接：</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230412190723458.png" alt="image-20230412190723458"></p>
<p>全连接：</p>
<p><img src="/2022/09/05/Mysql%E9%AB%98%E7%BA%A7/image-20230412190747912.png" alt="image-20230412190747912"></p>
<h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p><strong>基本语法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select column<br>from table 1<br>inner join table 2<br>on 连接条件<br></code></pre></td></tr></table></figure>

<p><strong>等值连接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"># <span class="hljs-number">1</span> 查询员工名、部门名<br># 其中员工名在employees表，部门名在departments表<br>SELECT last_name,department_name<br>FROM departments d<br>JOIN  employees e<br>ON e.`department_id` = d.`department_id`;<br><br>#<span class="hljs-number">2.</span>查询名字中包含e的员工名和工种名（添加筛选）<br>SELECT last_name,job_title<br>FROM employees e<br>INNER JOIN jobs j<br>ON e.`job_id`=  j.`job_id`<br>WHERE e.`last_name` LIKE <span class="hljs-string">&#x27;%e%&#x27;</span>;<br><br>#<span class="hljs-number">3.</span> 查询部门个数&gt;<span class="hljs-number">3</span>的城市名和部门个数，（添加分组+筛选）<br>SELECT city, COUNT(*) 部门个数 <br>FROM departments d<br>INNER	JOIN locations l<br>ON d.`location_id` = l.`location_id`<br>GROUP BY city<br>HAVING 部门个数 &gt; <span class="hljs-number">3</span>;<br><br>#<span class="hljs-number">4.</span>查询员工名、部门名、工种名，并按部门名降序（添加三表连接）<br>SELECT last_name,department_name,job_title<br>FROM employees e<br>INNER JOIN departments d ON e.`department_id`=d.`department_id`<br>INNER JOIN jobs j ON e.`job_id` = j.`job_id`<br>ORDER BY department_name DESC;<br></code></pre></td></tr></table></figure>

<p><strong>非等值连接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">#<span class="hljs-number">1.</span> 查询工资级别的个数&gt;<span class="hljs-number">20</span>的个数，并且按工资级别降序<br> SELECT <span class="hljs-title function_">COUNT</span><span class="hljs-params">(*)</span>,grade_level<br>FROM employees e<br> JOIN job_grades g<br> ON e.`salary` BETWEEN g.`lowest_sal` AND g.`highest_sal`<br> GROUP BY grade_level<br> HAVING <span class="hljs-title function_">COUNT</span><span class="hljs-params">(*)</span>&gt;<span class="hljs-number">20</span><br> ORDER BY grade_level DESC;<br></code></pre></td></tr></table></figure>

<p><strong>自连接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">#<span class="hljs-number">1.</span>查询员工的名字、上级的名字<br> SELECT e.last_name,m.last_name<br> FROM employees e<br> JOIN employees m<br> ON e.`manager_id`= m.`employee_id`;<br><br>#<span class="hljs-number">2.</span>查询姓名中包含字符k的员工的名字、上级的名字 <br> SELECT e.last_name,m.last_name<br> FROM employees e<br> JOIN employees m<br> ON e.`manager_id`= m.`employee_id`<br> WHERE e.`last_name` LIKE <span class="hljs-string">&#x27;%k%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>用于查询一个表中有，另一个表没有的记录</p>
<p><strong>左外连接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"># 查询没有员工的部门的信息<br> SELECT d.*,e.employee_id<br> FROM departments d<br> LEFT OUTER JOIN employees e<br> ON d.`department_id` = e.`department_id`<br> WHERE e.`employee_id` IS NULL;<br></code></pre></td></tr></table></figure>

<p><strong>右外连接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT d.*,e.employee_id<br> FROM employees e<br> RIGHT OUTER JOIN departments d<br> ON d.`department_id` = e.`department_id`<br> WHERE e.`employee_id` IS NULL;<br></code></pre></td></tr></table></figure>

<p>上述两种方法得到结果一致，部门信息在departments表中，departments表没有employee_id，这时我们想要的结果是部门信息＋员工id，因此，如果使用左外连接，则departments为主表，右外连接则employees为主表。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Mysql/" class="category-chain-item">Mysql</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Mysql高级</div>
      <div>http://example.com/2022/09/05/Mysql高级/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>zlw</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月5日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/08/%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" title="从前序和中序构造二叉树">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">从前序和中序构造二叉树</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/30/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/" title="单词搜索">
                        <span class="hidden-mobile">单词搜索</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments">
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"enable":true,"appId":"8pDDCsRJCVNm1OXHuh0xASVj-gzGzoHsz","appKey":"MnpSoeG5QTTJ4GagUMOq5t7J","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://8pddcsrj.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       #<a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> #<i class="iconfont icon-love"></i> #<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> #<a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> #<i class="iconfont icon-love"></i> #<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div>张露文的博客 | 记录成长过程</div> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>




  
<script src="/js/diy/timeDate.js"></script>
<script src="//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/metowolf/Metingjs@1.2/dist/Meting.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
