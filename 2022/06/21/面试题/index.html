

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#447EA5">
  <meta name="author" content="zlw">
  <meta name="keywords" content="">
  
    <meta name="description" content="常见字符集ASII美国人发明的数据集，用于输入到电脑中的代码，包括了英文和符号等。 标准的ASCII使用一个字节存储一个字符，首位是0，总共可以表示128个字符，对美国人来说完全够用。 但是对于中国人来说，还不够，则中国人也开发了一个自己的字符集，就是GBK GBK汉字占两个字节，英文占一个字节。  GBK规定个汉字的第一个字节的第一位必须为1  因为还有其他国家使用，所以如果其他国家也开发一个自">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题-java基础">
<meta property="og:url" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="zlw">
<meta property="og:description" content="常见字符集ASII美国人发明的数据集，用于输入到电脑中的代码，包括了英文和符号等。 标准的ASCII使用一个字节存储一个字符，首位是0，总共可以表示128个字符，对美国人来说完全够用。 但是对于中国人来说，还不够，则中国人也开发了一个自己的字符集，就是GBK GBK汉字占两个字节，英文占一个字节。  GBK规定个汉字的第一个字节的第一位必须为1  因为还有其他国家使用，所以如果其他国家也开发一个自">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125202941749.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125203408796.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125203905637.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204141153.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204341276.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204623833.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204642815.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204648335.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125205109693.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125205136562.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/7ae2aead01a946c183a01073915ee9bd.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/ce87cd35649245a1846f8340bee417c6.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003103940342.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221129200824038.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003135131615.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003215836718.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220126506.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220214067.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220255525.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230416162132765.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230416163041672.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230416164133893.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220332681.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220716231720069.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/other-bukfsdjavassmtjstd-be0964a8-856a-45c9-ab75-ce9505c2e237.png">
<meta property="og:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221128161846036.png">
<meta property="article:published_time" content="2022-06-21T15:37:40.000Z">
<meta property="article:modified_time" content="2023-04-18T05:01:07.724Z">
<meta property="article:author" content="zlw">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125202941749.png">
  
  
  
  <title>面试题-java基础 - zlw</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"8pDDCsRJCVNm1OXHuh0xASVj-gzGzoHsz","app_key":"MnpSoeG5QTTJ4GagUMOq5t7J","server_url":"https://leancloud.cn","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>欢迎来到张露文的Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试题-java基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-21 23:37" pubdate>
          2022年6月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          178 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试题-java基础</h1>
            
            <div class="markdown-body">
              
              <h1 id="常见字符集"><a href="#常见字符集" class="headerlink" title="常见字符集"></a>常见字符集</h1><h2 id="ASII"><a href="#ASII" class="headerlink" title="ASII"></a>ASII</h2><p>美国人发明的数据集，用于输入到电脑中的代码，包括了英文和符号等。</p>
<p>标准的ASCII使用一个字节存储一个字符，首位是0，总共可以表示128个字符，对美国人来说完全够用。</p>
<p>但是对于中国人来说，还不够，则中国人也开发了一个自己的字符集，就是GBK</p>
<h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><p>汉字占两个字节，英文占一个字节。</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125202941749.png" srcset="/img/loading.gif" lazyload alt="image-20221125202941749"></p>
<p><strong>GBK规定个汉字的第一个字节的第一位必须为1</strong></p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125203408796.png" srcset="/img/loading.gif" lazyload alt="image-20221125203408796"></p>
<p>因为还有其他国家使用，所以如果其他国家也开发一个自己国家语言的字符集，就会出现好多字符集，当各个国家进行通信的时候就会出现乱码问题。因此国家开发组织就定义了一个标准编码：Unicode</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125203905637.png" srcset="/img/loading.gif" lazyload alt="image-20221125203905637"></p>
<p><strong>UTF-8</strong></p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204141153.png" srcset="/img/loading.gif" lazyload alt="image-20221125204141153"></p>
<p>编码的时候可以根据汉字占3个字节进行编码，。但是解吗的时候怎么知道是3个字节代表的汉字呢，则下面utf-8提出了编码方式：</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204341276.png" srcset="/img/loading.gif" lazyload alt="image-20221125204341276"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204623833.png" srcset="/img/loading.gif" lazyload alt="image-20221125204623833"></p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204642815.png" srcset="/img/loading.gif" lazyload alt="image-20221125204642815"></p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125204648335.png" srcset="/img/loading.gif" lazyload alt="image-20221125204648335"></p>
<h2 id="Java代码对字符进行编码和解码"><a href="#Java代码对字符进行编码和解码" class="headerlink" title="Java代码对字符进行编码和解码"></a>Java代码对字符进行编码和解码</h2><p>String提供的方法：</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125205109693.png" srcset="/img/loading.gif" lazyload alt="image-20221125205109693"></p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221125205136562.png" srcset="/img/loading.gif" lazyload alt="image-20221125205136562"></p>
<h1 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h1><ul>
<li>面向过程是把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题</li>
<li>面向对象开发的程序一般更易维护，易复用，易扩展。</li>
</ul>
<h1 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h1><p>​		<strong>在程序中定义的引用所指向的具体类型和通过该引用调用的方法在编译时期不能确定，而是在程序运行时期才能确定。由于是程序运行时才确定具体的类，这样不用修改源代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</strong></p>
<p>多态：同一个方法，通过不同的对象调用产生不同的结果</p>
<p>多态的三个必要条件：</p>
<ul>
<li><p>有继承</p>
</li>
<li><p>有重写</p>
</li>
<li><p>父类引用指向子类对象</p>
</li>
</ul>
<p><strong>继承链中对象调用方法的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</strong></p>
<p><strong>注意！！！！：</strong></p>
<p>​		<strong>指向子类的父类引用，由于向上转型了，它只能访问子类中重写父类的方法和属性，而对于父类中不存在的方法，该引用不能调用。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）</strong></p>
<p><strong>经典的例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(D obj)</span> &#123;  <br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and D&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(A obj)</span> &#123;  <br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and A&quot;</span>);  <br>    &#125;   <br>  <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(B obj)</span>&#123;  <br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and B&quot;</span>);  <br>    &#125;  <br>      <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">show</span><span class="hljs-params">(A obj)</span>&#123;  <br>        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and A&quot;</span>);  <br>    &#125;   <br>&#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&#123;  &#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&#123;  &#125;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();  <br>        <span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();  <br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();  <br>        <span class="hljs-type">C</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();  <br>        <span class="hljs-type">D</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">D</span>();  <br>          <br>        System.out.println(<span class="hljs-string">&quot;1--&quot;</span> + a1.show(b));  <span class="hljs-comment">//A and A</span><br>        System.out.println(<span class="hljs-string">&quot;2--&quot;</span> + a1.show(c));  <span class="hljs-comment">//A and A</span><br>        System.out.println(<span class="hljs-string">&quot;3--&quot;</span> + a1.show(d));  <span class="hljs-comment">//A and D</span><br>        System.out.println(<span class="hljs-string">&quot;4--&quot;</span> + a2.show(b));  <span class="hljs-comment">//4--B and A .首先a2是A引用，B实例，调用show（B b）方法，此方法在父类A中没有定义，所以B中方法show(B b)不会调用（多态必须父类中已定义该方法），再按优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)，即先查this对象的父类，没有重头再查参数的父类。查找super.show((super)O)时，B中没有，再向上，找到A中show(A a),因此执行。</span><br> <br>        System.out.println(<span class="hljs-string">&quot;5--&quot;</span> + a2.show(c));  <span class="hljs-comment">//同上</span><br>        System.out.println(<span class="hljs-string">&quot;6--&quot;</span> + a2.show(d));  <span class="hljs-comment">//A and D .查找B中没有show(D d)方法，再查A中，有，执行。</span><br>        System.out.println(<span class="hljs-string">&quot;7--&quot;</span> + b.show(b));   <span class="hljs-comment">//B and B</span><br>        System.out.println(<span class="hljs-string">&quot;8--&quot;</span> + b.show(c));  <span class="hljs-comment">//B and B .</span><br>        System.out.println(<span class="hljs-string">&quot;9--&quot;</span> + b.show(d));  <span class="hljs-comment">//A and D      </span><br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>

<h1 id="抽象类和接口的区别？"><a href="#抽象类和接口的区别？" class="headerlink" title="抽象类和接口的区别？"></a>抽象类和接口的区别？</h1><p><strong>抽象类：</strong></p>
<ul>
<li>抽象类里面的全部方法，必须让子类全部实现，如果没有全部实现，则该子类也为抽象类，同样的接口也一样，如果子类没有全部实现接口中的方法，则该子类也为抽象类。</li>
<li>抽象类中可以有普通方法，也可以有抽象方法，而抽象方法的个数可以是0个，也可以是多个。</li>
<li>子类继承父类，必须重写全部的抽象方法，除非这个类也变成了抽象类。</li>
</ul>
<p><strong>接口：</strong></p>
<ul>
<li>接口中所有方法都必须是抽象的</li>
<li>接口中方法定义默认为public abstract类型，成员变量默认为public static final 类型。（为什么是final：如果不是final，意味着实现该接口的子类都可以去修改这个变量，这会影响其他继承该接口的类，。为什么是static：如果是非静态的变量，则实现了该接口的实现类都会有这个变量，由于接口是可以多继承的，如果另一个接口也有这样一个变量，则不知道用哪个。因此定为static，只能放在静态存储区）</li>
</ul>
<p><strong>主要区别：</strong></p>
<ul>
<li>抽象类可以有构造方法，接口中不能有构造方法。（接口中所有的方法都是抽象的，不存在抽象的构造方法）</li>
<li>抽象类中可以有普通方法，接口中所有方法都必须是抽象的。</li>
<li>抽象类中抽象方法的访问类型可以是public，protected，但接口中抽象方法的访问类型只能是public，并且默认为public <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=abstract&spm=1001.2101.3001.7020">abstract</a></li>
<li>抽象类中可以有静态方法（不能有静态抽象方法），接口中不能有静态方法。（因为接口不能被实例化，也就是不能分配内存空间，而static方法在实例化之前就已经分配了内存空间，所以矛盾了。）<strong>静态和抽象不能共存在一个方法上，静态不需要实例就可以运行，而抽象方法没有方法体，运行没有意义，所以不能共存。</strong></li>
</ul>
<h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><p><strong>（1）重载：</strong>发生在同一个类中，方法名相同，参数类型不同、个数不同、顺序不同，返回值和访问修饰符可以不同。<strong>就是同一个方法能够根据输入数据的不同，做出不同的处理</strong></p>
<p><strong>（2）重写：</strong>发生在运行期，子类对父类的允许访问的方法实现过程进行重写。（抛出异常的范围小于等于父类，访问修饰符范围大于等于父类），其中构造方法不能被重写，⽗类⽅法访问修饰符为 private&#x2F;final&#x2F;static 则⼦类就不能重写该⽅法，但是被 static 修饰的⽅法能够被再次声明  </p>
<h1 id="JAVA中的泛型"><a href="#JAVA中的泛型" class="headerlink" title="JAVA中的泛型"></a>JAVA中的泛型</h1><p>使用泛型参数，编译器可以对泛型参数进行检测，并通过泛型参数可以指定传入的对象类型，是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。<br>也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，而这种参数类型可以用在类、方法和接口中，</p>
<p><strong>举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//测试一下泛型的经典案例</span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">arrayList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        arrayList.add(<span class="hljs-string">&quot;helloWorld&quot;</span>);<br>        arrayList.add(<span class="hljs-string">&quot;taiziyenezha&quot;</span>);<br>        arrayList.add(<span class="hljs-number">88</span>);<span class="hljs-comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) &#123;<br>            <span class="hljs-comment">//需求：打印每个字符串的长度,就要把对象转成String类型</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) arrayList.get(i);<br>            System.out.println(str.length());<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>由于<code>ArrayList</code>可以存放任意类型的元素。例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，导致取出时强制转换为String类型后，引发了<code>ClassCastException</code>，因此程序崩溃了。</p>
<p>这显然不是我们所期望的，如果程序有潜在的错误，我们<code>更期望在编译时被告知错误</code>，而不是在运行时报异常。在jdk1.5后，泛型应运而生。让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>arrayList.add(<span class="hljs-string">&quot;helloWorld&quot;</span>);<br>arrayList.add(<span class="hljs-string">&quot;taiziyenezha&quot;</span>);<br>arrayList.add(<span class="hljs-number">88</span>);<span class="hljs-comment">// 在编译阶段，编译器就会报错</span><br></code></pre></td></tr></table></figure>

<p><strong>这样可以避免了我们类型强转时出现异常。</strong></p>
<p><strong>使用泛型的好处</strong></p>
<ul>
<li>避免了类型强转的麻烦。</li>
<li>它提供了编译期的<strong>类型安全</strong>，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException。</li>
</ul>
<h1 id="JAVA的跨平台"><a href="#JAVA的跨平台" class="headerlink" title="JAVA的跨平台"></a>JAVA的跨平台</h1><p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/216499.htm">https://www.jb51.net/article/216499.htm</a></p>
<p>跨平台，是指java语言编写的程序，<strong>一次编译</strong>后，可以在<strong>多个系统平台上运行</strong>。</p>
<p>实现跨平台：Java程序是<strong>通过java虚拟机</strong>在系统平台上运行的，只要该系统可以安装相应的java<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>，该系统就可以运行java程序。（注意不是能在所有的平台上运行，关键是该平台是否能安装相应的虚拟机）</p>
<p>Java跨平台原理：<br>由源文件(.java)—&gt;字节码文件(.class)(二进制文件)—–&gt; 解释—-&gt;Unix,Win,Linux等机器。</p>
<p><strong>简单的来说</strong>，<br>就是当你需要执行某个Java程序时，会牵扯到JVM。具体就是我们编写的Java源码，编译后会生成一种.class文件，称为字节码文件。而Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码，然后运行。</p>
<p><strong>如下图</strong></p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/7ae2aead01a946c183a01073915ee9bd.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>由此可知，JAVA的编译和执行与JVM有关，与平台无关。</p>
<p>而JVM分为很多个系统的版本，如Windows，Linux，macOS等等，都有其对应的JVM。</p>
<p><strong>因此，</strong><br>如果我们想要编译和执行编写好的Java程序，只需要在不同平台上安装其对应的JVM就行了。</p>
<p><strong>如下图</strong><br><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/ce87cd35649245a1846f8340bee417c6.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h1 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h1><ul>
<li>包装类不赋值就是null，而基本类型有默认值，不是null。</li>
<li>包装类可用作泛型，而基本类不可以。</li>
<li>基本数据类型，如果是局部成员变量存放在Java虚拟机栈中，如果是成员变量存放在堆中，包装类对象属于对象类型存放在堆中。</li>
<li>相比于对象类型，基本数据类型占用的空间非常小</li>
</ul>
<h1 id="包装类的缓存机制"><a href="#包装类的缓存机制" class="headerlink" title="包装类的缓存机制"></a>包装类的缓存机制</h1><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer i1 <span class="hljs-operator">=</span> <span class="hljs-number">33</span><span class="hljs-comment">;</span><br>Integer i2 <span class="hljs-operator">=</span> <span class="hljs-number">33</span><span class="hljs-comment">;</span><br>System.out.println(i1 <span class="hljs-operator">=</span><span class="hljs-operator">=</span> i2)<span class="hljs-comment">;// 输出 true</span><br><br>Float i11 <span class="hljs-operator">=</span> <span class="hljs-number">333</span>f<span class="hljs-comment">;</span><br>Float i22 <span class="hljs-operator">=</span> <span class="hljs-number">333</span>f<span class="hljs-comment">;</span><br>System.out.println(i11 <span class="hljs-operator">=</span><span class="hljs-operator">=</span> i22)<span class="hljs-comment">;// 输出 false</span><br><br>Double i3 <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br>Double i4 <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span><span class="hljs-comment">;</span><br>System.out.println(i3 <span class="hljs-operator">=</span><span class="hljs-operator">=</span> i4)<span class="hljs-comment">;// 输出 false</span><br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer i1 <span class="hljs-operator">=</span> <span class="hljs-number">40</span><span class="hljs-comment">;</span><br>Integer i2 <span class="hljs-operator">=</span> new Integer(<span class="hljs-number">40</span>)<span class="hljs-comment">;</span><br>System.out.println(i1<span class="hljs-operator">=</span><span class="hljs-operator">=</span>i2)<span class="hljs-comment">;   //输出false</span><br></code></pre></td></tr></table></figure>

<p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>
<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003103940342.png" srcset="/img/loading.gif" lazyload alt="image-20221003103940342"></p>
<h1 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h1><p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<h1 id="为什么浮点数运算会有精度丢失的风险"><a href="#为什么浮点数运算会有精度丢失的风险" class="headerlink" title="为什么浮点数运算会有精度丢失的风险"></a>为什么浮点数运算会有精度丢失的风险</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">由于计算机保存浮点数时是使用二进制进行存储的，而对于一些小数，不能准确的使用二进制存储，<br>因为可能无法消灭小数部分，导致无限循环下去，而又因为超过了其范围，所以就会导致精度丢失。<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span><br><span class="hljs-comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span><br><span class="hljs-number">0.2</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.4</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">0.4</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.8</span> -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">0.8</span> * <span class="hljs-number">2</span> = <span class="hljs-number">1.6</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-number">0.6</span> * <span class="hljs-number">2</span> = <span class="hljs-number">1.2</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-number">0.2</span> * <span class="hljs-number">2</span> = <span class="hljs-number">0.4</span> -&gt; <span class="hljs-number">0</span>（发生循环）<br>...<br><br></code></pre></td></tr></table></figure>

<h1 id="解决浮点数运算精度丢失问题"><a href="#解决浮点数运算精度丢失问题" class="headerlink" title="解决浮点数运算精度丢失问题"></a>解决浮点数运算精度丢失问题</h1><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.9&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.8&quot;</span>);<br><br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> a.subtract(b);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> b.subtract(c);<br><br>System.out.println(x); <span class="hljs-comment">/* 0.1 */</span><br>System.out.println(y); <span class="hljs-comment">/* 0.1 */</span><br>System.out.println(Objects.equals(x, y)); <span class="hljs-comment">/* true */</span><br><br></code></pre></td></tr></table></figure>

<p><strong><code>BigDecimal</code>进行等值比较的时候，要使用compareTo()方法，这是因为 <code>equals()</code> 方法不仅仅会比较值的大小（value）还会比较精度（scale），而 <code>compareTo()</code> 方法比较的时候会忽略精度。</strong></p>
<blockquote>
<p>1.0 的 scale 是 1，1 的 scale 是 0，因此 <code>a.equals(b)</code> 的结果是 false。</p>
</blockquote>
<p><strong>加减乘除的方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.0&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;0.9&quot;</span>);<br>System.out.println(a.add(b));<span class="hljs-comment">// 1.9</span><br>System.out.println(a.subtract(b));<span class="hljs-comment">// 0.1</span><br>System.out.println(a.multiply(b));<span class="hljs-comment">// 0.90</span><br>System.out.println(a.divide(b));<span class="hljs-comment">// 无法除尽，抛出 ArithmeticException 异常</span><br>System.out.println(a.divide(b, <span class="hljs-number">2</span>, RoundingMode.HALF_UP));<span class="hljs-comment">// 1.11</span><br></code></pre></td></tr></table></figure>

<p><strong>保留几位小数：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;1.255433&quot;</span>);<br><span class="hljs-type">BigDecimal</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> m.setScale(<span class="hljs-number">3</span>,RoundingMode.HALF_DOWN);<br>System.out.println(n);<span class="hljs-comment">// 1.255</span><br></code></pre></td></tr></table></figure>



<h1 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h1><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Long.MAX_VALUE;<br>System.out.println(l + <span class="hljs-number">1</span>); <span class="hljs-comment">// -9223372036854775808</span><br>System.out.println(l + <span class="hljs-number">1</span> == Long.MIN_VALUE); <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure>

<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>
<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>
<h1 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><strong>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</strong></p>
<blockquote>
<p> （就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。）</p>
</blockquote>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>不同类型的对象，相互之间经常有一定数量的共同点。将这些共同点定义为一个类，不同类型去继承这个类，</p>
<p><strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</strong></p>
<p><strong>注意三点：</strong></p>
<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</strong></p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><ul>
<li><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，<strong>也就是说拷贝对象和原对象共用同一个内部对象。</strong>新旧对象还是共用一个内存块。</p>
<blockquote>
<p>若是想要彻底的深拷贝，就要保证该对象的所有引用对象的类型都要去实现<code>Cloneable</code>接口，实现<code>clone</code>方法。 </p>
</blockquote>
</li>
<li><p><strong>深拷贝</strong>：是新建一个一模一样的对象，该对象与原对象不共享内存，修改新对象也不会影响原对象。</p>
</li>
</ul>
<p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221129200824038.png" srcset="/img/loading.gif" lazyload alt="image-20221129200824038"></p>
<p>obj2是对obj1的浅拷贝，obj3是对obj1的深拷贝</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003135131615.png" srcset="/img/loading.gif" lazyload alt="image-20221003135131615"></p>
<p>阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/crystal_hhj/article/details/119740469">https://blog.csdn.net/crystal_hhj/article/details/119740469</a></p>
<h1 id="x3D-x3D-和equals-的区别"><a href="#x3D-x3D-和equals-的区别" class="headerlink" title="&#x3D;&#x3D;和equals()的区别"></a>&#x3D;&#x3D;和equals()的区别</h1><p>&#x3D;&#x3D;：对于基本数据类型比较的是值，对于引用类型比较的是两个的地址</p>
<p>equals()：如果没有重写，则于&#x3D;&#x3D;一样，如果重写了则比较的是内容。</p>
<h1 id="字符串中intern-方法有什么作用"><a href="#字符串中intern-方法有什么作用" class="headerlink" title="字符串中intern 方法有什么作用?"></a>字符串中intern 方法有什么作用?</h1><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”Java“</span><br><span class="hljs-comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br><span class="hljs-comment">// 会在堆中在单独创建一个字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s3.intern();<br><span class="hljs-comment">// s1 和 s2 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// s3 和 s4 指向的是堆中不同的对象</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// s1 和 s4 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s4); <span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure>

<h1 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h1><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串</p>
<p>🐛 修正 ： 我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><strong><code>String</code> 真正不可变有下面几点原因：</strong></p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h1 id="为什么要将String设置为不可变的"><a href="#为什么要将String设置为不可变的" class="headerlink" title="为什么要将String设置为不可变的"></a>为什么要将String设置为不可变的</h1><p>（1）字符串常量池需要String不可变，因为当创建一个String对象时，若此字符串已经存在常量池中，则不会创建一个新对象，而是引用已经存在的对象，如果允许改变的话，会影响另一个已经存在的对象。</p>
<p>（2）安全性，string被许多java类用来当作参数，若String可变，将会引起各种安全隐患。</p>
<p>（3）可以用作HashMap的key，因为通常建议把不可变的对象作为HashMap的key，以可缓存hashCode，对象一旦被创建hashCode的值也就不会改变，下次可以直接使用。</p>
<h1 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h1><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h1 id="Hash冲突的解决方法"><a href="#Hash冲突的解决方法" class="headerlink" title="Hash冲突的解决方法"></a>Hash冲突的解决方法</h1><p><strong>开放寻址法、链地址法（拉链法）、再哈希法、建立公共溢出区</strong>等方法。</p>
<p><strong>（1）开放寻址法：</strong></p>
<p>​		开放寻址法又叫做<strong>开放定址法</strong>、<strong>开地址法</strong>，从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。</p>
<p>​		开放定址法的<strong>缺点</strong>在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p>
<p><strong>（2）链地址法</strong></p>
<p>​		链地址法（Separate Chaining）的思路是将哈希值相同的元素构成一个同义词的单向链表，并将单向链表的头指针存放在哈希表的第 i 个单元中，查找、插入和删除主要在同义词链表中进行。链地址法适用于经常进行插入和删除的情况。</p>
<p><strong>（3）再哈希法</strong></p>
<p>​		就是同时构造多个不同的哈希函数，当使用其中一个h哈希函数出现冲突后，再使用下一个哈希函数进行计算。直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>
<p><strong>（4）建立公共溢出区域</strong></p>
<p>​		将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
<h1 id="JAVA-IO流"><a href="#JAVA-IO流" class="headerlink" title="JAVA IO流"></a>JAVA IO流</h1><p><strong>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。</strong>数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p><strong>字符流和字节流的使用场景：</strong></p>
<p>（1）字节流：主要用于处理图像、音频、视频、ppt等。它也可以处理文本文件</p>
<p>（2）字符流：主要用于处理纯文本的文件。不可以处理音频等文件</p>
<h1 id="Java-I-x2F-O模型详解"><a href="#Java-I-x2F-O模型详解" class="headerlink" title="Java I&#x2F;O模型详解"></a>Java I&#x2F;O模型详解</h1><p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003215836718.png" srcset="/img/loading.gif" lazyload alt="image-20221003215836718"></p>
<p>用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间</p>
<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>
<h1 id="java中三种常见的IO模型"><a href="#java中三种常见的IO模型" class="headerlink" title="java中三种常见的IO模型"></a>java中三种常见的IO模型</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/10225159.html#autoid-h2-5-0-0">https://www.cnblogs.com/crazymakercircle/p/10225159.html#autoid-h2-5-0-0</a></p>
<h2 id="BIO（同步阻塞模型）"><a href="#BIO（同步阻塞模型）" class="headerlink" title="BIO（同步阻塞模型）"></a>BIO（同步阻塞模型）</h2><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<p><strong>最简单的方法，告诉内核需要哪些数据，然后等待，直到有了数据之后，从内核区拷贝到用户区，也就是所谓的阻塞IO。</strong></p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220126506.png" srcset="/img/loading.gif" lazyload alt="image-20221003220126506"></p>
<p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p>
<h2 id="NIO（同步非阻塞模型）"><a href="#NIO（同步非阻塞模型）" class="headerlink" title="NIO（同步非阻塞模型）"></a>NIO（同步非阻塞模型）</h2><p>对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p><strong>告诉内核需要哪些数据，不等待，过一段时间去检查下，是否有数据，有则拷贝，没有则继续等待检查，这就是非阻塞IO。</strong></p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220214067.png" srcset="/img/loading.gif" lazyload alt="image-20221003220214067"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><blockquote>
<p>一般用在，想要设置一个高性能的网络服务器，这个服务器可以同时被多个客户端连接，并且能够处理这些客户端传上来的请求。</p>
</blockquote>
<p>这个时候，<strong>I&#x2F;O 多路复用模型</strong> 就上场了。</p>
<p><strong>同时监视多个IO端口，只要有数据就处理。这就是IO多路复用。</strong></p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220255525.png" srcset="/img/loading.gif" lazyload alt="image-20221003220255525"></p>
<p><strong>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</strong></p>
<p>使用场景：</p>
<blockquote>
<p>1.当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</p>
<p>2.当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</p>
<p>3.如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</p>
<p>4.如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</p>
<p>5.如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</p>
</blockquote>
<p><strong>实现方法有：select 、poll或者epoll</strong></p>
<h3 id="（1）select"><a href="#（1）select" class="headerlink" title="（1）select:"></a><strong>（1）select:</strong></h3><p>首先创建一个socket，可以接收多个客户端的连接，**每个连接就是一个文件描述符(fd)**。文件描述符集合fds[]中每一个元素其实是一个随机的数字，代表这个文件描述符的编号，max用来保存其中最大的一个数字。</p>
<p><strong>select执行步骤：</strong></p>
<p>将rset拷贝一份到内核中，由内核判断哪个fd中有数据，如果一个或多个有数据就将其标记一下（修改bitmap）然后返回，用户进程通过遍历文件描述符集合得到数据。（由于bitmap会被修改，所以rset每次都会被重置）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> maxfdp, fd_set *readset, fd_set *writeset, fd_set *excepset, const struct timeval *timeout)</span>;<br></code></pre></td></tr></table></figure>

<p>返回值：就绪描述符的数目，超时返回0，出错返回-1</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230416162132765.png" srcset="/img/loading.gif" lazyload alt="image-20230416162132765"></p>
<p><strong>缺点：</strong></p>
<ul>
<li>对待测试的描述符个数有限制，最大1024</li>
<li>fdset不可重复适用，每次都要重新创建fd_set</li>
<li>每次调用select，都会将readset、writeset、excepset从用户区拷贝到内核区，同样，返回时，又会将三个数据结构从内核区拷贝到用户区，大量的空间复制。</li>
<li>select返回时，并不知道是哪些fd，这是还要进行O（n）的循环判断，进行处理。</li>
</ul>
<p><strong>优点：</strong>用户态替我们监听fd</p>
<h3 id="（2）poll"><a href="#（2）poll" class="headerlink" title="（2）poll"></a><strong>（2）poll</strong></h3><p><strong>步骤：</strong></p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(struct pollfd *fds, unsigned <span class="hljs-type">int</span> nfds, <span class="hljs-type">int</span> timeout)</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230416163041672.png" srcset="/img/loading.gif" lazyload alt="image-20230416163041672"></p>
<p>poll是对select的改进。</p>
<p><strong>改进点</strong>：</p>
<ul>
<li>没有最大个数的限制</li>
<li>不用重新设置fd_set，因为换成了pollfd结构体，改变的是结构体中的revents，在poll返回后又将revents设置为0，因此可以重用。</li>
</ul>
<p><strong>select的其他缺点依然存在：</strong></p>
<ul>
<li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</li>
</ul>
<h3 id="（3）epoll"><a href="#（3）epoll" class="headerlink" title="（3）epoll"></a><strong>（3）epoll</strong></h3><p><strong>优点</strong>：不需要再遍历所有的socket号来获取每一个socket的状态，只需要管理活跃的连接。即监听在通过epoll_create()创建的文件中注册的socket号以及对应的事件。只有产生就绪事件，才会处理，所以操作都是有效的，为O(1).</p>
<p>epoll_create  创建一个白板 存放fd_events<br>epoll_ctl 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上<br>epoll_wait 通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230416164133893.png" srcset="/img/loading.gif" lazyload alt="image-20230416164133893"></p>
<p><strong>两种触发模式：</strong><br><strong>LT:水平触发</strong><br>            当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<p><strong>ET:边缘触发</strong><br>            和 LT 模式不同的是，通知之后进程必须立即处理事件。下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，</p>
<p>因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h2 id="AIO（异步模型）"><a href="#AIO（异步模型）" class="headerlink" title="AIO（异步模型）"></a>AIO（异步模型）</h2><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221003220332681.png" srcset="/img/loading.gif" lazyload alt="image-20221003220332681"></p>
<p>目前来说 AIO 的应用还不是很广泛。</p>
<h1 id="为什么Java中只有值传递"><a href="#为什么Java中只有值传递" class="headerlink" title="为什么Java中只有值传递"></a>为什么Java中只有值传递</h1><p><strong>先来介绍一下什么是值传递和引用传递：</strong></p>
<ul>
<li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p><strong>案例一</strong></p>
<p>传递基本类型参数时，是将实参的值拷贝给形参，所以形参值的改变，不会影响实参值的改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    swap(num1, num2);<br>    System.out.println(<span class="hljs-string">&quot;num1 = &quot;</span> + num1);<br>    System.out.println(<span class="hljs-string">&quot;num2 = &quot;</span> + num2);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> a;<br>    a = b;<br>    b = temp;<br>    System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + a);<br>    System.out.println(<span class="hljs-string">&quot;b = &quot;</span> + b);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">a = 20<br>b = 10<br>num1 = 10<br>num2 = 20<br></code></pre></td></tr></table></figure>

<p><strong>案例二</strong></p>
<p>传递引用类型参数1：当传递引用类型时，是将实参中引用类型在堆中的地址拷贝给形参，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>      System.out.println(arr[<span class="hljs-number">0</span>]);<br>      change(arr);<br>      System.out.println(arr[<span class="hljs-number">0</span>]);<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array)</span> &#123;<br>      <span class="hljs-comment">// 将数组的第一个元素变为0</span><br>      array[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1<br>0<br></code></pre></td></tr></table></figure>

<p>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！</p>
<p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p>
<p><strong>案例三</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">xiaoZhang</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小张&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">xiaoLi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小李&quot;</span>);<br>    swap(xiaoZhang, xiaoLi);<br>    System.out.println(<span class="hljs-string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());<br>    System.out.println(<span class="hljs-string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(Person person1, Person person2)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> person1;<br>    person1 = person2;<br>    person2 = temp;<br>    System.out.println(<span class="hljs-string">&quot;person1:&quot;</span> + person1.getName());<br>    System.out.println(<span class="hljs-string">&quot;person2:&quot;</span> + person2.getName());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">person1:小李<br>person2:小张<br>xiaoZhang:小张<br>xiaoLi:小李<br></code></pre></td></tr></table></figure>

<p><code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p>
<h1 id="Java反射中的方法"><a href="#Java反射中的方法" class="headerlink" title="Java反射中的方法"></a>Java反射中的方法</h1><h2 id="获取class示例的方法"><a href="#获取class示例的方法" class="headerlink" title="获取class示例的方法"></a>获取class示例的方法</h2><p><strong>1. 知道具体类的情况下可以使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass</span> <span class="hljs-operator">=</span> TargetObject.class;<br></code></pre></td></tr></table></figure>

<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p>
<p><strong>2. 通过 <code>Class.forName()</code>传入类的全路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>3. 通过对象实例<code>instance.getClass()</code>获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TargetObject</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetObject</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass2</span> <span class="hljs-operator">=</span> o.getClass();<br></code></pre></td></tr></table></figure>

<p><strong>4. 通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure>

<h2 id="反射中的方法"><a href="#反射中的方法" class="headerlink" title="反射中的方法"></a>反射中的方法</h2><p><strong>获取运行时类的方法结构</strong></p>
<ul>
<li><code>getMethods()</code>:获取当前运行时类及其所有父类中声明为public权限的方法</li>
<li><code>getDeclaredMethods()</code>:获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</li>
<li><code>getAnnotations()</code>：获取方法声明的注解</li>
<li><code>getModifiers()</code>：获取方法权限修饰符</li>
<li><code>getReturnType().getName()</code>：获取方法返回值类型</li>
<li><code>getName()</code>：获取方法名</li>
<li><code>public Class&lt;?&gt;[] getParameterTypes()</code>:取得全部的参数</li>
<li><code>public Class&lt;?&gt;[] getExceptionTypes()</code>:取得异常信息</li>
</ul>
<p><strong>获取当前运行时类的属性结构</strong></p>
<ul>
<li><code>getFields()</code>:获取当前运行时类及其父类中声明为public访问权限的属性</li>
<li><code>getDeclaredFields()</code>:获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</li>
<li><code>public int getModifiers()</code>: 以整数形式返回此Field的修饰符</li>
<li><code>public Class&lt;?&gt; getType()</code>: 得到Field的属性类型</li>
<li><code>public String getName()</code>: 返回Field的名称。</li>
</ul>
<p><strong>获取构造器结构</strong></p>
<ul>
<li>getConstructors():获取当前运行时类中声明为public的构造器</li>
<li>getDeclaredConstructors():获取当前运行时类中声明的所有的构造器</li>
</ul>
<p><code>getSuperclass();</code>：获取运行时类的父类</p>
<p><code>getGenericSuperclass()</code>：获取运行时带泛型的父类</p>
<p><strong>获取运行时类的带泛型的父类的泛型(重点)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    获取运行时类的带泛型的父类的泛型</span><br><span class="hljs-comment">    代码：逻辑性代码  vs 功能性代码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><br>        <span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> clazz.getGenericSuperclass();<br>        <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">paramType</span> <span class="hljs-operator">=</span> (ParameterizedType) genericSuperclass;<br>        <span class="hljs-comment">//获取泛型类型</span><br>        Type[] actualTypeArguments = paramType.getActualTypeArguments();<br><span class="hljs-comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span><br>        System.out.println(((Class)actualTypeArguments[<span class="hljs-number">0</span>]).getName());<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>如何操作运行时类中的指定的属性 – 需要掌握</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    如何操作运行时类中的指定的属性 -- 需要掌握</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testField1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><br>        <span class="hljs-comment">//创建运行时类的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) clazz.newInstance();<br><br>        <span class="hljs-comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br><br>        <span class="hljs-comment">//2.保证当前属性是可访问的</span><br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//3.获取、设置指定对象的此属性值</span><br>        name.set(p,<span class="hljs-string">&quot;Tom&quot;</span>);<br><br>        System.out.println(name.get(p));<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>如何操作运行时类中的指定的方法 – 需要掌握</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    如何操作运行时类中的指定的方法 -- 需要掌握</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><br>        <span class="hljs-comment">//创建运行时类的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) clazz.newInstance();<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.获取指定的某个方法</span><br><span class="hljs-comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">show</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;show&quot;</span>, String.class);<br>        <span class="hljs-comment">//2.保证当前方法是可访问的</span><br>        show.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span><br><span class="hljs-comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> show.invoke(p,<span class="hljs-string">&quot;CHN&quot;</span>); <span class="hljs-comment">//String nation = p.show(&quot;CHN&quot;);</span><br>        System.out.println(returnValue);<br><br>        System.out.println(<span class="hljs-string">&quot;*************如何调用静态方法*****************&quot;</span>);<br><br>        <span class="hljs-comment">// private static void showDesc()</span><br><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">showDesc</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;showDesc&quot;</span>);<br>        showDesc.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//如果调用的运行时类中的方法没有返回值，则此invoke()返回null</span><br><span class="hljs-comment">//        Object returnVal = showDesc.invoke(null);</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnVal</span> <span class="hljs-operator">=</span> showDesc.invoke(Person.class);<br>        System.out.println(returnVal);<span class="hljs-comment">//null</span><br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>如何调用运行时类中的指定的构造器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConstructor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Person.class;<br><br>        <span class="hljs-comment">//private Person(String name)</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.获取指定的构造器</span><br><span class="hljs-comment">        getDeclaredConstructor():参数：指明构造器的参数列表</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(String.class);<br><br>        <span class="hljs-comment">//2.保证此构造器是可访问的</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">//3.调用此构造器创建运行时类的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> (Person) constructor.newInstance(<span class="hljs-string">&quot;Tom&quot;</span>);<br>        System.out.println(per);<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h2><p>JDBC中的加载数据库驱动程序，Spring框架中加载bean对象，以及态代理，这些都使用到反射，因为我们要想理解一些框架的底层原理，反射是我们必须要掌握的</p>
<h1 id="Java-8-的新特性"><a href="#Java-8-的新特性" class="headerlink" title="Java 8 的新特性"></a>Java 8 的新特性</h1><h2 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h2><blockquote>
<p>概念：一个接口中的抽象方法只有一个，那么这个接口就是一个函数式接口。</p>
</blockquote>
<p>通过注解检测一个接口是否是函数式接口：<code>@FunctionallInterface</code></p>
<p>这是lambda表达式使用的前提。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><blockquote>
<p>lambda表达式是一个匿名函数，java 8允许把函数作为参数进行传递进方法中，（前提这个函数是函数式接口）</p>
</blockquote>
<h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>在对数据进行操作的时候，认为该数据一定有其他线程对它进行修改，因此在获取数据的时候会加锁，确保数据不会被其他线程修改，常见的使用悲观锁的机制为：<code>sychronized</code>和<code>lock</code></p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>在操作数据的时候 ，认为该数据不会被其他线程所修改，所以不会加锁，<strong>而是在更新的时候判断数据有没有被其他线程更新</strong>，如果数据没有被更新则成功写入，否则进行重试或抛出错误。常见的乐观锁是<code>CAS</code>和<code>版本控制</code></p>
<p><strong>CAS介绍：</strong></p>
<ul>
<li>CAS算法涉及到3个操作数：1、需要读写的内存值V；2、进行比较的值A；3、要写入的新值B。</li>
<li>当且仅当V的值等于A的值，CAS通过原子方式用B来更新V的值（<strong>比较+更新</strong>是一个原子操作）。否则不会执行。</li>
</ul>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220716231720069.png" srcset="/img/loading.gif" lazyload alt="image-20220716231720069"></p>
<p><strong>CAS存在的问题：</strong></p>
<ul>
<li><p><strong>ABA问题</strong>：一个线程把数据A变成了B，然后又重新变成了A，此时另一个线程读取该数据的时候，发现A没有变化，就误认为是原来的那个A，但是此时A的一些属性或状态已经发生过变化。</p>
<blockquote>
<p>解决办法：可以增加版本号（AtomicStampedReference对象），内存值每次修改后，版本号+1。<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42671172/article/details/108340791%E3%80%82%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8AtomicMarkableReference%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%88%A4%E6%96%AD%E4%BF%AE%E6%94%B9%E7%8A%B6%E6%80%81%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4%E3%80%82">https://blog.csdn.net/weixin_42671172/article/details/108340791。或者使用AtomicMarkableReference对象，判断修改状态是否一致。</a></p>
</blockquote>
</li>
<li><p><strong>循环时间长开销大问题：</strong> CAS如果长时间不成功，就会导致一直自旋，给CPU带来很大的消耗。</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作：</strong> 对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>
</li>
</ul>
<p><strong>两个锁适用的场景：</strong></p>
<ul>
<li>悲观锁<strong>适合写多的操作</strong>，先加锁可以确保数据写操作时的准确性</li>
<li>乐观锁<strong>适合读多的操作</strong>，不加锁的特点能够使读操作的性能得到提升</li>
</ul>
<h2 id="自旋锁和适应性自旋锁"><a href="#自旋锁和适应性自旋锁" class="headerlink" title="自旋锁和适应性自旋锁"></a>自旋锁和适应性自旋锁</h2><p><strong>自旋锁：</strong>就是让后面请求锁的线程不放弃CPU的时间，进行自旋等待，等前面的线程释放了锁，当前线程就可以获取锁了，这种省略了CPU对线程状态的转变，避免切换线程的开销。</p>
<pre><code class="hljs">因为唤醒和阻塞一个Java线程需要操作系统切换CPU的状态来完成。如果同步资源的锁定时间过短，为了这一小段的时间切换线程，线程挂起和恢复会让系统得不偿失。如果让两个或两个以上的线程同时并发执行，我们可以让后面那个请求锁的线程不放弃CPU执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。
</code></pre>
<p><strong>自旋锁执行流程：</strong><br>某个线程尝试获取同步资源锁失败，资源被占用—&gt;自旋锁—&gt;不放弃CPU时间片，通过自旋进行等待—&gt;再次尝试获取锁，获取成功—&gt;获取同步资源。<br><strong>非自旋锁的执行流程：</strong><br>某个线程尝试获取同步资源锁失败，资源被占用—&gt;非自旋锁—&gt;CPU切换状态,使当前线程进行休眠—&gt;CPU切换线程执行其他操作—&gt;占用同步资源的线程释放了的锁—&gt;恢复现场—&gt;再次尝试获取锁。</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/other-bukfsdjavassmtjstd-be0964a8-856a-45c9-ab75-ce9505c2e237.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><p>在说sychronized优化锁之前了解一下Java对象头，</p>
<p>对象在内存中的布局分为三块区域：对象头，实例数据和对齐填充。</p>
<p>对象头中包含两部分：MarkWord 和 类型指针。如果是数组对象的话，对象头还有一部分是存储数组的长度。</p>
<p><strong>MarkWord</strong>：用于存储对象自身的运行时数据，如 HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等等。</p>
<p><strong>类型指针：</strong>虚拟机通过这个指针确定该对象是哪个类的实例。</p>
<p><strong>对象头的长度：</strong></p>
<table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32&#x2F;64bit</td>
<td>MarkWord</td>
<td>存储对象的hashCode或锁信息等</td>
</tr>
<tr>
<td>32&#x2F;64bit</td>
<td>Class Metadada Address</td>
<td>存储对象类型数据的指针</td>
</tr>
<tr>
<td>32&#x2F;64bit</td>
<td>Array Length</td>
<td>数组的长度(如果当前对象是数组)</td>
</tr>
</tbody></table>
<p>****锁升级功能主要是依赖Mark Word中**同步锁标志位**和**是否偏向锁标志位**来实现的****。</p>
<p><img src="/2022/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98/image-20221128161846036.png" srcset="/img/loading.gif" lazyload alt="image-20221128161846036"></p>
<h2 id="Sychronized优化锁"><a href="#Sychronized优化锁" class="headerlink" title="Sychronized优化锁"></a>Sychronized优化锁</h2><p>级别从低到高依次是：</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<p>锁可以升级，但不能降级。即：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁是单向的。</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><table>
<thead>
<tr>
<th>25bit</th>
<th>4bit</th>
<th>1bit(是否是偏向锁)</th>
<th>2bit(锁标志位)</th>
</tr>
</thead>
<tbody><tr>
<td>对象的hashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody></table>
<p>无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一资源，但同时<strong>只能有一个线程</strong>修改成功。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><table>
<thead>
<tr>
<th>23bit</th>
<th>2bit</th>
<th>4bit</th>
<th>1bit</th>
<th>2bit</th>
</tr>
</thead>
<tbody><tr>
<td>线程ID</td>
<td>epoch</td>
<td>对象分代年龄</td>
<td>1</td>
<td>01</td>
</tr>
</tbody></table>
<p><strong>含义</strong></p>
<p>当线程A第一次竞争到锁的时候，通过操作修改MarkWord中的偏向线程ID，锁变为偏向模式，如果不存在其他线程的竞争，那么持有偏向锁的线程将永远不需要进行同步（不需要反复的获得锁和释放锁消耗资源）</p>
<p><strong>主要作用</strong></p>
<p>不存在其他线程竞争的情况下，不需要反复的获得和释放锁，减少性能的消耗</p>
<p><strong>场景</strong></p>
<p>有且只有一个线程访问的情况</p>
<p><strong>注意，偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</strong></p>
<p>当有其他线程进行竞争的时候，才会发生释放锁，检查锁的偏向线程 D与当前线程ID是否一致，如果一致直接进入同步。</p>
<p><strong>如果不等</strong>，表示发生了竞争，锁已经不是总是偏向于同一个线程了，这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新线程的ID，</p>
<p><strong>竞争成功</strong>，表示之前的线程不存在了，MarkWord里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁:<br><strong>竞争失败</strong>，这时候可能需要升级变为轻量级锁，才能保证线程问公平竞争锁。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>如果线程B竞争线程A失败了，则将偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。</strong></p>
<p><strong>含义</strong></p>
<p>多线程竞争，但是任一时刻最多只有一个线程竞争（也就是两个线程在竞争同一个资源）</p>
<p><strong>场景</strong></p>
<p>有两个线程来交替访问进行竞争</p>
<p>**主要目的:**在没有多线程竞争的前提下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗，说白了先自旋，不行才升级阻塞</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>如果自旋多次，则升级为重量级锁。<strong>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</strong></p>
<p><strong>含义</strong></p>
<p>直接到操作系统级别，使用monitor管程</p>
<p><strong>场景</strong></p>
<p>多个线程来访问竞争</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>首先要明确一点是引入这些锁是为了提高获取锁的效率, 要明白每种锁的使用场景, 比如<strong>偏向锁适合一个线程对一个锁的多次获取的情况</strong>; <strong>轻量级锁适合锁执行体比较简单(即减少锁粒度或时间), 自旋一会儿就可以成功获取锁的情况.</strong></p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%A0%A1%E6%8B%9B/" class="category-chain-item">校招</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%A0%A1%E6%8B%9B/%E5%BC%80%E5%8F%91/" class="category-chain-item">开发</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试题-java基础</div>
      <div>http://example.com/2022/06/21/面试题/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>zlw</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月21日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/23/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/" title="表达式求值">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">表达式求值</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/20/%E6%A8%A1%E6%9D%BF2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="模板2-数据结构">
                        <span class="hidden-mobile">模板2-数据结构</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"enable":true,"appId":"8pDDCsRJCVNm1OXHuh0xASVj-gzGzoHsz","appKey":"MnpSoeG5QTTJ4GagUMOq5t7J","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://8pddcsrj.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       #<a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> #<i class="iconfont icon-love"></i> #<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> #<a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> #<i class="iconfont icon-love"></i> #<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div>张露文的博客 | 记录成长过程</div> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
